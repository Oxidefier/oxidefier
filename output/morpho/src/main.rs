// Generated by Oxidefier

#![allow(mixed_script_confusables)]
#![allow(non_snake_case)]
#![allow(uncommon_codepoints)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod morpho {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn cleanup_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
        Ok(cleaned)
    }

    pub fn cleanup_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = cleanup_uint160(value, context)?;
        Ok(cleaned)
    }

    pub fn validator_revert_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if iszero(eq(value, cleanup_address(value, context)?, context)?, context)? != U256::ZERO {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        }
        Ok(())
    }

    pub fn abi_decode_address_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value = U256::ZERO;
        value = mload(offset, context)?;
        validator_revert_address(value, context)?;
        Ok(value)
    }

    pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn abi_decode_tuple_address_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value0 = U256::ZERO;
        if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
        }
        value0 = abi_decode_address_fromMemory(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
        Ok(value0)
    }

    pub fn abi_encode_address<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(pos, cleanup_address(value, context)?, context)?;
        Ok(())
    }

    pub fn cleanup_bytes32<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn abi_encode_bytes32<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(pos, cleanup_bytes32(value, context)?, context)?;
        Ok(())
    }

    pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn abi_encode_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(pos, cleanup_uint256(value, context)?, context)?;
        Ok(())
    }

    pub fn abi_encode_bytes32_uint256_address<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut tail = U256::ZERO;
        tail = add(headStart, U256::from(0x60u128), context)?;
        abi_encode_bytes32(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
        abi_encode_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
        abi_encode_address(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
        Ok(tail)
    }

    pub fn array_length_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut length = U256::ZERO;
        length = mload(value, context)?;
        Ok(length)
    }

    pub fn array_storeLengthForEncoding_string<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut updated_pos = U256::ZERO;
        mstore(pos, length, context)?;
        updated_pos = add(pos, U256::from(0x20u128), context)?;
        Ok(updated_pos)
    }

    pub fn copy_memory_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mcopy(dst, src, length, context)?;
        mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn round_up_to_mul_of<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
        Ok(result)
    }

    pub fn abi_encode_string_memory_ptr<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut end_ = U256::ZERO;
        let length = array_length_string(value, context)?;
        pos = array_storeLengthForEncoding_string(pos, length, context)?;
        copy_memory_to_memory_with_cleanup(add(value, U256::from(0x20u128), context)?, pos, length, context)?;
        end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
        Ok(end_)
    }

    pub fn abi_encode_string<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut tail = U256::ZERO;
        tail = add(headStart, U256::from(0x20u128), context)?;
        mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
        tail = abi_encode_string_memory_ptr(value0, tail, context)?;
        Ok(tail)
    }

    pub fn abi_encode_tuple<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut tail = U256::ZERO;
        tail = add(headStart, U256::from(0x0u128), context)?;
        Ok(tail)
    }

    pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn panic_error_0x41<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
        mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
        revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
        Ok(())
    }

    pub fn finalize_allocation<CI>(memPtr: U256, size: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
        if or(gt(newFreePtr, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        mstore(U256::from(0x40u128), newFreePtr, context)?;
        Ok(())
    }

    pub fn allocate_memory<CI>(size: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = allocate_unbounded(context)?;
        finalize_allocation(memPtr, size, context)?;
        Ok(memPtr)
    }

    pub fn array_allocation_size_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut size = U256::ZERO;
        if gt(length, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        size = round_up_to_mul_of(length, context)?;
        size = add(size, U256::from(0x20u128), context)?;
        Ok(size)
    }

    pub fn allocate_memory_array_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        let allocSize = array_allocation_size_string(length, context)?;
        memPtr = allocate_memory(allocSize, context)?;
        mstore(memPtr, length, context)?;
        Ok(memPtr)
    }

    pub fn array_dataslot_bytes<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut data = U256::ZERO;
        data = ptr;
        data = add(ptr, U256::from(0x20u128), context)?;
        Ok(data)
    }

    pub fn array_length_bytes<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut length = U256::ZERO;
        length = mload(value, context)?;
        Ok(length)
    }

    pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn constant_DOMAIN_TYPEHASH<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        let expr = U256::from_be_slice(&[0x47, 0xe7, 0x95, 0x34, 0xa2, 0x45, 0x95, 0x2e, 0x8b, 0x16, 0x89, 0x3a, 0x33, 0x6b, 0x85, 0xa3, 0xd9, 0xea, 0x9f, 0xa8, 0xc5, 0x73, 0xf3, 0xd8, 0x03, 0xaf, 0xb9, 0x2a, 0x79, 0x46, 0x92, 0x18]);
        ret = expr;
        Ok(ret)
    }

    pub fn store_literal_in_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7a65726f20616464726573730000000000000000000000000000000000000000"), context)?;
        Ok(())
    }

    pub fn copy_literal_to_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = allocate_memory_array_string(U256::from(0xcu128), context)?;
        store_literal_in_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7(add(memPtr, U256::from(0x20u128), context)?, context)?;
        Ok(memPtr)
    }

    pub fn convert_stringliteral_a4b4_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = copy_literal_to_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7(context)?;
        Ok(converted)
    }

    pub fn constant_ZERO_ADDRESS<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret_mpos = U256::ZERO;
        let _mpos = convert_stringliteral_a4b4_to_string(context)?;
        ret_mpos = _mpos;
        Ok(ret_mpos)
    }

    pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn convert_uint160_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint160(identity(cleanup_uint160(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn convert_uint160_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_uint160(value, context)?;
        Ok(converted)
    }

    pub fn convert_address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_address(value, context)?;
        Ok(converted)
    }

    pub fn convert_contract_Morpho_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_address(value, context)?;
        Ok(converted)
    }

    pub fn convert_rational_by_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint160(identity(cleanup_rational_by(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn convert_rational_by_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_rational_by_to_uint160(value, context)?;
        Ok(converted)
    }

    pub fn require_helper_string<CI>(condition: U256, expr_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if iszero(condition, context)? != U256::ZERO {
            let memPtr = allocate_unbounded(context)?;
            mstore(memPtr, shl(U256::from(0xe5u128), U256::from(0x461bcdu128), context)?, context)?;
            let end_ = abi_encode_string(add(memPtr, U256::from(0x4u128), context)?, expr_mpos, context)?;
            revert(memPtr, sub(end_, memPtr, context)?, context)?;
        }
        Ok(())
    }

    pub fn prepare_store_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn shift_left<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shl(U256::from(0x0u128), value, context)?;
        Ok(newValue)
    }

    pub fn update_byte_slice_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let mask = sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?;
        toInsert = shift_left(toInsert, context)?;
        value = and(value, not(mask, context)?, context)?;
        result = or(value, and(toInsert, mask, context)?, context)?;
        Ok(result)
    }

    pub fn update_storage_value_offsett_address_to_address<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let convertedValue = convert_address_to_address(value, context)?;
        sstore(slot, update_byte_slice_shift(sload(slot, context)?, prepare_store_address(convertedValue, context)?, context)?, context)?;
        Ok(())
    }

    pub fn constructor_Morpho<CI>(var_newOwner: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
        let expr_1 = iszero(eq(cleanup_address(var_newOwner, context)?, cleanup_address(expr, context)?, context)?, context)?;
        let expr_mpos = constant_ZERO_ADDRESS(context)?;
        require_helper_string(expr_1, expr_mpos, context)?;
        let expr_2 = constant_DOMAIN_TYPEHASH(context)?;
        let expr_3 = convert_contract_Morpho_to_address(address(context)?, context)?;
        let expr_143_mpos = allocate_unbounded(context)?;
        let _1 = add(expr_143_mpos, U256::from(0x20u128), context)?;
        let _2 = abi_encode_bytes32_uint256_address(_1, expr_2, chainid(context)?, expr_3, context)?;
        mstore(expr_143_mpos, sub(_2, _1, context)?, context)?;
        finalize_allocation(expr_143_mpos, sub(_2, expr_143_mpos, context)?, context)?;
        let expr_4 = keccak256(array_dataslot_bytes(expr_143_mpos, context)?, array_length_bytes(expr_143_mpos, context)?, context)?;
        mstore(U256::from(0x80u128), expr_4, context)?;
        update_storage_value_offsett_address_to_address(U256::from(0x0u128), var_newOwner, context)?;
        let _3 = convert_address_to_address(var_newOwner, context)?;
        let _4 = allocate_unbounded(context)?;
        let _5 = abi_encode_tuple(_4, context)?;
        log2(_4, sub(_5, _4, context)?, U256::from_be_slice(&[0x16, 0x7d, 0x3e, 0x9c, 0x10, 0x16, 0xab, 0x80, 0xe5, 0x88, 0x02, 0xca, 0x9d, 0xa1, 0x0c, 0xe5, 0xc6, 0xa0, 0xf4, 0xde, 0xbc, 0x46, 0xa2, 0xe7, 0xa2, 0xcd, 0x9e, 0x56, 0x89, 0x9a, 0x4f, 0xb5]), _3, context)?;
        Ok(())
    }

    pub fn copy_arguments_for_constructor_object_Morpho<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret_param = U256::ZERO;
        let programSize = datasize(from_hex("4d6f7270686f5f32323637000000000000000000000000000000000000000000"), context)?;
        let argSize = sub(codesize(context)?, programSize, context)?;
        let memoryDataOffset = allocate_memory(argSize, context)?;
        codecopy(memoryDataOffset, programSize, argSize, context)?;
        ret_param = abi_decode_tuple_address_fromMemory(memoryDataOffset, add(memoryDataOffset, argSize, context)?, context)?;
        Ok(ret_param)
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0xa0u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let _1 = copy_arguments_for_constructor_object_Morpho(context)?;
        constructor_Morpho(_1, context)?;
        let _2 = allocate_unbounded(context)?;
        codecopy(_2, dataoffset(from_hex("4d6f7270686f5f323236375f6465706c6f796564000000000000000000000000"), context)?, datasize(from_hex("4d6f7270686f5f323236375f6465706c6f796564000000000000000000000000"), context)?, context)?;
        setimmutable(_2, from_hex("3634000000000000000000000000000000000000000000000000000000000000"), mload(U256::from(0x80u128), context)?, context)?;
        return_(_2, datasize(from_hex("4d6f7270686f5f323236375f6465706c6f796564000000000000000000000000"), context)?, context)?;
        Ok(())
    }

    pub mod morpho_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            Ok(())
        }

        pub fn cleanup_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = cleanup_uint160(value, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_address(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_address<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_address(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn cleanup_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = iszero(iszero(value, context)?, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_bool(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_bool<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_bool(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_bool<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_bool(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_bytes_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x1u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_addresst_uint256t_bytes_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x40u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value2, value3) = abi_decode_bytes_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3))
        }

        pub fn abi_decode_array_bytes32_dyn_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x20u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_bytes32_dyn_calldata_ptr<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value0, value1) = abi_decode_array_bytes32_dyn_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_t_bool_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = mload(offset, context)?;
            validator_revert_bool(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_bool_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_t_bool_fromMemory(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            Ok(())
        }

        pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x41<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn round_up_to_mul_of<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
            Ok(result)
        }

        pub fn finalize_allocation<CI>(memPtr: U256, size: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
            if or(gt(newFreePtr, U256::from(0xffffffffffffffffu128), context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            mstore(U256::from(0x40u128), newFreePtr, context)?;
            Ok(())
        }

        pub fn allocate_memory<CI>(size: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            finalize_allocation(memPtr, size, context)?;
            Ok(memPtr)
        }

        pub fn revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_struct_Authorization<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0xa0u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0xa0u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_address(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_address(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_bool(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x60u128), context)?, abi_decode_uint256(add(headStart, U256::from(0x60u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x80u128), context)?, abi_decode_uint256(add(headStart, U256::from(0x80u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn revert_error_21fe6b43b4db61d76a176e95bf1a6b9ede4c301f93a4246f41fecb96e160861d<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_struct_Signature_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, offset, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_21fe6b43b4db61d76a176e95bf1a6b9ede4c301f93a4246f41fecb96e160861d(context)?;
            }
            value = offset;
            Ok(value)
        }

        pub fn abi_decode_struct_Authorizationt_struct_Signature_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x100u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_Authorization(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_struct_Signature_calldata(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_struct_MarketParams_memory_ptr<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0xa0u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0xa0u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_address(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_address(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_address(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x60u128), context)?, abi_decode_address(add(headStart, U256::from(0x60u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x80u128), context)?, abi_decode_uint256(add(headStart, U256::from(0x80u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn abi_decode_struct_MarketParams<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0xa0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_MarketParams_memory_ptr(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_struct_MarketParamst_addresst_uint256t_uint256t_bytes_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            let mut value5 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x120u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_MarketParams_memory_ptr(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0xc0u128), context)?, dataEnd, context)?;
            value3 = abi_decode_uint256(add(headStart, U256::from(0xe0u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x100u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value4, value5) = abi_decode_bytes_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4, value5))
        }

        pub fn abi_decode_struct_MarketParamst_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0xc0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_MarketParams_memory_ptr(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_struct_MarketParamst_uint256t_addresst_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x100u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_MarketParams_memory_ptr(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value2 = abi_decode_address(add(headStart, U256::from(0xc0u128), context)?, dataEnd, context)?;
            value3 = abi_decode_address(add(headStart, U256::from(0xe0u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3))
        }

        pub fn abi_decode_struct_MarketParamst_uint256t_addresst_bytes_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x100u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_MarketParams_memory_ptr(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value2 = abi_decode_address(add(headStart, U256::from(0xc0u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0xe0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value3, value4) = abi_decode_bytes_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4))
        }

        pub fn abi_decode_struct_MarketParamst_uint256t_uint256t_addresst_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x120u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_MarketParams_memory_ptr(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0xc0u128), context)?, dataEnd, context)?;
            value3 = abi_decode_address(add(headStart, U256::from(0xe0u128), context)?, dataEnd, context)?;
            value4 = abi_decode_address(add(headStart, U256::from(0x100u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4))
        }

        pub fn abi_decode_struct_MarketParamst_uint256t_uint256t_addresst_bytes_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            let mut value5 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x120u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_struct_MarketParams_memory_ptr(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0xc0u128), context)?, dataEnd, context)?;
            value3 = abi_decode_address(add(headStart, U256::from(0xe0u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x100u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value4, value5) = abi_decode_bytes_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4, value5))
        }

        pub fn abi_decode_t_uint256_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = mload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_tuple_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_tuple_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn cleanup_bytes32<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_userDefinedValueType_Id<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_bytes32(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_userDefinedValueType_Id<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_userDefinedValueType_Id(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_tuple_userDefinedValueType_Id<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_userDefinedValueType_Id(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_uint256_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_t_uint256_fromMemory(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_userDefinedValueType_Idt_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_userDefinedValueType_Id(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_encode_bytes32<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bytes32(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encodeUpdatedPos_bytes32<CI>(value0: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updatedPos = U256::ZERO;
            abi_encode_bytes32(value0, pos, context)?;
            updatedPos = add(pos, U256::from(0x20u128), context)?;
            Ok(updatedPos)
        }

        pub fn abi_encode_address<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256_to_uint256_fromStack<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_address_address_address_address_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, value3: U256, value4: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0xa0u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_address(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            abi_encode_address(value3, add(headStart, U256::from(0x60u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value4, add(headStart, U256::from(0x80u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_address_address_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_address_to_address<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_address_uint256<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_address_uint256_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_dataslot_array_bytes32_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_bytes32_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_nextElement_array_bytes32_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut next = U256::ZERO;
            next = add(ptr, U256::from(0x20u128), context)?;
            Ok(next)
        }

        pub fn array_storeLengthForEncoding_array_bytes32_dyn<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_array_bytes32_dyn_memory_ptr<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_array_bytes32_dyn(value, context)?;
            pos = array_storeLengthForEncoding_array_bytes32_dyn(pos, length, context)?;
            let baseRef = array_dataslot_array_bytes32_dyn(value, context)?;
            let mut srcPtr = baseRef;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    let elementValue0 = mload(srcPtr, context)?;
                    pos = abi_encodeUpdatedPos_bytes32(elementValue0, pos, context)?;
                    srcPtr = array_nextElement_array_bytes32_dyn(srcPtr, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            end_ = pos;
            Ok(end_)
        }

        pub fn abi_encode_array_bytes32_dyn<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_bytes32_dyn_memory_ptr(value0, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_bool<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bool_to_bool<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bytes32_to_bytes32<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bytes32(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256_to_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_Authorization<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            let memberValue0_2 = mload(add(value, U256::from(0x40u128), context)?, context)?;
            abi_encode_bool(memberValue0_2, add(pos, U256::from(0x40u128), context)?, context)?;
            let memberValue0_3 = mload(add(value, U256::from(0x60u128), context)?, context)?;
            abi_encode_uint256_to_uint256(memberValue0_3, add(pos, U256::from(0x60u128), context)?, context)?;
            let memberValue0_4 = mload(add(value, U256::from(0x80u128), context)?, context)?;
            abi_encode_uint256_to_uint256(memberValue0_4, add(pos, U256::from(0x80u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bytes32_struct_Authorization<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0xc0u128), context)?;
            abi_encode_bytes32_to_bytes32(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_struct_Authorization(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn leftAlign_bytes32<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut aligned = U256::ZERO;
            aligned = value;
            Ok(aligned)
        }

        pub fn abi_encode_bytes32_to_bytes32_nonPadded_inplace<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, leftAlign_bytes32(cleanup_bytes32(value, context)?, context)?, context)?;
            Ok(())
        }

        pub fn cleanup_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffu128), context)?;
            Ok(cleaned)
        }

        pub fn abi_encode_uint8<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint8(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bytes32_uint8_bytes32_bytes32<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, value3: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x80u128), context)?;
            abi_encode_bytes32_to_bytes32(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint8(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_bytes32_to_bytes32(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            abi_encode_bytes32_to_bytes32(value3, add(headStart, U256::from(0x60u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_storeLengthForEncoding_bytes<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn copy_calldata_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            calldatacopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_encode_bytes_calldata<CI>(start: U256, length: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = array_storeLengthForEncoding_bytes(pos, length, context)?;
            copy_calldata_to_memory_with_cleanup(start, pos, length, context)?;
            end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
            Ok(end_)
        }

        pub fn abi_encode_stringliteral_301a<CI>(pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, shl(U256::from(0xf0u128), U256::from(0x1901u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_packed_stringliteral_301a_bytes32_bytes32<CI>(mut pos: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            abi_encode_stringliteral_301a(pos, context)?;
            pos = add(pos, U256::from(0x2u128), context)?;
            abi_encode_bytes32_to_bytes32_nonPadded_inplace(value0, pos, context)?;
            pos = add(pos, U256::from(0x20u128), context)?;
            abi_encode_bytes32_to_bytes32_nonPadded_inplace(value1, pos, context)?;
            pos = add(pos, U256::from(0x20u128), context)?;
            end_ = pos;
            Ok(end_)
        }

        pub fn array_length_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_storeLengthForEncoding_string<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn copy_memory_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mcopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_encode_string_memory_ptr<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_string(value, context)?;
            pos = array_storeLengthForEncoding_string(pos, length, context)?;
            copy_memory_to_memory_with_cleanup(add(value, U256::from(0x20u128), context)?, pos, length, context)?;
            end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
            Ok(end_)
        }

        pub fn abi_encode_string<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_string_memory_ptr(value0, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_struct_MarketParams_memory_ptr<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            let memberValue0_2 = mload(add(value, U256::from(0x40u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0_2, add(pos, U256::from(0x40u128), context)?, context)?;
            let memberValue0_3 = mload(add(value, U256::from(0x60u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0_3, add(pos, U256::from(0x60u128), context)?, context)?;
            let memberValue0_4 = mload(add(value, U256::from(0x80u128), context)?, context)?;
            abi_encode_uint256_to_uint256(memberValue0_4, add(pos, U256::from(0x80u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_MarketParams<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0xa0u128), context)?;
            abi_encode_struct_MarketParams_memory_ptr(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn cleanup_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn abi_encode_uint128_to_uint128<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn cleanup_from_storage_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn shift_right_128_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0x80u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_16t_uint128<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint128(shift_right_128_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn shift_right_0_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offsett_uint128<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint128(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn abi_encode_struct_Market_storage<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let mut slotValue = U256::from(0x0u128);
            slotValue = sload(add(value, U256::from(0x0u128), context)?, context)?;
            let memberValue0 = extract_from_storage_value_offsett_uint128(slotValue, context)?;
            abi_encode_uint128_to_uint128(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = extract_from_storage_value_offset_16t_uint128(slotValue, context)?;
            abi_encode_uint128_to_uint128(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            slotValue = sload(add(value, U256::from(0x1u128), context)?, context)?;
            let memberValue0_2 = extract_from_storage_value_offsett_uint128(slotValue, context)?;
            abi_encode_uint128_to_uint128(memberValue0_2, add(pos, U256::from(0x40u128), context)?, context)?;
            let memberValue0_3 = extract_from_storage_value_offset_16t_uint128(slotValue, context)?;
            abi_encode_uint128_to_uint128(memberValue0_3, add(pos, U256::from(0x60u128), context)?, context)?;
            slotValue = sload(add(value, U256::from(0x2u128), context)?, context)?;
            let memberValue0_4 = extract_from_storage_value_offsett_uint128(slotValue, context)?;
            abi_encode_uint128_to_uint128(memberValue0_4, add(pos, U256::from(0x80u128), context)?, context)?;
            let memberValue0_5 = extract_from_storage_value_offset_16t_uint128(slotValue, context)?;
            abi_encode_uint128_to_uint128(memberValue0_5, add(pos, U256::from(0xa0u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_MarketParams_struct_Market_storage<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x160u128), context)?;
            abi_encode_struct_MarketParams_memory_ptr(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_struct_Market_storage(value1, add(headStart, U256::from(0xa0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x0u128), context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_address<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_bool<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bool_to_bool(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_bytes32<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bytes32_to_bytes32(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint128_uint128_uint128_uint128_uint128_uint128<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, value3: U256, value4: U256, value5: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0xc0u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            abi_encode_uint128(value3, add(headStart, U256::from(0x60u128), context)?, context)?;
            abi_encode_uint128(value4, add(headStart, U256::from(0x80u128), context)?, context)?;
            abi_encode_uint128(value5, add(headStart, U256::from(0xa0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint256_to_uint256_fromStack(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_bytes_calldata<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint256_to_uint256_fromStack(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            mstore(add(headStart, U256::from(0x20u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_bytes_calldata(value1, value2, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint128_uint128<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256_fromStack(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint256<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint256_to_uint256_fromStack(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint256_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256_fromStack(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint256_uint256_uint256_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, value3: U256, value4: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0xa0u128), context)?;
            abi_encode_uint256_to_uint256_fromStack(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value3, add(headStart, U256::from(0x60u128), context)?, context)?;
            abi_encode_uint256_to_uint256_fromStack(value4, add(headStart, U256::from(0x80u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_allocation_size_array_bytes32_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn allocate_memory_array_array_bytes32_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_array_bytes32_dyn(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn zero_memory_chunk_bytes32<CI>(dataStart: U256, dataSizeInBytes: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            calldatacopy(dataStart, calldatasize(context)?, dataSizeInBytes, context)?;
            Ok(())
        }

        pub fn allocate_and_zero_memory_array_array_bytes32_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_array_bytes32_dyn(length, context)?;
            let mut dataStart = memPtr;
            let mut dataSize = array_allocation_size_array_bytes32_dyn(length, context)?;
            dataStart = add(memPtr, U256::from(0x20u128), context)?;
            dataSize = sub(dataSize, U256::from(0x20u128), context)?;
            zero_memory_chunk_bytes32(dataStart, dataSize, context)?;
            Ok(memPtr)
        }

        pub fn array_allocation_size_bytes<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = round_up_to_mul_of(length, context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn allocate_memory_array_bytes<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_bytes(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn array_allocation_size_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = round_up_to_mul_of(length, context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn allocate_memory_array_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_string(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn array_dataslot_bytes<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_bytes32_dyn_calldata<CI>(value: U256, len: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = len;
            Ok(length)
        }

        pub fn array_length_bytes<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_length_bytes_calldata<CI>(value: U256, len: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = len;
            Ok(length)
        }

        pub fn bytes_concat_stringliteral_301a_bytes32_bytes32<CI>(param: U256, param_1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut outPtr = U256::ZERO;
            outPtr = allocate_unbounded(context)?;
            let dataStart = add(outPtr, U256::from(0x20u128), context)?;
            let dataEnd = abi_encode_packed_stringliteral_301a_bytes32_bytes32(dataStart, param, param_1, context)?;
            mstore(outPtr, sub(dataEnd, dataStart, context)?, context)?;
            finalize_allocation(outPtr, sub(dataEnd, outPtr, context)?, context)?;
            Ok(outPtr)
        }

        pub fn panic_error_0x32<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x32u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn calldata_array_index_access_bytes32_dyn_calldata<CI>(base_ref: U256, length: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, length, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            addr = add(base_ref, mul(index, U256::from(0x20u128), context)?, context)?;
            Ok(addr)
        }

        pub fn panic_error_0x11<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_add_uint128<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            x = cleanup_uint128(x, context)?;
            y = cleanup_uint128(y, context)?;
            sum = add(x, y, context)?;
            if gt(sum, U256::from(0xffffffffffffffffffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn checked_add_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            sum = add(x, y, context)?;
            if gt(x, sum, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn panic_error_0x12<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x12u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_div_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut r = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            if iszero(y, context)? != U256::ZERO {
                panic_error_0x12(context)?;
            }
            r = div(x, y, context)?;
            Ok(r)
        }

        pub fn checked_mul_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut product = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            product = cleanup_uint256(mul(x, y, context)?, context)?;
            if iszero(or(iszero(x, context)?, eq(y, div(product, x, context)?, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(product)
        }

        pub fn checked_sub_uint128<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            x = cleanup_uint128(x, context)?;
            y = cleanup_uint128(y, context)?;
            diff = sub(x, y, context)?;
            if gt(diff, U256::from(0xffffffffffffffffffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(diff)
        }

        pub fn checked_sub_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            diff = sub(x, y, context)?;
            if gt(diff, x, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(diff)
        }

        pub fn cleanup_from_storage_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffu128), context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_0_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1000000000000000000000000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1150000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_250000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_3_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn store_literal_in_memory_f6c00b09d2d55d4b94163c927f1e37be0dfa382ef0d91c45cde1d8cac8030b1d<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("616c726561647920736574000000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_f6c00b09d2d55d4b94163c927f1e37be0dfa382ef0d91c45cde1d8cac8030b1d<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0xbu128), context)?;
            store_literal_in_memory_f6c00b09d2d55d4b94163c927f1e37be0dfa382ef0d91c45cde1d8cac8030b1d(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_f6c0_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_f6c00b09d2d55d4b94163c927f1e37be0dfa382ef0d91c45cde1d8cac8030b1d(context)?;
            Ok(converted)
        }

        pub fn constant_ALREADY_SET<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _mpos = convert_stringliteral_f6c0_to_string(context)?;
            ret_mpos = _mpos;
            Ok(ret_mpos)
        }

        pub fn constant_AUTHORIZATION_TYPEHASH<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let expr = U256::from_be_slice(&[0x81, 0xd0, 0x28, 0x4f, 0xb0, 0xe2, 0xcd, 0xe1, 0x8d, 0x05, 0x53, 0xb0, 0x61, 0x89, 0xd6, 0xf7, 0x61, 0x3c, 0x96, 0xa0, 0x1b, 0xb5, 0xb5, 0xe7, 0x82, 0x8e, 0xad, 0xe6, 0xa0, 0xdc, 0xac, 0x91]);
            ret = expr;
            Ok(ret)
        }

        pub fn store_literal_in_memory_e190310e18d17f1064beb01f6d8e74924f4b126b0e55460f01b0d81f2a1e4c40<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("706f736974696f6e206973206865616c74687900000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_e190310e18d17f1064beb01f6d8e74924f4b126b0e55460f01b0d81f2a1e4c40<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x13u128), context)?;
            store_literal_in_memory_e190310e18d17f1064beb01f6d8e74924f4b126b0e55460f01b0d81f2a1e4c40(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_e190_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_e190310e18d17f1064beb01f6d8e74924f4b126b0e55460f01b0d81f2a1e4c40(context)?;
            Ok(converted)
        }

        pub fn constant_HEALTHY_POSITION<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _723_mpos = convert_stringliteral_e190_to_string(context)?;
            ret_mpos = _723_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_af014e38b7c5f227cd14c59116f3da8dd63513df483ec13a5a17d6093fb510a6<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("696e636f6e73697374656e7420696e7075740000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_af014e38b7c5f227cd14c59116f3da8dd63513df483ec13a5a17d6093fb510a6<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x12u128), context)?;
            store_literal_in_memory_af014e38b7c5f227cd14c59116f3da8dd63513df483ec13a5a17d6093fb510a6(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_af01_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_af014e38b7c5f227cd14c59116f3da8dd63513df483ec13a5a17d6093fb510a6(context)?;
            Ok(converted)
        }

        pub fn constant_INCONSISTENT_INPUT<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _33_mpos = convert_stringliteral_af01_to_string(context)?;
            ret_mpos = _33_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_3b807cd2312cb7a8816bf8f90c8b8fabc63939f2d074d6f3426cd3f6aa264952<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("696e73756666696369656e7420636f6c6c61746572616c000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_3b807cd2312cb7a8816bf8f90c8b8fabc63939f2d074d6f3426cd3f6aa264952<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x17u128), context)?;
            store_literal_in_memory_3b807cd2312cb7a8816bf8f90c8b8fabc63939f2d074d6f3426cd3f6aa264952(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_3b80_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_3b807cd2312cb7a8816bf8f90c8b8fabc63939f2d074d6f3426cd3f6aa264952(context)?;
            Ok(converted)
        }

        pub fn constant_INSUFFICIENT_COLLATERAL<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _283_mpos = convert_stringliteral_3b80_to_string(context)?;
            ret_mpos = _283_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_ee16f499aa24e0ee394849a0c205c7424513d7e3afc7cb8ee1d45156f4e28a49<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("696e73756666696369656e74206c697175696469747900000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_ee16f499aa24e0ee394849a0c205c7424513d7e3afc7cb8ee1d45156f4e28a49<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x16u128), context)?;
            store_literal_in_memory_ee16f499aa24e0ee394849a0c205c7424513d7e3afc7cb8ee1d45156f4e28a49(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_ee16_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_ee16f499aa24e0ee394849a0c205c7424513d7e3afc7cb8ee1d45156f4e28a49(context)?;
            Ok(converted)
        }

        pub fn constant_INSUFFICIENT_LIQUIDITY<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _296_mpos = convert_stringliteral_ee16_to_string(context)?;
            ret_mpos = _296_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_71713bd5478b586cac708caace92720e83db31d1de15cf938f760684d5501e10<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("696e76616c6964206e6f6e636500000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_71713bd5478b586cac708caace92720e83db31d1de15cf938f760684d5501e10<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0xdu128), context)?;
            store_literal_in_memory_71713bd5478b586cac708caace92720e83db31d1de15cf938f760684d5501e10(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_7171_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_71713bd5478b586cac708caace92720e83db31d1de15cf938f760684d5501e10(context)?;
            Ok(converted)
        }

        pub fn constant_INVALID_NONCE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _452_mpos = convert_stringliteral_7171_to_string(context)?;
            ret_mpos = _452_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_12a179e1a73f41ef8e1ba2f259a99bc53b6ace3abb110ac2ea058e42c6104e1a<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("696e76616c6964207369676e6174757265000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_12a179e1a73f41ef8e1ba2f259a99bc53b6ace3abb110ac2ea058e42c6104e1a<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x11u128), context)?;
            store_literal_in_memory_12a179e1a73f41ef8e1ba2f259a99bc53b6ace3abb110ac2ea058e42c6104e1a(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_12a1_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_12a179e1a73f41ef8e1ba2f259a99bc53b6ace3abb110ac2ea058e42c6104e1a(context)?;
            Ok(converted)
        }

        pub fn constant_INVALID_SIGNATURE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _474_mpos = convert_stringliteral_12a1_to_string(context)?;
            ret_mpos = _474_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_2d8ebf55c9b8ace72ef0bf1b62cf64f9d3f1a9443d63532ea5a55317476ddf2b<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("49524d206e6f7420656e61626c65640000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_2d8ebf55c9b8ace72ef0bf1b62cf64f9d3f1a9443d63532ea5a55317476ddf2b<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0xfu128), context)?;
            store_literal_in_memory_2d8ebf55c9b8ace72ef0bf1b62cf64f9d3f1a9443d63532ea5a55317476ddf2b(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_2d8e_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_2d8ebf55c9b8ace72ef0bf1b62cf64f9d3f1a9443d63532ea5a55317476ddf2b(context)?;
            Ok(converted)
        }

        pub fn constant_IRM_NOT_ENABLED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _561_mpos = convert_stringliteral_2d8e_to_string(context)?;
            ret_mpos = _561_mpos;
            Ok(ret_mpos)
        }

        pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_t_rational_by_to_t_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_LIQUIDATION_CURSOR<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_t_rational_by_to_t_uint256(U256::from(0x429d069189e0000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn store_literal_in_memory_f0eb92cdd1b31b002c2ec568fbb7dbc78ecc4b2665fe50a65f491e029f0661b7<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("4c4c5456206e6f7420656e61626c656400000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_f0eb92cdd1b31b002c2ec568fbb7dbc78ecc4b2665fe50a65f491e029f0661b7<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x10u128), context)?;
            store_literal_in_memory_f0eb92cdd1b31b002c2ec568fbb7dbc78ecc4b2665fe50a65f491e029f0661b7(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_f0eb_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_f0eb92cdd1b31b002c2ec568fbb7dbc78ecc4b2665fe50a65f491e029f0661b7(context)?;
            Ok(converted)
        }

        pub fn constant_LLTV_NOT_ENABLED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _568_mpos = convert_stringliteral_f0eb_to_string(context)?;
            ret_mpos = _568_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_c924f76f855a219f278c48882fd037797f0591c2cef019229af291964c4d3b43<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("6d61726b657420616c7265616479206372656174656400000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_c924f76f855a219f278c48882fd037797f0591c2cef019229af291964c4d3b43<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x16u128), context)?;
            store_literal_in_memory_c924f76f855a219f278c48882fd037797f0591c2cef019229af291964c4d3b43(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_c924_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_c924f76f855a219f278c48882fd037797f0591c2cef019229af291964c4d3b43(context)?;
            Ok(converted)
        }

        pub fn constant_MARKET_ALREADY_CREATED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _575_mpos = convert_stringliteral_c924_to_string(context)?;
            ret_mpos = _575_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_1798fe1b45706024844fe1ae37566f71d02866731bfe8dd8db26da9baccb8204<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("6d61726b6574206e6f7420637265617465640000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_1798fe1b45706024844fe1ae37566f71d02866731bfe8dd8db26da9baccb8204<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x12u128), context)?;
            store_literal_in_memory_1798fe1b45706024844fe1ae37566f71d02866731bfe8dd8db26da9baccb8204(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_1798_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_1798fe1b45706024844fe1ae37566f71d02866731bfe8dd8db26da9baccb8204(context)?;
            Ok(converted)
        }

        pub fn constant_MARKET_NOT_CREATED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _19_mpos = convert_stringliteral_1798_to_string(context)?;
            ret_mpos = _19_mpos;
            Ok(ret_mpos)
        }

        pub fn convert_rational_250000000000000000_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_250000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_MAX_FEE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_250000000000000000_by_1_to_uint256(U256::from(0x3782dace9d90000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn store_literal_in_memory_4530a1018f844b7636fc55587c6439f0d13cba2756954c065684847c09fd8695<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("6d61782066656520657863656564656400000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_4530a1018f844b7636fc55587c6439f0d13cba2756954c065684847c09fd8695<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x10u128), context)?;
            store_literal_in_memory_4530a1018f844b7636fc55587c6439f0d13cba2756954c065684847c09fd8695(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_4530_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_4530a1018f844b7636fc55587c6439f0d13cba2756954c065684847c09fd8695(context)?;
            Ok(converted)
        }

        pub fn constant_MAX_FEE_EXCEEDED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _179_mpos = convert_stringliteral_4530_to_string(context)?;
            ret_mpos = _179_mpos;
            Ok(ret_mpos)
        }

        pub fn convert_rational_1150000000000000000_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1150000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_MAX_LIQUIDATION_INCENTIVE_FACTOR<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1150000000000000000_by_1_to_uint256(U256::from(0xff59ee833b30000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn store_literal_in_memory_640f90576275d294c88e507a81345b1231497628757ec4cf63f3b1503cdf1a9f<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("6d6178204c4c5456206578636565646564000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_640f90576275d294c88e507a81345b1231497628757ec4cf63f3b1503cdf1a9f<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x11u128), context)?;
            store_literal_in_memory_640f90576275d294c88e507a81345b1231497628757ec4cf63f3b1503cdf1a9f(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_640f_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_640f90576275d294c88e507a81345b1231497628757ec4cf63f3b1503cdf1a9f(context)?;
            Ok(converted)
        }

        pub fn constant_MAX_LLTV_EXCEEDED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _201_mpos = convert_stringliteral_640f_to_string(context)?;
            ret_mpos = _201_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_23a5a67a6705a938d2afa184b7de3e9b24c9212f02dec96966825e48f5b461b6<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("6d61782075696e74313238206578636565646564000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_23a5a67a6705a938d2afa184b7de3e9b24c9212f02dec96966825e48f5b461b6<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x14u128), context)?;
            store_literal_in_memory_23a5a67a6705a938d2afa184b7de3e9b24c9212f02dec96966825e48f5b461b6(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_23a5_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_23a5a67a6705a938d2afa184b7de3e9b24c9212f02dec96966825e48f5b461b6(context)?;
            Ok(converted)
        }

        pub fn constant_MAX_UINT128_EXCEEDED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _1090_mpos = convert_stringliteral_23a5_to_string(context)?;
            ret_mpos = _1090_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_f2881edc58d5a08d0243d7f8afdab31d949d85825e628e4b88558657a031f74e<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("6e6f74206f776e65720000000000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_f2881edc58d5a08d0243d7f8afdab31d949d85825e628e4b88558657a031f74e<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x9u128), context)?;
            store_literal_in_memory_f2881edc58d5a08d0243d7f8afdab31d949d85825e628e4b88558657a031f74e(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_f288_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_f2881edc58d5a08d0243d7f8afdab31d949d85825e628e4b88558657a031f74e(context)?;
            Ok(converted)
        }

        pub fn constant_NOT_OWNER<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _2_mpos = convert_stringliteral_f288_to_string(context)?;
            ret_mpos = _2_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_032999fca1188e683f4a316e0deaa9b99b639717686bfe7875953796fc849c71<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("6e6f20636f646500000000000000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_032999fca1188e683f4a316e0deaa9b99b639717686bfe7875953796fc849c71<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x7u128), context)?;
            store_literal_in_memory_032999fca1188e683f4a316e0deaa9b99b639717686bfe7875953796fc849c71(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_032999fca1188e683f4a316e0deaa9b99b639717686bfe7875953796fc849c71(context)?;
            Ok(converted)
        }

        pub fn constant_NO_CODE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _1094_mpos = convert_stringliteral_to_string(context)?;
            ret_mpos = _1094_mpos;
            Ok(ret_mpos)
        }

        pub fn convert_rational_1000000000000000000000000000000000000_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1000000000000000000000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_ORACLE_PRICE_SCALE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000000000000000000000000000000000_by_1_to_uint256(U256::from(0xc097ce7bc90715b34b9f1000000000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn store_literal_in_memory_f433534ec486a258d5f02d2db53468b858b8afa0b57bc61bc37ba0c2205a4fbd<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7369676e61747572652065787069726564000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_f433534ec486a258d5f02d2db53468b858b8afa0b57bc61bc37ba0c2205a4fbd<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x11u128), context)?;
            store_literal_in_memory_f433534ec486a258d5f02d2db53468b858b8afa0b57bc61bc37ba0c2205a4fbd(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_f433_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_f433534ec486a258d5f02d2db53468b858b8afa0b57bc61bc37ba0c2205a4fbd(context)?;
            Ok(converted)
        }

        pub fn constant_SIGNATURE_EXPIRED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _441_mpos = convert_stringliteral_f433_to_string(context)?;
            ret_mpos = _441_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_ad4e91d846cee378cbbd4ed8fdb0537bfb87e11139fb8585a973fb1b267366b0<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7472616e7366657246726f6d2072657475726e65642066616c73650000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_ad4e91d846cee378cbbd4ed8fdb0537bfb87e11139fb8585a973fb1b267366b0<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x1bu128), context)?;
            store_literal_in_memory_ad4e91d846cee378cbbd4ed8fdb0537bfb87e11139fb8585a973fb1b267366b0(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_ad4e_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_ad4e91d846cee378cbbd4ed8fdb0537bfb87e11139fb8585a973fb1b267366b0(context)?;
            Ok(converted)
        }

        pub fn constant_TRANSFER_FROM_RETURNED_FALSE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _1107_mpos = convert_stringliteral_ad4e_to_string(context)?;
            ret_mpos = _1107_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_fe8c0c040bbd1663af28d63b3a1790971461e9c7eacb7abbff91b5b166409b4a<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7472616e7366657246726f6d2072657665727465640000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_fe8c0c040bbd1663af28d63b3a1790971461e9c7eacb7abbff91b5b166409b4a<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x15u128), context)?;
            store_literal_in_memory_fe8c0c040bbd1663af28d63b3a1790971461e9c7eacb7abbff91b5b166409b4a(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_fe8c_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_fe8c0c040bbd1663af28d63b3a1790971461e9c7eacb7abbff91b5b166409b4a(context)?;
            Ok(converted)
        }

        pub fn constant_TRANSFER_FROM_REVERTED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _1104_mpos = convert_stringliteral_fe8c_to_string(context)?;
            ret_mpos = _1104_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_b0b1cc5e07eae1fb9c1e53fb6e7f759d03bf206d4233f4e365ee05d0824394ee<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7472616e736665722072657475726e65642066616c7365000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_b0b1cc5e07eae1fb9c1e53fb6e7f759d03bf206d4233f4e365ee05d0824394ee<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x17u128), context)?;
            store_literal_in_memory_b0b1cc5e07eae1fb9c1e53fb6e7f759d03bf206d4233f4e365ee05d0824394ee(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_b0b1_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_b0b1cc5e07eae1fb9c1e53fb6e7f759d03bf206d4233f4e365ee05d0824394ee(context)?;
            Ok(converted)
        }

        pub fn constant_TRANSFER_RETURNED_FALSE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _1157_mpos = convert_stringliteral_b0b1_to_string(context)?;
            ret_mpos = _1157_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_2a8385f53cbacc45d155583b417a48112a0633f2137989c786fa88b7647549f5<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7472616e73666572207265766572746564000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_2a8385f53cbacc45d155583b417a48112a0633f2137989c786fa88b7647549f5<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x11u128), context)?;
            store_literal_in_memory_2a8385f53cbacc45d155583b417a48112a0633f2137989c786fa88b7647549f5(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_2a83_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_2a8385f53cbacc45d155583b417a48112a0633f2137989c786fa88b7647549f5(context)?;
            Ok(converted)
        }

        pub fn constant_TRANSFER_REVERTED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _1154_mpos = convert_stringliteral_2a83_to_string(context)?;
            ret_mpos = _1154_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_926a1b84b861d31f2d45224162461e1d5ff4377725d977d8f792bb84825a0348<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("756e617574686f72697a65640000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_926a1b84b861d31f2d45224162461e1d5ff4377725d977d8f792bb84825a0348<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0xcu128), context)?;
            store_literal_in_memory_926a1b84b861d31f2d45224162461e1d5ff4377725d977d8f792bb84825a0348(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_926a_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_926a1b84b861d31f2d45224162461e1d5ff4377725d977d8f792bb84825a0348(context)?;
            Ok(converted)
        }

        pub fn constant_UNAUTHORIZED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _222_mpos = convert_stringliteral_926a_to_string(context)?;
            ret_mpos = _222_mpos;
            Ok(ret_mpos)
        }

        pub fn convert_rational_1_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_VIRTUAL_ASSETS<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_1000000_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_VIRTUAL_SHARES<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000_by_1_to_uint256(U256::from(0xf4240u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_by_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_WAD<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_by_to_uint256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn store_literal_in_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7a65726f20616464726573730000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0xcu128), context)?;
            store_literal_in_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_a4b4_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_a4b4461cfc9c1f0249c17896b005545dc5d1690f81d2023afc517b07ed3227a7(context)?;
            Ok(converted)
        }

        pub fn constant_ZERO_ADDRESS<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _35_mpos = convert_stringliteral_a4b4_to_string(context)?;
            ret_mpos = _35_mpos;
            Ok(ret_mpos)
        }

        pub fn store_literal_in_memory_66565ea0c208e7335f4209a28fd1a047a5930228ef63dde212841a4b5b376b7e<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("7a65726f20617373657473000000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn copy_literal_to_memory_66565ea0c208e7335f4209a28fd1a047a5930228ef63dde212841a4b5b376b7e<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0xbu128), context)?;
            store_literal_in_memory_66565ea0c208e7335f4209a28fd1a047a5930228ef63dde212841a4b5b376b7e(add(memPtr, U256::from(0x20u128), context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_6656_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_66565ea0c208e7335f4209a28fd1a047a5930228ef63dde212841a4b5b376b7e(context)?;
            Ok(converted)
        }

        pub fn constant_ZERO_ASSETS<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_mpos = U256::ZERO;
            let _130_mpos = convert_stringliteral_6656_to_string(context)?;
            ret_mpos = _130_mpos;
            Ok(ret_mpos)
        }

        pub fn convert_uint160_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_uint160(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IERC20(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IIrm<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IIrm<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IIrm(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IMorphoFlashLoanCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IMorphoFlashLoanCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IMorphoFlashLoanCallback(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IMorphoLiquidateCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IMorphoLiquidateCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IMorphoLiquidateCallback(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IMorphoRepayCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IMorphoRepayCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IMorphoRepayCallback(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IMorphoSupplyCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IMorphoSupplyCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IMorphoSupplyCallback(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IMorphoSupplyCollateralCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IMorphoSupplyCollateralCallback<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IMorphoSupplyCollateralCallback(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IOracle<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IOracle<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IOracle(value, context)?;
            Ok(converted)
        }

        pub fn convert_bool_to_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_bool(value, context)?;
            Ok(converted)
        }

        pub fn convert_bytes32_to_bytes32<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_bytes32(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IERC20_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IIrm_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IMorphoFlashLoanCallback_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IMorphoLiquidateCallback_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IMorphoRepayCallback_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IMorphoSupplyCallback_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IMorphoSupplyCollateralCallback_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IOracle_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_Morpho_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_rational_0_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_3_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_3_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_rational_by_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint128_to_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_uint128(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint128_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint128(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn read_from_memoryt_address<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_address(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_uint256<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint256(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn prepare_store_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_20_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_address_to_address<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_address_to_address(value, context)?;
            sstore(slot, update_byte_slice_20_shift(sload(slot, context)?, prepare_store_address(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn update_byte_slice_shift_0<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = not(U256::from(0x0u128), context)?;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint256_to_uint256<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint256_to_uint256(value, context)?;
            sstore(slot, update_byte_slice_shift_0(sload(slot, context)?, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn copy_struct_to_storage_from_struct_MarketParams_to_struct_MarketParams<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue = read_from_memoryt_address(add(value, U256::from(0x0u128), context)?, context)?;
            update_storage_value_offsett_address_to_address(add(slot, U256::from(0x0u128), context)?, memberValue, context)?;
            let memberValue_1 = read_from_memoryt_address(add(value, U256::from(0x20u128), context)?, context)?;
            update_storage_value_offsett_address_to_address(add(slot, U256::from(0x1u128), context)?, memberValue_1, context)?;
            let memberValue_2 = read_from_memoryt_address(add(value, U256::from(0x40u128), context)?, context)?;
            update_storage_value_offsett_address_to_address(add(slot, U256::from(0x2u128), context)?, memberValue_2, context)?;
            let memberValue_3 = read_from_memoryt_address(add(value, U256::from(0x60u128), context)?, context)?;
            update_storage_value_offsett_address_to_address(add(slot, U256::from(0x3u128), context)?, memberValue_3, context)?;
            let memberValue_4 = read_from_memoryt_uint256(add(value, U256::from(0x80u128), context)?, context)?;
            update_storage_value_offsett_uint256_to_uint256(add(slot, U256::from(0x4u128), context)?, memberValue_4, context)?;
            Ok(())
        }

        pub fn getter_fun_DOMAIN_SEPARATOR<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut rval = U256::ZERO;
            rval = loadimmutable(from_hex("3634000000000000000000000000000000000000000000000000000000000000"), context)?;
            Ok(rval)
        }

        pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn external_fun_DOMAIN_SEPARATOR<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_DOMAIN_SEPARATOR(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bytes32(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_mulDivDown<CI>(var_x: U256, var_y: U256, var_d: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = checked_mul_uint256(var_x, var_y, context)?;
            let expr_1 = checked_div_uint256(expr, var_d, context)?;
            var = expr_1;
            Ok(var)
        }

        pub fn fun_toSharesDown<CI>(var_assets: U256, var_totalAssets: U256, var_totalShares: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = constant_VIRTUAL_SHARES(context)?;
            let expr_1 = checked_add_uint256(var_totalShares, expr, context)?;
            let expr_2 = constant_VIRTUAL_ASSETS(context)?;
            let expr_3 = checked_add_uint256(var_totalAssets, expr_2, context)?;
            let expr_4 = fun_mulDivDown(var_assets, expr_1, expr_3, context)?;
            var = expr_4;
            Ok(var)
        }

        pub fn require_helper_string<CI>(condition: U256, expr_167_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(condition, context)? != U256::ZERO {
                let memPtr = allocate_unbounded(context)?;
                mstore(memPtr, shl(U256::from(0xe5u128), U256::from(0x461bcdu128), context)?, context)?;
                let end_ = abi_encode_string(add(memPtr, U256::from(0x4u128), context)?, expr_167_mpos, context)?;
                revert(memPtr, sub(end_, memPtr, context)?, context)?;
            }
            Ok(())
        }

        pub fn zero_value_for_split_uint128<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_toUint128<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let expr = iszero(gt(cleanup_uint256(var_x, context)?, convert_uint128_to_uint256(U256::from(0xffffffffffffffffffffffffffffffffu128), context)?, context)?, context)?;
            let expr_3581_mpos = constant_MAX_UINT128_EXCEEDED(context)?;
            require_helper_string(expr, expr_3581_mpos, context)?;
            let expr_1 = convert_uint256_to_uint128(var_x, context)?;
            var = expr_1;
            Ok(var)
        }

        pub fn fun_wMulDown<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = constant_WAD(context)?;
            let expr_1 = fun_mulDivDown(var_x, var_y, expr, context)?;
            var = expr_1;
            Ok(var)
        }

        pub fn fun_wTaylorCompounded<CI>(var_x: U256, var_n: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = checked_mul_uint256(var_x, var_n, context)?;
            let expr_1 = constant_WAD(context)?;
            let expr_2 = checked_mul_uint256(convert_rational_2_by_1_to_uint256(U256::from(0x2u128), context)?, expr_1, context)?;
            let expr_3 = fun_mulDivDown(expr, expr, expr_2, context)?;
            let expr_4 = checked_mul_uint256(convert_rational_3_by_1_to_uint256(U256::from(0x3u128), context)?, expr_1, context)?;
            let expr_5 = fun_mulDivDown(expr_3, expr, expr_4, context)?;
            let expr_6 = checked_add_uint256(expr, expr_3, context)?;
            let expr_7 = checked_add_uint256(expr_6, expr_5, context)?;
            var = expr_7;
            Ok(var)
        }

        pub fn mapping_index_access_mapping_address_struct_Position_storage_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_bytes32_to_bytes32(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_bytes32_to_bytes32(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn extract_from_storage_value_offsett_address<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_address(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_address<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_address(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_t_uint128<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_uint128(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_uint128<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_16t_uint128(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn extract_from_storage_value_offsett_uint256<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint256(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_uint256<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_uint256(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn revert_forward<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let pos = allocate_unbounded(context)?;
            returndatacopy(pos, U256::from(0x0u128), returndatasize(context)?, context)?;
            revert(pos, returndatasize(context)?, context)?;
            Ok(())
        }

        pub fn shift_left_224<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn prepare_store_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left_128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0x80u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_16<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = not(U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            toInsert = shift_left_128(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint128_to_t_uint128<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint128_to_uint128(value, context)?;
            sstore(slot, update_byte_slice_shift_16(sload(slot, context)?, prepare_store_uint128(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn update_byte_slice_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = U256::from(0xffffffffffffffffffffffffffffffffu128);
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint128_to_uint128<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint128_to_uint128(value, context)?;
            sstore(slot, update_byte_slice_shift(sload(slot, context)?, prepare_store_uint128(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn fun_accrueInterest<CI>(var_marketParams_1971_mpos: U256, var_id: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _973_slot = U256::from(0x3u128);
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr = checked_sub_uint256(timestamp(context)?, convert_uint128_to_uint256(_2, context)?, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                return Ok(());
            }
            let _3 = add(var_marketParams_1971_mpos, U256::from(0x60u128), context)?;
            let _4 = read_from_memoryt_address(_3, context)?;
            let expr_2 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_3 = iszero(eq(cleanup_address(_4, context)?, cleanup_address(expr_2, context)?, context)?, context)?;
            if expr_3 != U256::ZERO {
                let _5 = read_from_memoryt_address(_3, context)?;
                let expr_2004_address = convert_address_to_contract_IIrm(_5, context)?;
                let expr_2005_address = convert_contract_IIrm_to_address(expr_2004_address, context)?;
                let _6 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                let _7 = allocate_unbounded(context)?;
                mstore(_7, shift_left_224(U256::from(0x9451fed4u128), context)?, context)?;
                let _8 = abi_encode_struct_MarketParams_struct_Market_storage(add(_7, U256::from(0x4u128), context)?, var_marketParams_1971_mpos, _6, context)?;
                let _9 = call(gas(context)?, expr_2005_address, U256::from(0x0u128), _7, sub(_8, _7, context)?, _7, U256::from(0x20u128), context)?;
                if iszero(_9, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                let mut expr_4 = U256::ZERO;
                if _9 != U256::ZERO {
                    let mut _10 = U256::from(0x20u128);
                    if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                        _10 = returndatasize(context)?;
                    }
                    finalize_allocation(_7, _10, context)?;
                    expr_4 = abi_decode_uint256_fromMemory(_7, add(_7, _10, context)?, context)?;
                }
                let _11 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                let _12 = read_from_storage_split_offset_t_uint128(add(_11, U256::from(0x1u128), context)?, context)?;
                let expr_self = convert_uint128_to_uint256(_12, context)?;
                let expr_5 = fun_wTaylorCompounded(expr_4, expr, context)?;
                let expr_6 = fun_wMulDown(expr_self, expr_5, context)?;
                let expr_7 = fun_toUint128(expr_6, context)?;
                let _13 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                let _14 = add(_13, U256::from(0x1u128), context)?;
                let _15 = read_from_storage_split_offset_t_uint128(_14, context)?;
                let expr_8 = checked_add_uint128(_15, expr_7, context)?;
                update_storage_value_offsett_uint128_to_uint128(_14, expr_8, context)?;
                let expr_9 = fun_toUint128(expr_6, context)?;
                let _16 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                let _17 = add(_16, U256::from(0x0u128), context)?;
                let _18 = read_from_storage_split_offset_t_uint128(_17, context)?;
                let expr_10 = checked_add_uint128(_18, expr_9, context)?;
                update_storage_value_offsett_uint128_to_uint128(_17, expr_10, context)?;
                let mut var_feeShares = U256::ZERO;
                let zero_uint256 = zero_value_for_split_uint256(context)?;
                var_feeShares = zero_uint256;
                let _19 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                let _20 = read_from_storage_split_offset_uint128(add(_19, U256::from(0x2u128), context)?, context)?;
                let expr_11 = iszero(eq(cleanup_uint128(_20, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
                if expr_11 != U256::ZERO {
                    let _21 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                    let _22 = read_from_storage_split_offset_uint128(add(_21, U256::from(0x2u128), context)?, context)?;
                    let _23 = convert_uint128_to_uint256(_22, context)?;
                    let expr_12 = fun_wMulDown(expr_6, _23, context)?;
                    let _24 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                    let _25 = read_from_storage_split_offset_t_uint128(add(_24, U256::from(0x0u128), context)?, context)?;
                    let expr_13 = checked_sub_uint256(convert_uint128_to_uint256(_25, context)?, expr_12, context)?;
                    let _26 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                    let _27 = read_from_storage_split_offset_uint128(add(_26, U256::from(0x0u128), context)?, context)?;
                    let _28 = convert_uint128_to_uint256(_27, context)?;
                    let expr_14 = fun_toSharesDown(expr_12, expr_13, _28, context)?;
                    var_feeShares = expr_14;
                    let _29 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), var_id, context)?;
                    let _30 = read_from_storage_split_offset_address(U256::from(0x1u128), context)?;
                    let _31 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_29, _30, context)?;
                    let _32 = add(_31, U256::from(0x0u128), context)?;
                    let _33 = read_from_storage_split_offset_uint256(_32, context)?;
                    let expr_15 = checked_add_uint256(_33, expr_14, context)?;
                    update_storage_value_offsett_uint256_to_uint256(_32, expr_15, context)?;
                    let expr_16 = fun_toUint128(expr_14, context)?;
                    let _34 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
                    let _35 = add(_34, U256::from(0x0u128), context)?;
                    let _36 = read_from_storage_split_offset_uint128(_35, context)?;
                    let expr_17 = checked_add_uint128(_36, expr_16, context)?;
                    update_storage_value_offsett_uint128_to_t_uint128(_35, expr_17, context)?;
                }
                let _37 = convert_bytes32_to_bytes32(var_id, context)?;
                let _38 = allocate_unbounded(context)?;
                let _39 = abi_encode_uint256_uint256_uint256(_38, expr_4, expr_6, var_feeShares, context)?;
                log2(_38, sub(_39, _38, context)?, U256::from_be_slice(&[0x9d, 0x9b, 0xd5, 0x01, 0xd0, 0x65, 0x7d, 0x7d, 0xfe, 0x41, 0x5f, 0x77, 0x9a, 0x62, 0x0a, 0x62, 0xb7, 0x8b, 0xc5, 0x08, 0xdd, 0xc0, 0x89, 0x1f, 0xbb, 0xd8, 0xb7, 0xac, 0x0f, 0x8f, 0xce, 0x87]), _37, context)?;
            }
            let expr_18 = convert_uint256_to_uint128(timestamp(context)?, context)?;
            let _40 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_973_slot, var_id, context)?;
            update_storage_value_offsett_uint128_to_uint128(add(_40, U256::from(0x2u128), context)?, expr_18, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_userDefinedValueType_Id<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_id<CI>(var_marketParams_3107_mpos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_marketParamsId = U256::ZERO;
            let zero_userDefinedValueType_Id = zero_value_for_split_userDefinedValueType_Id(context)?;
            var_marketParamsId = zero_userDefinedValueType_Id;
            var_marketParamsId = keccak256(var_marketParams_3107_mpos, U256::from(0xa0u128), context)?;
            Ok(var_marketParamsId)
        }

        pub fn fun_accrueInterest_1967<CI>(var_marketParams_1940_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_id(var_marketParams_1940_mpos, context)?;
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(U256::from(0x3u128), expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1958_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_1958_mpos, context)?;
            fun_accrueInterest(var_marketParams_1940_mpos, expr, context)?;
            Ok(())
        }

        pub fn external_fun_accrueInterest<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_struct_MarketParams(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_accrueInterest_1967(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_mulDivUp<CI>(var_x: U256, var_y: U256, var_d: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = checked_mul_uint256(var_x, var_y, context)?;
            let expr_1 = checked_sub_uint256(var_d, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let expr_2 = checked_add_uint256(expr, expr_1, context)?;
            let expr_3 = checked_div_uint256(expr_2, var_d, context)?;
            var = expr_3;
            Ok(var)
        }

        pub fn fun_toAssetsUp<CI>(var_shares: U256, var_totalAssets: U256, var_totalShares: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = constant_VIRTUAL_ASSETS(context)?;
            let expr_1 = checked_add_uint256(var_totalAssets, expr, context)?;
            let expr_2 = constant_VIRTUAL_SHARES(context)?;
            let expr_3 = checked_add_uint256(var_totalShares, expr_2, context)?;
            let expr_4 = fun_mulDivUp(var_shares, expr_1, expr_3, context)?;
            var = expr_4;
            Ok(var)
        }

        pub fn zero_value_for_split_bool<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_isHealthy<CI>(var_marketParams_mpos: U256, var_id: U256, var_borrower: U256, var_collateralPrice: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_ = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_ = zero_bool;
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), var_id, context)?;
            let _2 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_1, var_borrower, context)?;
            let _3 = read_from_storage_split_offset_t_uint128(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = convert_uint128_to_uint256(_3, context)?;
            let _4 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(U256::from(0x3u128), var_id, context)?;
            let _5 = read_from_storage_split_offset_t_uint128(add(_4, U256::from(0x1u128), context)?, context)?;
            let _6 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(U256::from(0x3u128), var_id, context)?;
            let _7 = read_from_storage_split_offset_uint128(add(_6, U256::from(0x1u128), context)?, context)?;
            let _8 = convert_uint128_to_uint256(_5, context)?;
            let _9 = convert_uint128_to_uint256(_7, context)?;
            let expr_1 = fun_toAssetsUp(expr, _8, _9, context)?;
            let _10 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), var_id, context)?;
            let _11 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_10, var_borrower, context)?;
            let _12 = read_from_storage_split_offset_uint128(add(_11, U256::from(0x1u128), context)?, context)?;
            let expr_2 = convert_uint128_to_uint256(_12, context)?;
            let expr_3 = constant_ORACLE_PRICE_SCALE(context)?;
            let expr_4 = fun_mulDivDown(expr_2, var_collateralPrice, expr_3, context)?;
            let _13 = read_from_memoryt_uint256(add(var_marketParams_mpos, U256::from(0x80u128), context)?, context)?;
            let expr_5 = fun_wMulDown(expr_4, _13, context)?;
            let expr_6 = iszero(lt(cleanup_uint256(expr_5, context)?, cleanup_uint256(expr_1, context)?, context)?, context)?;
            var_ = expr_6;
            Ok(var_)
        }

        pub fn fun__isHealthy<CI>(var_marketParams_2125_mpos: U256, var_id: U256, var_borrower: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), var_id, context)?;
            let _2 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_1, var_borrower, context)?;
            let _3 = read_from_storage_split_offset_t_uint128(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = eq(cleanup_uint128(_3, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                var = U256::from(0x1u128);
                return Ok(var);
            }
            let _4 = read_from_memoryt_address(add(var_marketParams_2125_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_2151_address = convert_address_to_contract_IOracle(_4, context)?;
            let expr_2152_address = convert_contract_IOracle_to_address(expr_2151_address, context)?;
            let _5 = allocate_unbounded(context)?;
            mstore(_5, shift_left_224(U256::from(0xa035b1feu128), context)?, context)?;
            let _6 = abi_encode_tuple(add(_5, U256::from(0x4u128), context)?, context)?;
            let _7 = staticcall(gas(context)?, expr_2152_address, _5, sub(_6, _5, context)?, _5, U256::from(0x20u128), context)?;
            if iszero(_7, context)? != U256::ZERO {
                revert_forward(context)?;
            }
            let mut expr_1 = U256::ZERO;
            if _7 != U256::ZERO {
                let mut _8 = U256::from(0x20u128);
                if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                    _8 = returndatasize(context)?;
                }
                finalize_allocation(_5, _8, context)?;
                expr_1 = abi_decode_uint256_fromMemory(_5, add(_5, _8, context)?, context)?;
            }
            let expr_2 = fun_isHealthy(var_marketParams_2125_mpos, var_id, var_borrower, expr_1, context)?;
            var = expr_2;
            Ok(var)
        }

        pub fn fun_exactlyOneZero<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_z = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_z = zero_bool;
            var_z = xor(iszero(var_x, context)?, iszero(var_y, context)?, context)?;
            Ok(var_z)
        }

        pub fn mapping_index_access_mapping_address_bool_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_address_mapping_address_bool_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn extract_from_storage_value_offsett_bool<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_bool<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_bool(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn fun_isSenderAuthorized<CI>(var_onBehalf: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_bool = zero_value_for_split_bool(context)?;
            var = zero_t_bool;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(var_onBehalf, context)?, context)?;
            let mut expr_1 = expr;
            if iszero(expr, context)? != U256::ZERO {
                let _1 = mapping_index_access_mapping_address_mapping_address_bool_of_address(U256::from(0x6u128), var_onBehalf, context)?;
                let _2 = mapping_index_access_mapping_address_bool_of_address(_1, caller(context)?, context)?;
                let _3 = read_from_storage_split_offset_bool(_2, context)?;
                expr_1 = _3;
            }
            var = expr_1;
            Ok(var)
        }

        pub fn zero_value_for_split_bytes<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn extract_returndata<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            // switch
            let  = returndatasize(context)?;
            if  == U256::from(0x0u128) {
                data = zero_value_for_split_bytes(context)?;
            }
            Ok(data)
        }

        pub fn fun_safeTransfer<CI>(var_token_3293_address: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_contract_IERC20_to_address(var_token_3293_address, context)?;
            let expr_1 = extcodesize(expr, context)?;
            let expr_2 = gt(cleanup_uint256(expr_1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            let expr_3310_mpos = constant_NO_CODE(context)?;
            require_helper_string(expr_2, expr_3310_mpos, context)?;
            let expr_3329_mpos = allocate_unbounded(context)?;
            let mut _1 = add(expr_3329_mpos, U256::from(0x20u128), context)?;
            mstore(_1, shl(U256::from(0xe0u128), U256::from(0xa9059cbbu128), context)?, context)?;
            _1 = add(_1, U256::from(0x4u128), context)?;
            let _2 = abi_encode_address_uint256(_1, var_to, var_value, context)?;
            mstore(expr_3329_mpos, sub(_2, add(expr_3329_mpos, U256::from(0x20u128), context)?, context)?, context)?;
            finalize_allocation(expr_3329_mpos, sub(_2, expr_3329_mpos, context)?, context)?;
            let _3 = mload(expr_3329_mpos, context)?;
            let expr_component = call(gas(context)?, expr, U256::from(0x0u128), add(expr_3329_mpos, U256::from(0x20u128), context)?, _3, U256::from(0x0u128), U256::from(0x0u128), context)?;
            let expr_3330_component_2_mpos = extract_returndata(context)?;
            let expr_3335_mpos = constant_TRANSFER_REVERTED(context)?;
            require_helper_string(expr_component, expr_3335_mpos, context)?;
            let expr_3 = array_length_bytes(expr_3330_component_2_mpos, context)?;
            let expr_4 = eq(cleanup_uint256(expr_3, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            let mut expr_5 = expr_4;
            if iszero(expr_4, context)? != U256::ZERO {
                let expr_6 = abi_decode_bool_fromMemory(add(expr_3330_component_2_mpos, U256::from(0x20u128), context)?, add(add(expr_3330_component_2_mpos, U256::from(0x20u128), context)?, array_length_bytes(expr_3330_component_2_mpos, context)?, context)?, context)?;
                expr_5 = expr_6;
            }
            let expr_3352_mpos = constant_TRANSFER_RETURNED_FALSE(context)?;
            require_helper_string(expr_5, expr_3352_mpos, context)?;
            Ok(())
        }

        pub fn fun_toAssetsDown<CI>(var_shares: U256, var_totalAssets: U256, var_totalShares: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = constant_VIRTUAL_ASSETS(context)?;
            let expr_1 = checked_add_uint256(var_totalAssets, expr, context)?;
            let expr_2 = constant_VIRTUAL_SHARES(context)?;
            let expr_3 = checked_add_uint256(var_totalShares, expr_2, context)?;
            let expr_4 = fun_mulDivDown(var_shares, expr_1, expr_3, context)?;
            var = expr_4;
            Ok(var)
        }

        pub fn fun_toSharesUp<CI>(var_assets: U256, var_totalAssets: U256, var_totalShares: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = constant_VIRTUAL_SHARES(context)?;
            let expr_1 = checked_add_uint256(var_totalShares, expr, context)?;
            let expr_2 = constant_VIRTUAL_ASSETS(context)?;
            let expr_3 = checked_add_uint256(var_totalAssets, expr_2, context)?;
            let expr_4 = fun_mulDivUp(var_assets, expr_1, expr_3, context)?;
            var = expr_4;
            Ok(var)
        }

        pub fn fun_borrow<CI>(var_marketParams_792_mpos: U256, mut var_assets: U256, var_shares: U256, var_onBehalf: U256, var_receiver: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let mut var_1 = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            var_1 = zero_uint256;
            let expr = fun_id(var_marketParams_792_mpos, context)?;
            let _212_slot = U256::from(0x3u128);
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_212_slot, expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_822_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_822_mpos, context)?;
            let expr_2 = fun_exactlyOneZero(var_assets, var_shares, context)?;
            let expr_832_mpos = constant_INCONSISTENT_INPUT(context)?;
            require_helper_string(expr_2, expr_832_mpos, context)?;
            let expr_3 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_4 = iszero(eq(cleanup_address(var_receiver, context)?, cleanup_address(expr_3, context)?, context)?, context)?;
            let expr_843_mpos = constant_ZERO_ADDRESS(context)?;
            require_helper_string(expr_4, expr_843_mpos, context)?;
            let expr_5 = fun_isSenderAuthorized(var_onBehalf, context)?;
            let expr_851_mpos = constant_UNAUTHORIZED(context)?;
            require_helper_string(expr_5, expr_851_mpos, context)?;
            fun_accrueInterest(var_marketParams_792_mpos, expr, context)?;
            let expr_6 = gt(cleanup_uint256(var_assets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_6;
            if  == U256::from(0x0u128) {
                let _3 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_212_slot, expr, context)?;
                let _4 = read_from_storage_split_offset_t_uint128(add(_3, U256::from(0x1u128), context)?, context)?;
                let _5 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_212_slot, expr, context)?;
                let _6 = read_from_storage_split_offset_uint128(add(_5, U256::from(0x1u128), context)?, context)?;
                let _7 = convert_uint128_to_uint256(_4, context)?;
                let _8 = convert_uint128_to_uint256(_6, context)?;
                let expr_7 = fun_toAssetsDown(var_shares, _7, _8, context)?;
                var_assets = expr_7;
            }
            let expr_9 = fun_toUint128(var_shares, context)?;
            let _15 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), expr, context)?;
            let _16 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_15, var_onBehalf, context)?;
            let _17 = add(_16, U256::from(0x1u128), context)?;
            let _18 = read_from_storage_split_offset_t_uint128(_17, context)?;
            let expr_10 = checked_add_uint128(_18, expr_9, context)?;
            update_storage_value_offsett_uint128_to_uint128(_17, expr_10, context)?;
            let expr_11 = fun_toUint128(var_shares, context)?;
            let _19 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_212_slot, expr, context)?;
            let _20 = add(_19, U256::from(0x1u128), context)?;
            let _21 = read_from_storage_split_offset_uint128(_20, context)?;
            let expr_12 = checked_add_uint128(_21, expr_11, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_20, expr_12, context)?;
            let expr_13 = fun_toUint128(var_assets, context)?;
            let _22 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_212_slot, expr, context)?;
            let _23 = add(_22, U256::from(0x1u128), context)?;
            let _24 = read_from_storage_split_offset_t_uint128(_23, context)?;
            let expr_14 = checked_add_uint128(_24, expr_13, context)?;
            update_storage_value_offsett_uint128_to_uint128(_23, expr_14, context)?;
            let expr_15 = fun__isHealthy(var_marketParams_792_mpos, expr, var_onBehalf, context)?;
            let expr_927_mpos = constant_INSUFFICIENT_COLLATERAL(context)?;
            require_helper_string(expr_15, expr_927_mpos, context)?;
            let _25 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_212_slot, expr, context)?;
            let _26 = read_from_storage_split_offset_t_uint128(add(_25, U256::from(0x1u128), context)?, context)?;
            let _27 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_212_slot, expr, context)?;
            let _28 = read_from_storage_split_offset_t_uint128(add(_27, U256::from(0x0u128), context)?, context)?;
            let expr_16 = iszero(gt(cleanup_uint128(_26, context)?, cleanup_uint128(_28, context)?, context)?, context)?;
            let expr_941_mpos = constant_INSUFFICIENT_LIQUIDITY(context)?;
            require_helper_string(expr_16, expr_941_mpos, context)?;
            let _29 = convert_bytes32_to_bytes32(expr, context)?;
            let _30 = convert_address_to_address(var_onBehalf, context)?;
            let _31 = convert_address_to_address(var_receiver, context)?;
            let _32 = allocate_unbounded(context)?;
            let _33 = abi_encode_address_uint256_uint256(_32, caller(context)?, var_assets, var_shares, context)?;
            log4(_32, sub(_33, _32, context)?, U256::from_be_slice(&[0x57, 0x09, 0x54, 0x54, 0x0b, 0xed, 0x6b, 0x13, 0x04, 0xa8, 0x7d, 0xfe, 0x81, 0x5a, 0x5e, 0xda, 0x4a, 0x64, 0x8f, 0x70, 0x97, 0xa1, 0x62, 0x40, 0xdc, 0xd8, 0x5c, 0x9b, 0x5f, 0xd4, 0x2a, 0x43]), _29, _30, _31, context)?;
            let _34 = read_from_memoryt_address(add(var_marketParams_792_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_959_address = convert_address_to_contract_IERC20(_34, context)?;
            fun_safeTransfer(expr_959_address, var_receiver, var_assets, context)?;
            var = var_assets;
            var_1 = var_shares;
            Ok((var, var_1))
        }

        pub fn external_fun_borrow<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3, param_4) = abi_decode_struct_MarketParamst_uint256t_uint256t_addresst_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1) = fun_borrow(param, param_1, param_2, param_3, param_4, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256_uint256(memPos, ret, ret_1, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn mapping_index_access_mapping_uint256_bool_of_uint256<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_uint256_to_uint256(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_userDefinedValueType_Id_struct_MarketParams_storage_of_userDefinedValueType_Id<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_bytes32_to_bytes32(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn update_storage_value_offsett_struct_MarketParams_to_struct_MarketParams<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            copy_struct_to_storage_from_struct_MarketParams_to_struct_MarketParams(slot, value, context)?;
            Ok(())
        }

        pub fn fun_createMarket<CI>(var_marketParams_369_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_id(var_marketParams_369_mpos, context)?;
            let _1 = add(var_marketParams_369_mpos, U256::from(0x60u128), context)?;
            let _2 = read_from_memoryt_address(_1, context)?;
            let _3 = mapping_index_access_mapping_address_bool_of_address(U256::from(0x4u128), _2, context)?;
            let _4 = read_from_storage_split_offset_bool(_3, context)?;
            let expr_385_mpos = constant_IRM_NOT_ENABLED(context)?;
            require_helper_string(_4, expr_385_mpos, context)?;
            let _5 = read_from_memoryt_uint256(add(var_marketParams_369_mpos, U256::from(0x80u128), context)?, context)?;
            let _6 = mapping_index_access_mapping_uint256_bool_of_uint256(U256::from(0x5u128), _5, context)?;
            let _7 = read_from_storage_split_offset_bool(_6, context)?;
            let expr_394_mpos = constant_LLTV_NOT_ENABLED(context)?;
            require_helper_string(_7, expr_394_mpos, context)?;
            let _569_slot = U256::from(0x3u128);
            let _8 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_569_slot, expr, context)?;
            let _9 = read_from_storage_split_offset_t_uint128(add(_8, U256::from(0x2u128), context)?, context)?;
            let expr_1 = eq(cleanup_uint128(_9, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            let expr_405_mpos = constant_MARKET_ALREADY_CREATED(context)?;
            require_helper_string(expr_1, expr_405_mpos, context)?;
            let expr_2 = convert_uint256_to_uint128(timestamp(context)?, context)?;
            let _10 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_569_slot, expr, context)?;
            update_storage_value_offsett_uint128_to_uint128(add(_10, U256::from(0x2u128), context)?, expr_2, context)?;
            let _11 = mapping_index_access_mapping_userDefinedValueType_Id_struct_MarketParams_storage_of_userDefinedValueType_Id(U256::from(0x8u128), expr, context)?;
            update_storage_value_offsett_struct_MarketParams_to_struct_MarketParams(_11, var_marketParams_369_mpos, context)?;
            let _12 = convert_bytes32_to_bytes32(expr, context)?;
            let _13 = allocate_unbounded(context)?;
            let _14 = abi_encode_struct_MarketParams(_13, var_marketParams_369_mpos, context)?;
            log2(_13, sub(_14, _13, context)?, U256::from_be_slice(&[0xac, 0x4b, 0x24, 0x00, 0xf1, 0x69, 0x22, 0x0b, 0x0c, 0x0a, 0xfd, 0xde, 0x7a, 0x0b, 0x32, 0xe7, 0x75, 0xba, 0x72, 0x7e, 0xa1, 0xcb, 0x30, 0xb3, 0x5f, 0x93, 0x5c, 0xda, 0xab, 0x86, 0x83, 0xac]), _12, context)?;
            let _15 = read_from_memoryt_address(_1, context)?;
            let expr_3 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_4 = iszero(eq(cleanup_address(_15, context)?, cleanup_address(expr_3, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                let _16 = read_from_memoryt_address(_1, context)?;
                let expr_442_address = convert_address_to_contract_IIrm(_16, context)?;
                let expr_443_address = convert_contract_IIrm_to_address(expr_442_address, context)?;
                let _17 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_569_slot, expr, context)?;
                let _18 = allocate_unbounded(context)?;
                mstore(_18, shift_left_224(U256::from(0x9451fed4u128), context)?, context)?;
                let _19 = abi_encode_struct_MarketParams_struct_Market_storage(add(_18, U256::from(0x4u128), context)?, var_marketParams_369_mpos, _17, context)?;
                let _20 = call(gas(context)?, expr_443_address, U256::from(0x0u128), _18, sub(_19, _18, context)?, _18, U256::from(0x20u128), context)?;
                if iszero(_20, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                let mut expr_5 = U256::ZERO;
                if _20 != U256::ZERO {
                    let mut _21 = U256::from(0x20u128);
                    if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                        _21 = returndatasize(context)?;
                    }
                    finalize_allocation(_18, _21, context)?;
                    expr_5 = abi_decode_uint256_fromMemory(_18, add(_18, _21, context)?, context)?;
                }
            }
            Ok(())
        }

        pub fn external_fun_createMarket<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_struct_MarketParams(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_createMarket(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn update_byte_slice_1_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(U256::from(0xffu128), context)?, context)?;
            result = or(value, and(toInsert, U256::from(0xffu128), context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_bool_to_bool<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_bool_to_bool(value, context)?;
            sstore(slot, update_byte_slice_1_shift(sload(slot, context)?, prepare_store_bool(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn fun_enableIrm_inner<CI>(var_irm: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_address_bool_of_address(U256::from(0x4u128), var_irm, context)?;
            let _2 = read_from_storage_split_offset_bool(_1, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            let expr_213_mpos = constant_ALREADY_SET(context)?;
            require_helper_string(expr, expr_213_mpos, context)?;
            let _3 = mapping_index_access_mapping_address_bool_of_address(U256::from(0x4u128), var_irm, context)?;
            update_storage_value_offsett_bool_to_bool(_3, U256::from(0x1u128), context)?;
            let _4 = convert_address_to_address(var_irm, context)?;
            let _5 = allocate_unbounded(context)?;
            let _6 = abi_encode_tuple(_5, context)?;
            log2(_5, sub(_6, _5, context)?, U256::from_be_slice(&[0x59, 0x0e, 0x04, 0xcd, 0xeb, 0xec, 0xcb, 0xa4, 0x0f, 0x56, 0x61, 0x86, 0xb9, 0x74, 0x6a, 0xd2, 0x95, 0xa4, 0xcd, 0x35, 0x8e, 0xa4, 0xfe, 0xfa, 0xae, 0xa6, 0xce, 0x79, 0x63, 0x0d, 0x96, 0xc0]), _4, context)?;
            Ok(())
        }

        pub fn modifier_onlyOwner_205<CI>(var_irm: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(_1, context)?, context)?;
            let expr_mpos = constant_NOT_OWNER(context)?;
            require_helper_string(expr, expr_mpos, context)?;
            fun_enableIrm_inner(var_irm, context)?;
            Ok(())
        }

        pub fn fun_enableIrm<CI>(var_irm: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyOwner_205(var_irm, context)?;
            Ok(())
        }

        pub fn external_fun_enableIrm<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_enableIrm(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_enableLltv_inner<CI>(var_lltv: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_bool_of_uint256(U256::from(0x5u128), var_lltv, context)?;
            let _2 = read_from_storage_split_offset_bool(_1, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            let expr_243_mpos = constant_ALREADY_SET(context)?;
            require_helper_string(expr, expr_243_mpos, context)?;
            let expr_1 = constant_WAD(context)?;
            let expr_2 = lt(cleanup_uint256(var_lltv, context)?, cleanup_uint256(expr_1, context)?, context)?;
            let expr_251_mpos = constant_MAX_LLTV_EXCEEDED(context)?;
            require_helper_string(expr_2, expr_251_mpos, context)?;
            let _3 = mapping_index_access_mapping_uint256_bool_of_uint256(U256::from(0x5u128), var_lltv, context)?;
            update_storage_value_offsett_bool_to_bool(_3, U256::from(0x1u128), context)?;
            let _4 = allocate_unbounded(context)?;
            let _5 = abi_encode_uint256(_4, var_lltv, context)?;
            log1(_4, sub(_5, _4, context)?, U256::from_be_slice(&[0x29, 0x7b, 0x80, 0xe7, 0xa8, 0x96, 0xfa, 0xd4, 0x70, 0xc6, 0x30, 0xf6, 0x57, 0x50, 0x72, 0xd6, 0x09, 0xbd, 0xe9, 0x97, 0x26, 0x0f, 0xf3, 0xdb, 0x85, 0x19, 0x39, 0x40, 0x5e, 0xc2, 0x91, 0x39]), context)?;
            Ok(())
        }

        pub fn modifier_onlyOwner_235<CI>(var_lltv: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(_1, context)?, context)?;
            let expr_mpos = constant_NOT_OWNER(context)?;
            require_helper_string(expr, expr_mpos, context)?;
            fun_enableLltv_inner(var_lltv, context)?;
            Ok(())
        }

        pub fn fun_enableLltv<CI>(var_lltv: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyOwner_235(var_lltv, context)?;
            Ok(())
        }

        pub fn external_fun_enableLltv<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_enableLltv(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn increment_uint256<CI>(mut value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            value = cleanup_uint256(value, context)?;
            if eq(value, not(U256::from(0x0u128), context)?, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            ret = add(value, U256::from(0x1u128), context)?;
            Ok(ret)
        }

        pub fn validator_revert_bytes32<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_bytes32(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn read_from_calldatat_bytes32<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_bytes32(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn zero_value_for_split_array_bytes32_dyn<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_extSloads<CI>(var_slots_offset: U256, var_slots_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_res_mpos = U256::ZERO;
            let zero_array_bytes32_dyn_mpos = zero_value_for_split_array_bytes32_dyn(context)?;
            var_res_mpos = zero_array_bytes32_dyn_mpos;
            let expr = array_length_array_bytes32_dyn_calldata(var_slots_offset, var_slots_length, context)?;
            let expr_2246_mpos = allocate_and_zero_memory_array_array_bytes32_dyn(expr, context)?;
            var_res_mpos = expr_2246_mpos;
            let mut var_i = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_i = zero_uint256;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_1 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_1, context)? != U256::ZERO {
                        break;
                    }
                    let _1 = var_i;
                    let _2 = increment_uint256(var_i, context)?;
                    var_i = _2;
                    let expr_2 = read_from_calldatat_bytes32(calldata_array_index_access_bytes32_dyn_calldata(var_slots_offset, var_slots_length, _1, context)?, context)?;
                    mstore(add(expr_2246_mpos, mul(_2, U256::from(0x20u128), context)?, context)?, sload(expr_2, context)?, context)?;
                }
                // post
                {

                }
            }
            Ok(var_res_mpos)
        }

        pub fn external_fun_extSloads<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_array_bytes32_dyn_calldata_ptr(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_extSloads(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_array_bytes32_dyn(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn shift_right_unsigned_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(bits, value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_dynamict_address<CI>(slot_value: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_address(shift_right_unsigned_dynamic(mul(offset, U256::from(0x8u128), context)?, slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_dynamic_address<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_dynamict_address(sload(slot, context)?, offset, context)?;
            Ok(value)
        }

        pub fn getter_fun_feeRecipient<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = read_from_storage_split_dynamic_address(U256::from(0x1u128), U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_feeRecipient<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_feeRecipient(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_address(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_safeTransferFrom<CI>(var_token_address: U256, var_from: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_contract_IERC20_to_address(var_token_address, context)?;
            let expr_1 = extcodesize(expr, context)?;
            let expr_2 = gt(cleanup_uint256(expr_1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            let expr_3378_mpos = constant_NO_CODE(context)?;
            require_helper_string(expr_2, expr_3378_mpos, context)?;
            let expr_3398_mpos = allocate_unbounded(context)?;
            let mut _1 = add(expr_3398_mpos, U256::from(0x20u128), context)?;
            mstore(_1, shl(U256::from(0xe0u128), U256::from(0x23b872ddu128), context)?, context)?;
            _1 = add(_1, U256::from(0x4u128), context)?;
            let _2 = abi_encode_address_address_uint256(_1, var_from, var_to, var_value, context)?;
            mstore(expr_3398_mpos, sub(_2, add(expr_3398_mpos, U256::from(0x20u128), context)?, context)?, context)?;
            finalize_allocation(expr_3398_mpos, sub(_2, expr_3398_mpos, context)?, context)?;
            let _3 = mload(expr_3398_mpos, context)?;
            let expr_3399_component = call(gas(context)?, expr, U256::from(0x0u128), add(expr_3398_mpos, U256::from(0x20u128), context)?, _3, U256::from(0x0u128), U256::from(0x0u128), context)?;
            let expr_component_mpos = extract_returndata(context)?;
            let expr_3404_mpos = constant_TRANSFER_FROM_REVERTED(context)?;
            require_helper_string(expr_3399_component, expr_3404_mpos, context)?;
            let expr_3 = array_length_bytes(expr_component_mpos, context)?;
            let expr_4 = eq(cleanup_uint256(expr_3, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            let mut expr_5 = expr_4;
            if iszero(expr_4, context)? != U256::ZERO {
                let expr_6 = abi_decode_bool_fromMemory(add(expr_component_mpos, U256::from(0x20u128), context)?, add(add(expr_component_mpos, U256::from(0x20u128), context)?, array_length_bytes(expr_component_mpos, context)?, context)?, context)?;
                expr_5 = expr_6;
            }
            let expr_3421_mpos = constant_TRANSFER_FROM_RETURNED_FALSE(context)?;
            require_helper_string(expr_5, expr_3421_mpos, context)?;
            Ok(())
        }

        pub fn revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn fun_flashLoan<CI>(var_token: U256, var_assets: U256, var_data_1702_offset: U256, var_data_1702_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = iszero(eq(cleanup_uint256(var_assets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1710_mpos = constant_ZERO_ASSETS(context)?;
            require_helper_string(expr, expr_1710_mpos, context)?;
            let _1 = convert_address_to_address(caller(context)?, context)?;
            let _2 = convert_address_to_address(var_token, context)?;
            let _3 = allocate_unbounded(context)?;
            let _4 = abi_encode_uint256(_3, var_assets, context)?;
            log3(_3, sub(_4, _3, context)?, U256::from_be_slice(&[0xc7, 0x6f, 0x1b, 0x4f, 0xe4, 0x39, 0x6a, 0xc0, 0x7a, 0x9f, 0xa5, 0x5a, 0x41, 0x5d, 0x4c, 0xa4, 0x30, 0xe7, 0x26, 0x51, 0xd3, 0x7d, 0x34, 0x01, 0xf3, 0xbe, 0xd7, 0xcb, 0x13, 0xfc, 0x4f, 0x12]), _1, _2, context)?;
            let expr_1724_address = convert_address_to_contract_IERC20(var_token, context)?;
            fun_safeTransfer(expr_1724_address, caller(context)?, var_assets, context)?;
            let expr_1734_address = convert_address_to_contract_IMorphoFlashLoanCallback(caller(context)?, context)?;
            let expr_1735_address = convert_contract_IMorphoFlashLoanCallback_to_address(expr_1734_address, context)?;
            if iszero(extcodesize(expr_1735_address, context)?, context)? != U256::ZERO {
                revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20(context)?;
            }
            let _5 = allocate_unbounded(context)?;
            mstore(_5, shift_left_224(U256::from(0x31f57072u128), context)?, context)?;
            let _6 = abi_encode_uint256_bytes_calldata(add(_5, U256::from(0x4u128), context)?, var_assets, var_data_1702_offset, var_data_1702_length, context)?;
            let _7 = call(gas(context)?, expr_1735_address, U256::from(0x0u128), _5, sub(_6, _5, context)?, _5, U256::from(0x0u128), context)?;
            if iszero(_7, context)? != U256::ZERO {
                revert_forward(context)?;
            }
            if _7 != U256::ZERO {
                let mut _8 = U256::from(0x0u128);
                if gt(U256::from(0x0u128), returndatasize(context)?, context)? != U256::ZERO {
                    _8 = returndatasize(context)?;
                }
                finalize_allocation(_5, _8, context)?;
                abi_decode_fromMemory(_5, add(_5, _8, context)?, context)?;
            }
            let expr_1 = convert_contract_Morpho_to_address(address(context)?, context)?;
            fun_safeTransferFrom(expr_1724_address, caller(context)?, expr_1, var_assets, context)?;
            Ok(())
        }

        pub fn external_fun_flashLoan<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3) = abi_decode_addresst_uint256t_bytes_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_flashLoan(param, param_1, param_2, param_3, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn getter_fun_idToMarketParams<CI>(key: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let mut ret_1 = U256::ZERO;
            let mut ret_2 = U256::ZERO;
            let mut ret_3 = U256::ZERO;
            let mut ret_4 = U256::ZERO;
            let mut slot = U256::from(0x8u128);
            slot = mapping_index_access_mapping_userDefinedValueType_Id_struct_MarketParams_storage_of_userDefinedValueType_Id(slot, key, context)?;
            ret = read_from_storage_split_offset_address(add(slot, U256::from(0x0u128), context)?, context)?;
            ret_1 = read_from_storage_split_offset_address(add(slot, U256::from(0x1u128), context)?, context)?;
            ret_2 = read_from_storage_split_offset_address(add(slot, U256::from(0x2u128), context)?, context)?;
            ret_3 = read_from_storage_split_offset_address(add(slot, U256::from(0x3u128), context)?, context)?;
            ret_4 = read_from_storage_split_offset_uint256(add(slot, U256::from(0x4u128), context)?, context)?;
            Ok((ret, ret_1, ret_2, ret_3, ret_4))
        }

        pub fn external_fun_idToMarketParams<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_userDefinedValueType_Id(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1, ret_2, ret_3, ret_4) = getter_fun_idToMarketParams(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_address_address_address_address_uint256(memPos, ret, ret_1, ret_2, ret_3, ret_4, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn extract_from_storage_value_dynamict_bool<CI>(slot_value: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_unsigned_dynamic(mul(offset, U256::from(0x8u128), context)?, slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_dynamic_bool<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_dynamict_bool(sload(slot, context)?, offset, context)?;
            Ok(value)
        }

        pub fn getter_fun_isAuthorized<CI>(key: U256, key_1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let mut slot = U256::from(0x6u128);
            slot = mapping_index_access_mapping_address_mapping_address_bool_of_address(U256::from(0x6u128), key, context)?;
            slot = mapping_index_access_mapping_address_bool_of_address(slot, key_1, context)?;
            ret = read_from_storage_split_dynamic_bool(slot, U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_isAuthorized<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_isAuthorized(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn getter_fun_isIrmEnabled<CI>(key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let mut slot = U256::from(0x4u128);
            slot = mapping_index_access_mapping_address_bool_of_address(U256::from(0x4u128), key, context)?;
            ret = read_from_storage_split_dynamic_bool(slot, U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_isIrmEnabled<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_isIrmEnabled(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn getter_fun_isLltvEnabled<CI>(key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let mut slot = U256::from(0x5u128);
            slot = mapping_index_access_mapping_uint256_bool_of_uint256(U256::from(0x5u128), key, context)?;
            ret = read_from_storage_split_dynamic_bool(slot, U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_isLltvEnabled<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_isLltvEnabled(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_min<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_z = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_z = zero_uint256;
            var_z = xor(var_x, mul(xor(var_x, var_y, context)?, lt(var_y, var_x, context)?, context)?, context)?;
            Ok(var_z)
        }

        pub fn fun_wDivDown<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = constant_WAD(context)?;
            let expr_1 = fun_mulDivDown(var_x, expr, var_y, context)?;
            var = expr_1;
            Ok(var)
        }

        pub fn fun_wDivUp<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = constant_WAD(context)?;
            let expr_1 = fun_mulDivUp(var_x, expr, var_y, context)?;
            var = expr_1;
            Ok(var)
        }

        pub fn fun_zeroFloorSub<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_z = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_z = zero_uint256;
            var_z = mul(gt(var_x, var_y, context)?, sub(var_x, var_y, context)?, context)?;
            Ok(var_z)
        }

        pub fn fun_liquidate<CI>(var_marketParams_1354_mpos: U256, var_borrower: U256, mut var_seizedAssets: U256, var_repaidShares: U256, var_data_offset: U256, var_data_1362_length: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let mut var_1 = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            var_1 = zero_uint256;
            let expr = fun_id(var_marketParams_1354_mpos, context)?;
            let _slot = U256::from(0x3u128);
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1384_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_1384_mpos, context)?;
            let expr_2 = fun_exactlyOneZero(var_seizedAssets, var_repaidShares, context)?;
            let expr_1394_mpos = constant_INCONSISTENT_INPUT(context)?;
            require_helper_string(expr_2, expr_1394_mpos, context)?;
            fun_accrueInterest(var_marketParams_1354_mpos, expr, context)?;
            let _3 = read_from_memoryt_address(add(var_marketParams_1354_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_1407_address = convert_address_to_contract_IOracle(_3, context)?;
            let expr_1408_address = convert_contract_IOracle_to_address(expr_1407_address, context)?;
            let _4 = allocate_unbounded(context)?;
            mstore(_4, shift_left_224(U256::from(0xa035b1feu128), context)?, context)?;
            let _5 = abi_encode_tuple(add(_4, U256::from(0x4u128), context)?, context)?;
            let _6 = staticcall(gas(context)?, expr_1408_address, _4, sub(_5, _4, context)?, _4, U256::from(0x20u128), context)?;
            if iszero(_6, context)? != U256::ZERO {
                revert_forward(context)?;
            }
            let mut expr_3 = U256::ZERO;
            if _6 != U256::ZERO {
                let mut _7 = U256::from(0x20u128);
                if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                    _7 = returndatasize(context)?;
                }
                finalize_allocation(_4, _7, context)?;
                expr_3 = abi_decode_uint256_fromMemory(_4, add(_4, _7, context)?, context)?;
            }
            let expr_4 = fun_isHealthy(var_marketParams_1354_mpos, expr, var_borrower, expr_3, context)?;
            let expr_5 = cleanup_bool(iszero(expr_4, context)?, context)?;
            let expr_1420_mpos = constant_HEALTHY_POSITION(context)?;
            require_helper_string(expr_5, expr_1420_mpos, context)?;
            let expr_6 = constant_MAX_LIQUIDATION_INCENTIVE_FACTOR(context)?;
            let expr_7 = constant_WAD(context)?;
            let expr_8 = constant_LIQUIDATION_CURSOR(context)?;
            let _8 = read_from_memoryt_uint256(add(var_marketParams_1354_mpos, U256::from(0x80u128), context)?, context)?;
            let expr_9 = checked_sub_uint256(expr_7, _8, context)?;
            let expr_10 = fun_wMulDown(expr_8, expr_9, context)?;
            let expr_11 = checked_sub_uint256(expr_7, expr_10, context)?;
            let expr_12 = fun_wDivDown(expr_7, expr_11, context)?;
            let expr_13 = fun_min(expr_6, expr_12, context)?;
            let expr_14 = gt(cleanup_uint256(var_seizedAssets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_14;
            if  == U256::from(0x0u128) {
                let _9 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _10 = read_from_storage_split_offset_t_uint128(add(_9, U256::from(0x1u128), context)?, context)?;
                let _11 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _12 = read_from_storage_split_offset_uint128(add(_11, U256::from(0x1u128), context)?, context)?;
                let _13 = convert_uint128_to_uint256(_10, context)?;
                let _14 = convert_uint128_to_uint256(_12, context)?;
                let expr_15 = fun_toAssetsDown(var_repaidShares, _13, _14, context)?;
                let expr_16 = fun_wMulDown(expr_15, expr_13, context)?;
                let expr_17 = constant_ORACLE_PRICE_SCALE(context)?;
                let expr_18 = fun_mulDivDown(expr_16, expr_17, expr_3, context)?;
                var_seizedAssets = expr_18;
            }
            let _21 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
            let _22 = read_from_storage_split_offset_t_uint128(add(_21, U256::from(0x1u128), context)?, context)?;
            let _23 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
            let _24 = read_from_storage_split_offset_uint128(add(_23, U256::from(0x1u128), context)?, context)?;
            let _25 = convert_uint128_to_uint256(_22, context)?;
            let _26 = convert_uint128_to_uint256(_24, context)?;
            let expr_23 = fun_toAssetsUp(var_repaidShares, _25, _26, context)?;
            let expr_24 = fun_toUint128(var_repaidShares, context)?;
            let _782_slot = U256::from(0x2u128);
            let _27 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(_782_slot, expr, context)?;
            let _28 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_27, var_borrower, context)?;
            let _29 = add(_28, U256::from(0x1u128), context)?;
            let _30 = read_from_storage_split_offset_t_uint128(_29, context)?;
            let expr_25 = checked_sub_uint128(_30, expr_24, context)?;
            update_storage_value_offsett_uint128_to_uint128(_29, expr_25, context)?;
            let expr_26 = fun_toUint128(var_repaidShares, context)?;
            let _31 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
            let _32 = add(_31, U256::from(0x1u128), context)?;
            let _33 = read_from_storage_split_offset_uint128(_32, context)?;
            let expr_27 = checked_sub_uint128(_33, expr_26, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_32, expr_27, context)?;
            let _34 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
            let _35 = read_from_storage_split_offset_t_uint128(add(_34, U256::from(0x1u128), context)?, context)?;
            let _36 = convert_uint128_to_uint256(_35, context)?;
            let expr_28 = fun_zeroFloorSub(_36, expr_23, context)?;
            let expr_29 = fun_toUint128(expr_28, context)?;
            let _37 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
            update_storage_value_offsett_uint128_to_uint128(add(_37, U256::from(0x1u128), context)?, expr_29, context)?;
            let expr_30 = fun_toUint128(var_seizedAssets, context)?;
            let _38 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(_782_slot, expr, context)?;
            let _39 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_38, var_borrower, context)?;
            let _40 = add(_39, U256::from(0x1u128), context)?;
            let _41 = read_from_storage_split_offset_uint128(_40, context)?;
            let expr_31 = checked_sub_uint128(_41, expr_30, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_40, expr_31, context)?;
            let mut var_badDebtShares = U256::ZERO;
            var_badDebtShares = zero_uint256;
            let mut var_badDebtAssets = U256::ZERO;
            var_badDebtAssets = zero_uint256;
            let _42 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(_782_slot, expr, context)?;
            let _43 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_42, var_borrower, context)?;
            let _44 = read_from_storage_split_offset_uint128(add(_43, U256::from(0x1u128), context)?, context)?;
            let expr_32 = eq(cleanup_uint128(_44, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr_32 != U256::ZERO {
                let _45 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(_782_slot, expr, context)?;
                let _46 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_45, var_borrower, context)?;
                let _47 = read_from_storage_split_offset_t_uint128(add(_46, U256::from(0x1u128), context)?, context)?;
                let _48 = convert_uint128_to_uint256(_47, context)?;
                var_badDebtShares = _48;
                let _49 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _50 = read_from_storage_split_offset_t_uint128(add(_49, U256::from(0x1u128), context)?, context)?;
                let _51 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _52 = read_from_storage_split_offset_t_uint128(add(_51, U256::from(0x1u128), context)?, context)?;
                let _53 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _54 = read_from_storage_split_offset_uint128(add(_53, U256::from(0x1u128), context)?, context)?;
                let _55 = convert_uint128_to_uint256(_52, context)?;
                let _56 = convert_uint128_to_uint256(_54, context)?;
                let expr_33 = fun_toAssetsUp(_48, _55, _56, context)?;
                let _57 = convert_uint128_to_uint256(_50, context)?;
                let expr_34 = fun_min(_57, expr_33, context)?;
                var_badDebtAssets = expr_34;
                let expr_35 = fun_toUint128(expr_34, context)?;
                let _58 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _59 = add(_58, U256::from(0x1u128), context)?;
                let _60 = read_from_storage_split_offset_t_uint128(_59, context)?;
                let expr_36 = checked_sub_uint128(_60, expr_35, context)?;
                update_storage_value_offsett_uint128_to_uint128(_59, expr_36, context)?;
                let expr_37 = fun_toUint128(expr_34, context)?;
                let _61 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _62 = add(_61, U256::from(0x0u128), context)?;
                let _63 = read_from_storage_split_offset_t_uint128(_62, context)?;
                let expr_38 = checked_sub_uint128(_63, expr_37, context)?;
                update_storage_value_offsett_uint128_to_uint128(_62, expr_38, context)?;
                let expr_39 = fun_toUint128(_48, context)?;
                let _64 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_slot, expr, context)?;
                let _65 = add(_64, U256::from(0x1u128), context)?;
                let _66 = read_from_storage_split_offset_uint128(_65, context)?;
                let expr_40 = checked_sub_uint128(_66, expr_39, context)?;
                update_storage_value_offsett_uint128_to_t_uint128(_65, expr_40, context)?;
                let _67 = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                let _68 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(_782_slot, expr, context)?;
                let _69 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_68, var_borrower, context)?;
                update_storage_value_offsett_uint128_to_uint128(add(_69, U256::from(0x1u128), context)?, _67, context)?;
            }
            let _70 = convert_bytes32_to_bytes32(expr, context)?;
            let _71 = convert_address_to_address(caller(context)?, context)?;
            let _72 = convert_address_to_address(var_borrower, context)?;
            let _73 = allocate_unbounded(context)?;
            let _74 = abi_encode_uint256_uint256_uint256_uint256_uint256(_73, expr_23, var_repaidShares, var_seizedAssets, var_badDebtAssets, var_badDebtShares, context)?;
            log4(_73, sub(_74, _73, context)?, U256::from_be_slice(&[0xa4, 0x94, 0x6e, 0xde, 0x45, 0xd0, 0xc6, 0xf0, 0x6a, 0x0f, 0x5c, 0xe9, 0x2c, 0x9a, 0xd3, 0xb4, 0x75, 0x14, 0x52, 0xd2, 0xfe, 0x0e, 0x25, 0x01, 0x07, 0x83, 0xbc, 0xab, 0x57, 0xa6, 0x7e, 0x41]), _70, _71, _72, context)?;
            let _75 = read_from_memoryt_address(add(var_marketParams_1354_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1655_address = convert_address_to_contract_IERC20(_75, context)?;
            fun_safeTransfer(expr_1655_address, caller(context)?, var_seizedAssets, context)?;
            let expr_41 = array_length_bytes_calldata(var_data_offset, var_data_1362_length, context)?;
            let expr_42 = gt(cleanup_uint256(expr_41, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_42 != U256::ZERO {
                let expr_1669_address = convert_address_to_contract_IMorphoLiquidateCallback(caller(context)?, context)?;
                let expr_1670_address = convert_contract_IMorphoLiquidateCallback_to_address(expr_1669_address, context)?;
                if iszero(extcodesize(expr_1670_address, context)?, context)? != U256::ZERO {
                    revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20(context)?;
                }
                let _76 = allocate_unbounded(context)?;
                mstore(_76, shift_left_224(U256::from(0xcf7ea196u128), context)?, context)?;
                let _77 = abi_encode_uint256_bytes_calldata(add(_76, U256::from(0x4u128), context)?, expr_23, var_data_offset, var_data_1362_length, context)?;
                let _78 = call(gas(context)?, expr_1670_address, U256::from(0x0u128), _76, sub(_77, _76, context)?, _76, U256::from(0x0u128), context)?;
                if iszero(_78, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                if _78 != U256::ZERO {
                    let mut _79 = U256::from(0x0u128);
                    if gt(U256::from(0x0u128), returndatasize(context)?, context)? != U256::ZERO {
                        _79 = returndatasize(context)?;
                    }
                    finalize_allocation(_76, _79, context)?;
                    abi_decode_fromMemory(_76, add(_76, _79, context)?, context)?;
                }
            }
            let _80 = read_from_memoryt_address(add(var_marketParams_1354_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_1679_address = convert_address_to_contract_IERC20(_80, context)?;
            let expr_43 = convert_contract_Morpho_to_address(address(context)?, context)?;
            fun_safeTransferFrom(expr_1679_address, caller(context)?, expr_43, expr_23, context)?;
            var = var_seizedAssets;
            var_1 = expr_23;
            Ok((var, var_1))
        }

        pub fn external_fun_liquidate<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3, param_4, param_5) = abi_decode_struct_MarketParamst_addresst_uint256t_uint256t_bytes_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1) = fun_liquidate(param, param_1, param_2, param_3, param_4, param_5, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256_uint256(memPos, ret, ret_1, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn getter_fun_market<CI>(key: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let mut ret_1 = U256::ZERO;
            let mut ret_2 = U256::ZERO;
            let mut ret_3 = U256::ZERO;
            let mut ret_4 = U256::ZERO;
            let mut ret_5 = U256::ZERO;
            let mut slot = U256::from(0x3u128);
            slot = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(slot, key, context)?;
            ret = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            ret_1 = read_from_storage_split_offset_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            ret_2 = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x1u128), context)?, context)?;
            ret_3 = read_from_storage_split_offset_uint128(add(slot, U256::from(0x1u128), context)?, context)?;
            ret_4 = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x2u128), context)?, context)?;
            ret_5 = read_from_storage_split_offset_uint128(add(slot, U256::from(0x2u128), context)?, context)?;
            Ok((ret, ret_1, ret_2, ret_3, ret_4, ret_5))
        }

        pub fn external_fun_market<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_userDefinedValueType_Id(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1, ret_2, ret_3, ret_4, ret_5) = getter_fun_market(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint128_uint128_uint128_uint128_uint128_uint128(memPos, ret, ret_1, ret_2, ret_3, ret_4, ret_5, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn mapping_index_access_mapping_address_uint256_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn extract_from_storage_value_dynamict_uint256<CI>(slot_value: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint256(shift_right_unsigned_dynamic(mul(offset, U256::from(0x8u128), context)?, slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_dynamic_uint256<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_dynamict_uint256(sload(slot, context)?, offset, context)?;
            Ok(value)
        }

        pub fn getter_fun_nonce<CI>(key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let mut slot = U256::from(0x7u128);
            slot = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x7u128), key, context)?;
            ret = read_from_storage_split_dynamic_uint256(slot, U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_nonce<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_nonce(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn getter_fun_owner<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = read_from_storage_split_dynamic_address(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_owner<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_owner(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_address(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn getter_fun_position<CI>(key: U256, key_1: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let mut ret_1 = U256::ZERO;
            let mut ret_2 = U256::ZERO;
            let mut slot = U256::from(0x2u128);
            slot = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(slot, key, context)?;
            slot = mapping_index_access_mapping_address_struct_Position_storage_of_address(slot, key_1, context)?;
            ret = read_from_storage_split_offset_uint256(add(slot, U256::from(0x0u128), context)?, context)?;
            ret_1 = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x1u128), context)?, context)?;
            ret_2 = read_from_storage_split_offset_uint128(add(slot, U256::from(0x1u128), context)?, context)?;
            Ok((ret, ret_1, ret_2))
        }

        pub fn external_fun_position<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_userDefinedValueType_Idt_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1, ret_2) = getter_fun_position(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256_uint128_uint128(memPos, ret, ret_1, ret_2, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_repay<CI>(var_marketParams_974_mpos: U256, mut var_assets: U256, var_shares: U256, var_onBehalf: U256, var_data_982_offset: U256, var_data_982_length: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let mut var_1 = U256::ZERO;
            let zero_t_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_t_uint256;
            var_1 = zero_t_uint256;
            let expr = fun_id(var_marketParams_974_mpos, context)?;
            let _25_slot = U256::from(0x3u128);
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_25_slot, expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1004_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_1004_mpos, context)?;
            let expr_2 = fun_exactlyOneZero(var_assets, var_shares, context)?;
            let expr_1014_mpos = constant_INCONSISTENT_INPUT(context)?;
            require_helper_string(expr_2, expr_1014_mpos, context)?;
            let expr_3 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_4 = iszero(eq(cleanup_address(var_onBehalf, context)?, cleanup_address(expr_3, context)?, context)?, context)?;
            let expr_1025_mpos = constant_ZERO_ADDRESS(context)?;
            require_helper_string(expr_4, expr_1025_mpos, context)?;
            fun_accrueInterest(var_marketParams_974_mpos, expr, context)?;
            let expr_5 = gt(cleanup_uint256(var_assets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_5;
            if  == U256::from(0x0u128) {
                let _3 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_25_slot, expr, context)?;
                let _4 = read_from_storage_split_offset_t_uint128(add(_3, U256::from(0x1u128), context)?, context)?;
                let _5 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_25_slot, expr, context)?;
                let _6 = read_from_storage_split_offset_uint128(add(_5, U256::from(0x1u128), context)?, context)?;
                let _7 = convert_uint128_to_uint256(_4, context)?;
                let _8 = convert_uint128_to_uint256(_6, context)?;
                let expr_6 = fun_toAssetsUp(var_shares, _7, _8, context)?;
                var_assets = expr_6;
            }
            let expr_8 = fun_toUint128(var_shares, context)?;
            let _15 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), expr, context)?;
            let _16 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_15, var_onBehalf, context)?;
            let _17 = add(_16, U256::from(0x1u128), context)?;
            let _18 = read_from_storage_split_offset_t_uint128(_17, context)?;
            let expr_9 = checked_sub_uint128(_18, expr_8, context)?;
            update_storage_value_offsett_uint128_to_uint128(_17, expr_9, context)?;
            let expr_10 = fun_toUint128(var_shares, context)?;
            let _19 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_25_slot, expr, context)?;
            let _20 = add(_19, U256::from(0x1u128), context)?;
            let _21 = read_from_storage_split_offset_uint128(_20, context)?;
            let expr_11 = checked_sub_uint128(_21, expr_10, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_20, expr_11, context)?;
            let _22 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_25_slot, expr, context)?;
            let _23 = read_from_storage_split_offset_t_uint128(add(_22, U256::from(0x1u128), context)?, context)?;
            let _24 = convert_uint128_to_uint256(_23, context)?;
            let expr_12 = fun_zeroFloorSub(_24, var_assets, context)?;
            let expr_13 = fun_toUint128(expr_12, context)?;
            let _25 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_25_slot, expr, context)?;
            update_storage_value_offsett_uint128_to_uint128(add(_25, U256::from(0x1u128), context)?, expr_13, context)?;
            let _26 = convert_bytes32_to_bytes32(expr, context)?;
            let _27 = convert_address_to_address(caller(context)?, context)?;
            let _28 = convert_address_to_address(var_onBehalf, context)?;
            let _29 = allocate_unbounded(context)?;
            let _30 = abi_encode_uint256_uint256(_29, var_assets, var_shares, context)?;
            log4(_29, sub(_30, _29, context)?, U256::from_be_slice(&[0x52, 0xac, 0xb0, 0x5c, 0xeb, 0xbd, 0x3c, 0xd3, 0x97, 0x15, 0x46, 0x9f, 0x22, 0xaf, 0xbf, 0x5a, 0x17, 0x49, 0x62, 0x95, 0xef, 0x3b, 0xc9, 0xbb, 0x59, 0x44, 0x05, 0x6c, 0x63, 0xcc, 0xaa, 0x09]), _26, _27, _28, context)?;
            let expr_14 = array_length_bytes_calldata(var_data_982_offset, var_data_982_length, context)?;
            let expr_15 = gt(cleanup_uint256(expr_14, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_15 != U256::ZERO {
                let expr_1119_address = convert_address_to_contract_IMorphoRepayCallback(caller(context)?, context)?;
                let expr_1120_address = convert_contract_IMorphoRepayCallback_to_address(expr_1119_address, context)?;
                if iszero(extcodesize(expr_1120_address, context)?, context)? != U256::ZERO {
                    revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20(context)?;
                }
                let _31 = allocate_unbounded(context)?;
                mstore(_31, shift_left_224(U256::from(0x5b4591cu128), context)?, context)?;
                let _32 = abi_encode_uint256_bytes_calldata(add(_31, U256::from(0x4u128), context)?, var_assets, var_data_982_offset, var_data_982_length, context)?;
                let _33 = call(gas(context)?, expr_1120_address, U256::from(0x0u128), _31, sub(_32, _31, context)?, _31, U256::from(0x0u128), context)?;
                if iszero(_33, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                if _33 != U256::ZERO {
                    let mut _34 = U256::from(0x0u128);
                    if gt(U256::from(0x0u128), returndatasize(context)?, context)? != U256::ZERO {
                        _34 = returndatasize(context)?;
                    }
                    finalize_allocation(_31, _34, context)?;
                    abi_decode_fromMemory(_31, add(_31, _34, context)?, context)?;
                }
            }
            let _35 = read_from_memoryt_address(add(var_marketParams_974_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_1129_address = convert_address_to_contract_IERC20(_35, context)?;
            let expr_16 = convert_contract_Morpho_to_address(address(context)?, context)?;
            fun_safeTransferFrom(expr_1129_address, caller(context)?, expr_16, var_assets, context)?;
            var = var_assets;
            var_1 = var_shares;
            Ok((var, var_1))
        }

        pub fn external_fun_repay<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3, param_4, param_5) = abi_decode_struct_MarketParamst_uint256t_uint256t_addresst_bytes_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1) = fun_repay(param, param_1, param_2, param_3, param_4, param_5, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256_uint256(memPos, ret, ret_1, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_setAuthorization<CI>(var_authorized: U256, var_newIsAuthorized: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_address_mapping_address_bool_of_address(U256::from(0x6u128), caller(context)?, context)?;
            let _2 = mapping_index_access_mapping_address_bool_of_address(_1, var_authorized, context)?;
            let _3 = read_from_storage_split_offset_bool(_2, context)?;
            let expr = iszero(eq(cleanup_bool(var_newIsAuthorized, context)?, cleanup_bool(_3, context)?, context)?, context)?;
            let expr_1772_mpos = constant_ALREADY_SET(context)?;
            require_helper_string(expr, expr_1772_mpos, context)?;
            let _4 = mapping_index_access_mapping_address_mapping_address_bool_of_address(U256::from(0x6u128), caller(context)?, context)?;
            let _5 = mapping_index_access_mapping_address_bool_of_address(_4, var_authorized, context)?;
            update_storage_value_offsett_bool_to_bool(_5, var_newIsAuthorized, context)?;
            let _6 = convert_address_to_address(caller(context)?, context)?;
            let _7 = convert_address_to_address(var_authorized, context)?;
            let _8 = allocate_unbounded(context)?;
            let _9 = abi_encode_tuple_bool(_8, var_newIsAuthorized, context)?;
            log4(_8, sub(_9, _8, context)?, U256::from_be_slice(&[0xd5, 0xe9, 0x69, 0xf0, 0x1e, 0xfe, 0x92, 0x1d, 0x3f, 0x76, 0x6b, 0xde, 0xba, 0xd2, 0x5f, 0x0a, 0x05, 0xe3, 0xf2, 0x37, 0x31, 0x1f, 0x56, 0x48, 0x2b, 0xf1, 0x32, 0xd0, 0x32, 0x63, 0x09, 0xc0]), _6, _6, _7, context)?;
            Ok(())
        }

        pub fn external_fun_setAuthorization<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_bool(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_setAuthorization(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn validator_revert_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint8(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn read_from_calldatat_uint8<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_uint8(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_bool<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_bool(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn fun_setAuthorizationWithSig<CI>(var_authorization_mpos: U256, var_signature_offset: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_memoryt_uint256(add(var_authorization_mpos, U256::from(0x80u128), context)?, context)?;
            let expr = iszero(gt(cleanup_uint256(timestamp(context)?, context)?, cleanup_uint256(_1, context)?, context)?, context)?;
            let expr_1813_mpos = constant_SIGNATURE_EXPIRED(context)?;
            require_helper_string(expr, expr_1813_mpos, context)?;
            let _2 = add(var_authorization_mpos, U256::from(0x60u128), context)?;
            let _3 = read_from_memoryt_uint256(_2, context)?;
            let _4 = read_from_memoryt_address(add(var_authorization_mpos, U256::from(0x0u128), context)?, context)?;
            let _5 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x7u128), _4, context)?;
            let _6 = read_from_storage_split_offset_uint256(_5, context)?;
            let _7 = increment_uint256(_6, context)?;
            update_storage_value_offsett_uint256_to_uint256(_5, _7, context)?;
            let expr_1 = eq(cleanup_uint256(_3, context)?, cleanup_uint256(_6, context)?, context)?;
            let expr_1826_mpos = constant_INVALID_NONCE(context)?;
            require_helper_string(expr_1, expr_1826_mpos, context)?;
            let expr_2 = constant_AUTHORIZATION_TYPEHASH(context)?;
            let expr_1836_mpos = allocate_unbounded(context)?;
            let _8 = add(expr_1836_mpos, U256::from(0x20u128), context)?;
            let _9 = abi_encode_bytes32_struct_Authorization(_8, expr_2, var_authorization_mpos, context)?;
            mstore(expr_1836_mpos, sub(_9, _8, context)?, context)?;
            finalize_allocation(expr_1836_mpos, sub(_9, expr_1836_mpos, context)?, context)?;
            let expr_3 = keccak256(array_dataslot_bytes(expr_1836_mpos, context)?, array_length_bytes(expr_1836_mpos, context)?, context)?;
            let _10 = loadimmutable(from_hex("3634000000000000000000000000000000000000000000000000000000000000"), context)?;
            let expr_1848_mpos = bytes_concat_stringliteral_301a_bytes32_bytes32(_10, expr_3, context)?;
            let expr_4 = keccak256(array_dataslot_bytes(expr_1848_mpos, context)?, array_length_bytes(expr_1848_mpos, context)?, context)?;
            let expr_5 = read_from_calldatat_uint8(add(var_signature_offset, U256::from(0x0u128), context)?, context)?;
            let expr_6 = read_from_calldatat_bytes32(add(var_signature_offset, U256::from(0x20u128), context)?, context)?;
            let expr_7 = read_from_calldatat_bytes32(add(var_signature_offset, U256::from(0x40u128), context)?, context)?;
            let _11 = allocate_unbounded(context)?;
            let _12 = abi_encode_bytes32_uint8_bytes32_bytes32(_11, expr_4, expr_5, expr_6, expr_7, context)?;
            mstore(U256::from(0x0u128), U256::from(0x0u128), context)?;
            let _13 = staticcall(gas(context)?, U256::from(0x1u128), _11, sub(_12, _11, context)?, U256::from(0x0u128), U256::from(0x20u128), context)?;
            if iszero(_13, context)? != U256::ZERO {
                revert_forward(context)?;
            }
            let expr_8 = shift_left(mload(U256::from(0x0u128), context)?, context)?;
            let expr_9 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_10 = iszero(eq(cleanup_address(expr_8, context)?, cleanup_address(expr_9, context)?, context)?, context)?;
            let mut expr_11 = expr_10;
            if expr_10 != U256::ZERO {
                let _14 = read_from_memoryt_address(add(var_authorization_mpos, U256::from(0x0u128), context)?, context)?;
                let expr_12 = eq(cleanup_address(_14, context)?, cleanup_address(expr_8, context)?, context)?;
                expr_11 = expr_12;
            }
            let expr_1876_mpos = constant_INVALID_SIGNATURE(context)?;
            require_helper_string(expr_11, expr_1876_mpos, context)?;
            let _15 = add(var_authorization_mpos, U256::from(0x0u128), context)?;
            let _16 = read_from_memoryt_address(_15, context)?;
            let _17 = read_from_memoryt_uint256(_2, context)?;
            let _18 = convert_address_to_address(caller(context)?, context)?;
            let _19 = convert_address_to_address(_16, context)?;
            let _20 = allocate_unbounded(context)?;
            let _21 = abi_encode_uint256(_20, _17, context)?;
            log3(_20, sub(_21, _20, context)?, U256::from_be_slice(&[0xa5, 0x8a, 0xf1, 0xa0, 0xc7, 0x0d, 0xba, 0x0c, 0x7a, 0xa6, 0x0d, 0x1a, 0x1a, 0x14, 0x7e, 0xbd, 0x61, 0x00, 0x0d, 0x16, 0x90, 0xa9, 0x68, 0x82, 0x8a, 0xc7, 0x18, 0xbc, 0xa9, 0x27, 0xf2, 0xc7]), _18, _19, context)?;
            let _22 = add(var_authorization_mpos, U256::from(0x40u128), context)?;
            let _23 = read_from_memoryt_bool(_22, context)?;
            let _24 = read_from_memoryt_address(_15, context)?;
            let _25 = mapping_index_access_mapping_address_mapping_address_bool_of_address(U256::from(0x6u128), _24, context)?;
            let _26 = add(var_authorization_mpos, U256::from(0x20u128), context)?;
            let _27 = read_from_memoryt_address(_26, context)?;
            let _28 = mapping_index_access_mapping_address_bool_of_address(_25, _27, context)?;
            update_storage_value_offsett_bool_to_bool(_28, _23, context)?;
            let _29 = read_from_memoryt_address(_15, context)?;
            let _30 = read_from_memoryt_address(_26, context)?;
            let _31 = read_from_memoryt_bool(_22, context)?;
            let _32 = convert_address_to_address(_29, context)?;
            let _33 = convert_address_to_address(_30, context)?;
            let _34 = allocate_unbounded(context)?;
            let _35 = abi_encode_tuple_bool(_34, _31, context)?;
            log4(_34, sub(_35, _34, context)?, U256::from_be_slice(&[0xd5, 0xe9, 0x69, 0xf0, 0x1e, 0xfe, 0x92, 0x1d, 0x3f, 0x76, 0x6b, 0xde, 0xba, 0xd2, 0x5f, 0x0a, 0x05, 0xe3, 0xf2, 0x37, 0x31, 0x1f, 0x56, 0x48, 0x2b, 0xf1, 0x32, 0xd0, 0x32, 0x63, 0x09, 0xc0]), _18, _32, _33, context)?;
            Ok(())
        }

        pub fn external_fun_setAuthorizationWithSig<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_struct_Authorizationt_struct_Signature_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_setAuthorizationWithSig(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_setFee_inner<CI>(var_marketParams_mpos: U256, var_newFee: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_id(var_marketParams_mpos, context)?;
            let _164_slot = U256::from(0x3u128);
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_164_slot, expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_293_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_293_mpos, context)?;
            let _3 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_164_slot, expr, context)?;
            let _4 = read_from_storage_split_offset_uint128(add(_3, U256::from(0x2u128), context)?, context)?;
            let expr_2 = iszero(eq(cleanup_uint256(var_newFee, context)?, convert_uint128_to_uint256(_4, context)?, context)?, context)?;
            let expr_304_mpos = constant_ALREADY_SET(context)?;
            require_helper_string(expr_2, expr_304_mpos, context)?;
            let expr_3 = constant_MAX_FEE(context)?;
            let expr_4 = iszero(gt(cleanup_uint256(var_newFee, context)?, cleanup_uint256(expr_3, context)?, context)?, context)?;
            let expr_312_mpos = constant_MAX_FEE_EXCEEDED(context)?;
            require_helper_string(expr_4, expr_312_mpos, context)?;
            fun_accrueInterest(var_marketParams_mpos, expr, context)?;
            let expr_5 = convert_uint256_to_uint128(var_newFee, context)?;
            let _5 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_164_slot, expr, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(add(_5, U256::from(0x2u128), context)?, expr_5, context)?;
            let _6 = convert_bytes32_to_bytes32(expr, context)?;
            let _7 = allocate_unbounded(context)?;
            let _8 = abi_encode_uint256(_7, var_newFee, context)?;
            log2(_7, sub(_8, _7, context)?, U256::from_be_slice(&[0x13, 0x9d, 0x6f, 0x58, 0xe9, 0xa1, 0x27, 0x22, 0x96, 0x67, 0xc8, 0xe3, 0xb3, 0x6e, 0x88, 0x89, 0x0a, 0x66, 0xcf, 0xc8, 0xab, 0x10, 0x24, 0xdd, 0xc5, 0x13, 0xe1, 0x89, 0xe1, 0x25, 0xb7, 0x5b]), _6, context)?;
            Ok(())
        }

        pub fn modifier_onlyOwner_276<CI>(var_marketParams_271_mpos: U256, var_newFee: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(_1, context)?, context)?;
            let expr_mpos = constant_NOT_OWNER(context)?;
            require_helper_string(expr, expr_mpos, context)?;
            fun_setFee_inner(var_marketParams_271_mpos, var_newFee, context)?;
            Ok(())
        }

        pub fn fun_setFee<CI>(var_marketParams_mpos: U256, var_newFee: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyOwner_276(var_marketParams_mpos, var_newFee, context)?;
            Ok(())
        }

        pub fn external_fun_setFee<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_struct_MarketParamst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_setFee(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_setFeeRecipient_inner<CI>(var_newFeeRecipient: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x1u128), context)?;
            let expr = iszero(eq(cleanup_address(var_newFeeRecipient, context)?, cleanup_address(_1, context)?, context)?, context)?;
            let expr_351_mpos = constant_ALREADY_SET(context)?;
            require_helper_string(expr, expr_351_mpos, context)?;
            update_storage_value_offsett_address_to_address(U256::from(0x1u128), var_newFeeRecipient, context)?;
            let _2 = convert_address_to_address(var_newFeeRecipient, context)?;
            let _3 = allocate_unbounded(context)?;
            let _4 = abi_encode_tuple(_3, context)?;
            log2(_3, sub(_4, _3, context)?, U256::from_be_slice(&[0x2e, 0x97, 0x9f, 0x80, 0xfe, 0x4d, 0x43, 0x05, 0x5c, 0x58, 0x4c, 0xf4, 0xa8, 0x46, 0x7c, 0x55, 0x87, 0x5e, 0xa3, 0x67, 0x28, 0xfc, 0x37, 0x17, 0x6c, 0x05, 0xac, 0xd7, 0x84, 0xeb, 0x7a, 0x73]), _2, context)?;
            Ok(())
        }

        pub fn modifier_onlyOwner_344<CI>(var_newFeeRecipient: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(_1, context)?, context)?;
            let expr_mpos = constant_NOT_OWNER(context)?;
            require_helper_string(expr, expr_mpos, context)?;
            fun_setFeeRecipient_inner(var_newFeeRecipient, context)?;
            Ok(())
        }

        pub fn fun_setFeeRecipient<CI>(var_newFeeRecipient: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyOwner_344(var_newFeeRecipient, context)?;
            Ok(())
        }

        pub fn external_fun_setFeeRecipient<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_setFeeRecipient(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_setOwner_inner<CI>(var_newOwner: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = iszero(eq(cleanup_address(var_newOwner, context)?, cleanup_address(_1, context)?, context)?, context)?;
            let expr_185_mpos = constant_ALREADY_SET(context)?;
            require_helper_string(expr, expr_185_mpos, context)?;
            update_storage_value_offsett_address_to_address(U256::from(0x0u128), var_newOwner, context)?;
            let _2 = convert_address_to_address(var_newOwner, context)?;
            let _3 = allocate_unbounded(context)?;
            let _4 = abi_encode_tuple(_3, context)?;
            log2(_3, sub(_4, _3, context)?, U256::from_be_slice(&[0x16, 0x7d, 0x3e, 0x9c, 0x10, 0x16, 0xab, 0x80, 0xe5, 0x88, 0x02, 0xca, 0x9d, 0xa1, 0x0c, 0xe5, 0xc6, 0xa0, 0xf4, 0xde, 0xbc, 0x46, 0xa2, 0xe7, 0xa2, 0xcd, 0x9e, 0x56, 0x89, 0x9a, 0x4f, 0xb5]), _2, context)?;
            Ok(())
        }

        pub fn modifier_onlyOwner<CI>(var_newOwner: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(_1, context)?, context)?;
            let expr_mpos = constant_NOT_OWNER(context)?;
            require_helper_string(expr, expr_mpos, context)?;
            fun_setOwner_inner(var_newOwner, context)?;
            Ok(())
        }

        pub fn fun_setOwner<CI>(var_newOwner: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyOwner(var_newOwner, context)?;
            Ok(())
        }

        pub fn external_fun_setOwner<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_setOwner(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_supply<CI>(var_marketParams_456_mpos: U256, mut var_assets: U256, var_shares: U256, var_onBehalf: U256, var_data_464_offset: U256, var_data_464_length: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let mut var_1 = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            var_1 = zero_uint256;
            let expr = fun_id(var_marketParams_456_mpos, context)?;
            let _610_slot = U256::from(0x3u128);
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_610_slot, expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_486_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_486_mpos, context)?;
            let expr_2 = fun_exactlyOneZero(var_assets, var_shares, context)?;
            let expr_496_mpos = constant_INCONSISTENT_INPUT(context)?;
            require_helper_string(expr_2, expr_496_mpos, context)?;
            let expr_3 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_4 = iszero(eq(cleanup_address(var_onBehalf, context)?, cleanup_address(expr_3, context)?, context)?, context)?;
            let expr_507_mpos = constant_ZERO_ADDRESS(context)?;
            require_helper_string(expr_4, expr_507_mpos, context)?;
            fun_accrueInterest(var_marketParams_456_mpos, expr, context)?;
            let expr_5 = gt(cleanup_uint256(var_assets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_5;
            if  == U256::from(0x0u128) {
                let _3 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_610_slot, expr, context)?;
                let _4 = read_from_storage_split_offset_t_uint128(add(_3, U256::from(0x0u128), context)?, context)?;
                let _5 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_610_slot, expr, context)?;
                let _6 = read_from_storage_split_offset_uint128(add(_5, U256::from(0x0u128), context)?, context)?;
                let _7 = convert_uint128_to_uint256(_4, context)?;
                let _8 = convert_uint128_to_uint256(_6, context)?;
                let expr_6 = fun_toAssetsUp(var_shares, _7, _8, context)?;
                var_assets = expr_6;
            }
            let _15 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), expr, context)?;
            let _16 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_15, var_onBehalf, context)?;
            let _17 = add(_16, U256::from(0x0u128), context)?;
            let _18 = read_from_storage_split_offset_uint256(_17, context)?;
            let expr_8 = checked_add_uint256(_18, var_shares, context)?;
            update_storage_value_offsett_uint256_to_uint256(_17, expr_8, context)?;
            let expr_9 = fun_toUint128(var_shares, context)?;
            let _19 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_610_slot, expr, context)?;
            let _20 = add(_19, U256::from(0x0u128), context)?;
            let _21 = read_from_storage_split_offset_uint128(_20, context)?;
            let expr_10 = checked_add_uint128(_21, expr_9, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_20, expr_10, context)?;
            let expr_11 = fun_toUint128(var_assets, context)?;
            let _22 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_610_slot, expr, context)?;
            let _23 = add(_22, U256::from(0x0u128), context)?;
            let _24 = read_from_storage_split_offset_t_uint128(_23, context)?;
            let expr_12 = checked_add_uint128(_24, expr_11, context)?;
            update_storage_value_offsett_uint128_to_uint128(_23, expr_12, context)?;
            let _25 = convert_bytes32_to_bytes32(expr, context)?;
            let _26 = convert_address_to_address(caller(context)?, context)?;
            let _27 = convert_address_to_address(var_onBehalf, context)?;
            let _28 = allocate_unbounded(context)?;
            let _29 = abi_encode_uint256_uint256(_28, var_assets, var_shares, context)?;
            log4(_28, sub(_29, _28, context)?, U256::from_be_slice(&[0xed, 0xf8, 0x87, 0x04, 0x33, 0xc8, 0x38, 0x23, 0xeb, 0x07, 0x1d, 0x3d, 0xf1, 0xca, 0xa8, 0xd0, 0x08, 0xf1, 0x2f, 0x64, 0x40, 0x91, 0x8c, 0x20, 0xd7, 0x5a, 0x36, 0x02, 0xcd, 0xa3, 0x0f, 0xe0]), _25, _26, _27, context)?;
            let expr_13 = array_length_bytes_calldata(var_data_464_offset, var_data_464_length, context)?;
            let expr_14 = gt(cleanup_uint256(expr_13, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_14 != U256::ZERO {
                let expr_address = convert_address_to_contract_IMorphoSupplyCallback(caller(context)?, context)?;
                let expr_593_address = convert_contract_IMorphoSupplyCallback_to_address(expr_address, context)?;
                if iszero(extcodesize(expr_593_address, context)?, context)? != U256::ZERO {
                    revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20(context)?;
                }
                let _30 = allocate_unbounded(context)?;
                mstore(_30, shift_left_224(U256::from(0x2075be03u128), context)?, context)?;
                let _31 = abi_encode_uint256_bytes_calldata(add(_30, U256::from(0x4u128), context)?, var_assets, var_data_464_offset, var_data_464_length, context)?;
                let _32 = call(gas(context)?, expr_593_address, U256::from(0x0u128), _30, sub(_31, _30, context)?, _30, U256::from(0x0u128), context)?;
                if iszero(_32, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                if _32 != U256::ZERO {
                    let mut _33 = U256::from(0x0u128);
                    if gt(U256::from(0x0u128), returndatasize(context)?, context)? != U256::ZERO {
                        _33 = returndatasize(context)?;
                    }
                    finalize_allocation(_30, _33, context)?;
                    abi_decode_fromMemory(_30, add(_30, _33, context)?, context)?;
                }
            }
            let _34 = read_from_memoryt_address(add(var_marketParams_456_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_602_address = convert_address_to_contract_IERC20(_34, context)?;
            let expr_15 = convert_contract_Morpho_to_address(address(context)?, context)?;
            fun_safeTransferFrom(expr_602_address, caller(context)?, expr_15, var_assets, context)?;
            var = var_assets;
            var_1 = var_shares;
            Ok((var, var_1))
        }

        pub fn external_fun_supply<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3, param_4, param_5) = abi_decode_struct_MarketParamst_uint256t_uint256t_addresst_bytes_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1) = fun_supply(param, param_1, param_2, param_3, param_4, param_5, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256_uint256(memPos, ret, ret_1, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_supplyCollateral<CI>(var_marketParams_1149_mpos: U256, var_assets: U256, var_onBehalf: U256, var_data_1155_offset: U256, var_data_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_id(var_marketParams_1149_mpos, context)?;
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(U256::from(0x3u128), expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1173_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_1173_mpos, context)?;
            let expr_2 = iszero(eq(cleanup_uint256(var_assets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1181_mpos = constant_ZERO_ASSETS(context)?;
            require_helper_string(expr_2, expr_1181_mpos, context)?;
            let expr_3 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_4 = iszero(eq(cleanup_address(var_onBehalf, context)?, cleanup_address(expr_3, context)?, context)?, context)?;
            let expr_mpos = constant_ZERO_ADDRESS(context)?;
            require_helper_string(expr_4, expr_mpos, context)?;
            let expr_5 = fun_toUint128(var_assets, context)?;
            let _3 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), expr, context)?;
            let _4 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_3, var_onBehalf, context)?;
            let _5 = add(_4, U256::from(0x1u128), context)?;
            let _6 = read_from_storage_split_offset_uint128(_5, context)?;
            let expr_6 = checked_add_uint128(_6, expr_5, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_5, expr_6, context)?;
            let _7 = convert_bytes32_to_bytes32(expr, context)?;
            let _8 = convert_address_to_address(caller(context)?, context)?;
            let _9 = convert_address_to_address(var_onBehalf, context)?;
            let _10 = allocate_unbounded(context)?;
            let _11 = abi_encode_uint256(_10, var_assets, context)?;
            log4(_10, sub(_11, _10, context)?, U256::from_be_slice(&[0xa3, 0xb9, 0x47, 0x2a, 0x13, 0x99, 0xe1, 0x7e, 0x12, 0x3f, 0x3c, 0x2e, 0x65, 0x86, 0xc2, 0x3e, 0x50, 0x41, 0x84, 0xd5, 0x04, 0xde, 0x59, 0xcd, 0xaa, 0x2b, 0x37, 0x5e, 0x88, 0x0c, 0x61, 0x84]), _7, _8, _9, context)?;
            let expr_7 = array_length_bytes_calldata(var_data_1155_offset, var_data_length, context)?;
            let expr_8 = gt(cleanup_uint256(expr_7, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_8 != U256::ZERO {
                let expr_1223_address = convert_address_to_contract_IMorphoSupplyCollateralCallback(caller(context)?, context)?;
                let expr_1224_address = convert_contract_IMorphoSupplyCollateralCallback_to_address(expr_1223_address, context)?;
                if iszero(extcodesize(expr_1224_address, context)?, context)? != U256::ZERO {
                    revert_error_0cc013b6b3b6beabea4e3a74a6d380f0df81852ca99887912475e1f66b2a2c20(context)?;
                }
                let _12 = allocate_unbounded(context)?;
                mstore(_12, shift_left_224(U256::from(0xb1022fdfu128), context)?, context)?;
                let _13 = abi_encode_uint256_bytes_calldata(add(_12, U256::from(0x4u128), context)?, var_assets, var_data_1155_offset, var_data_length, context)?;
                let _14 = call(gas(context)?, expr_1224_address, U256::from(0x0u128), _12, sub(_13, _12, context)?, _12, U256::from(0x0u128), context)?;
                if iszero(_14, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                if _14 != U256::ZERO {
                    let mut _15 = U256::from(0x0u128);
                    if gt(U256::from(0x0u128), returndatasize(context)?, context)? != U256::ZERO {
                        _15 = returndatasize(context)?;
                    }
                    finalize_allocation(_12, _15, context)?;
                    abi_decode_fromMemory(_12, add(_12, _15, context)?, context)?;
                }
            }
            let _16 = read_from_memoryt_address(add(var_marketParams_1149_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1233_address = convert_address_to_contract_IERC20(_16, context)?;
            let expr_9 = convert_contract_Morpho_to_address(address(context)?, context)?;
            fun_safeTransferFrom(expr_1233_address, caller(context)?, expr_9, var_assets, context)?;
            Ok(())
        }

        pub fn external_fun_supplyCollateral<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3, param_4) = abi_decode_struct_MarketParamst_uint256t_addresst_bytes_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_supplyCollateral(param, param_1, param_2, param_3, param_4, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_withdraw<CI>(var_marketParams_622_mpos: U256, mut var_assets: U256, var_shares: U256, var_onBehalf: U256, var_receiver: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let mut var_1 = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            var_1 = zero_uint256;
            let expr = fun_id(var_marketParams_622_mpos, context)?;
            let _331_slot = U256::from(0x3u128);
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_331_slot, expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_652_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_652_mpos, context)?;
            let expr_2 = fun_exactlyOneZero(var_assets, var_shares, context)?;
            let expr_662_mpos = constant_INCONSISTENT_INPUT(context)?;
            require_helper_string(expr_2, expr_662_mpos, context)?;
            let expr_3 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_4 = iszero(eq(cleanup_address(var_receiver, context)?, cleanup_address(expr_3, context)?, context)?, context)?;
            let expr_673_mpos = constant_ZERO_ADDRESS(context)?;
            require_helper_string(expr_4, expr_673_mpos, context)?;
            let expr_5 = fun_isSenderAuthorized(var_onBehalf, context)?;
            let expr_681_mpos = constant_UNAUTHORIZED(context)?;
            require_helper_string(expr_5, expr_681_mpos, context)?;
            fun_accrueInterest(var_marketParams_622_mpos, expr, context)?;
            let expr_6 = gt(cleanup_uint256(var_assets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_6;
            if  == U256::from(0x0u128) {
                let _3 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_331_slot, expr, context)?;
                let _4 = read_from_storage_split_offset_t_uint128(add(_3, U256::from(0x0u128), context)?, context)?;
                let _5 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_331_slot, expr, context)?;
                let _6 = read_from_storage_split_offset_uint128(add(_5, U256::from(0x0u128), context)?, context)?;
                let _7 = convert_uint128_to_uint256(_4, context)?;
                let _8 = convert_uint128_to_uint256(_6, context)?;
                let expr_7 = fun_toAssetsDown(var_shares, _7, _8, context)?;
                var_assets = expr_7;
            }
            let _15 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), expr, context)?;
            let _16 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_15, var_onBehalf, context)?;
            let _17 = add(_16, U256::from(0x0u128), context)?;
            let _18 = read_from_storage_split_offset_uint256(_17, context)?;
            let expr_9 = checked_sub_uint256(_18, var_shares, context)?;
            update_storage_value_offsett_uint256_to_uint256(_17, expr_9, context)?;
            let expr_10 = fun_toUint128(var_shares, context)?;
            let _19 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_331_slot, expr, context)?;
            let _20 = add(_19, U256::from(0x0u128), context)?;
            let _21 = read_from_storage_split_offset_uint128(_20, context)?;
            let expr_11 = checked_sub_uint128(_21, expr_10, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_20, expr_11, context)?;
            let expr_12 = fun_toUint128(var_assets, context)?;
            let _22 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_331_slot, expr, context)?;
            let _23 = add(_22, U256::from(0x0u128), context)?;
            let _24 = read_from_storage_split_offset_t_uint128(_23, context)?;
            let expr_13 = checked_sub_uint128(_24, expr_12, context)?;
            update_storage_value_offsett_uint128_to_uint128(_23, expr_13, context)?;
            let _25 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_331_slot, expr, context)?;
            let _26 = read_from_storage_split_offset_t_uint128(add(_25, U256::from(0x1u128), context)?, context)?;
            let _27 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(_331_slot, expr, context)?;
            let _28 = read_from_storage_split_offset_t_uint128(add(_27, U256::from(0x0u128), context)?, context)?;
            let expr_14 = iszero(gt(cleanup_uint128(_26, context)?, cleanup_uint128(_28, context)?, context)?, context)?;
            let expr_759_mpos = constant_INSUFFICIENT_LIQUIDITY(context)?;
            require_helper_string(expr_14, expr_759_mpos, context)?;
            let _29 = convert_bytes32_to_bytes32(expr, context)?;
            let _30 = convert_address_to_address(var_onBehalf, context)?;
            let _31 = convert_address_to_address(var_receiver, context)?;
            let _32 = allocate_unbounded(context)?;
            let _33 = abi_encode_address_uint256_uint256(_32, caller(context)?, var_assets, var_shares, context)?;
            log4(_32, sub(_33, _32, context)?, U256::from_be_slice(&[0xa5, 0x6f, 0xc0, 0xad, 0x57, 0x02, 0xec, 0x05, 0xce, 0x63, 0x66, 0x62, 0x21, 0xf7, 0x96, 0xfb, 0x62, 0x43, 0x7c, 0x32, 0xdb, 0x1a, 0xa1, 0xaa, 0x07, 0x5f, 0xc6, 0x48, 0x4c, 0xf5, 0x8f, 0xbf]), _29, _30, _31, context)?;
            let _34 = read_from_memoryt_address(add(var_marketParams_622_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_777_address = convert_address_to_contract_IERC20(_34, context)?;
            fun_safeTransfer(expr_777_address, var_receiver, var_assets, context)?;
            var = var_assets;
            var_1 = var_shares;
            Ok((var, var_1))
        }

        pub fn external_fun_withdraw<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3, param_4) = abi_decode_struct_MarketParamst_uint256t_uint256t_addresst_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let (ret, ret_1) = fun_withdraw(param, param_1, param_2, param_3, param_4, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256_uint256(memPos, ret, ret_1, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_withdrawCollateral<CI>(var_marketParams_1249_mpos: U256, var_assets: U256, var_onBehalf: U256, var_receiver: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_id(var_marketParams_1249_mpos, context)?;
            let _1 = mapping_index_access_mapping_userDefinedValueType_Id_struct_Market_storage_of_userDefinedValueType_Id(U256::from(0x3u128), expr, context)?;
            let _2 = read_from_storage_split_offset_t_uint128(add(_1, U256::from(0x2u128), context)?, context)?;
            let expr_1 = iszero(eq(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1273_mpos = constant_MARKET_NOT_CREATED(context)?;
            require_helper_string(expr_1, expr_1273_mpos, context)?;
            let expr_2 = iszero(eq(cleanup_uint256(var_assets, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let expr_1281_mpos = constant_ZERO_ASSETS(context)?;
            require_helper_string(expr_2, expr_1281_mpos, context)?;
            let expr_3 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_4 = iszero(eq(cleanup_address(var_receiver, context)?, cleanup_address(expr_3, context)?, context)?, context)?;
            let expr_1292_mpos = constant_ZERO_ADDRESS(context)?;
            require_helper_string(expr_4, expr_1292_mpos, context)?;
            let expr_5 = fun_isSenderAuthorized(var_onBehalf, context)?;
            let expr_1300_mpos = constant_UNAUTHORIZED(context)?;
            require_helper_string(expr_5, expr_1300_mpos, context)?;
            fun_accrueInterest(var_marketParams_1249_mpos, expr, context)?;
            let expr_6 = fun_toUint128(var_assets, context)?;
            let _3 = mapping_index_access_mapping_userDefinedValueType_Id_mapping_address_struct_Position_storage_of_userDefinedValueType_Id(U256::from(0x2u128), expr, context)?;
            let _4 = mapping_index_access_mapping_address_struct_Position_storage_of_address(_3, var_onBehalf, context)?;
            let _5 = add(_4, U256::from(0x1u128), context)?;
            let _6 = read_from_storage_split_offset_uint128(_5, context)?;
            let expr_7 = checked_sub_uint128(_6, expr_6, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(_5, expr_7, context)?;
            let expr_8 = fun__isHealthy(var_marketParams_1249_mpos, expr, var_onBehalf, context)?;
            let expr_1326_mpos = constant_INSUFFICIENT_COLLATERAL(context)?;
            require_helper_string(expr_8, expr_1326_mpos, context)?;
            let _7 = convert_bytes32_to_bytes32(expr, context)?;
            let _8 = convert_address_to_address(var_onBehalf, context)?;
            let _9 = convert_address_to_address(var_receiver, context)?;
            let _10 = allocate_unbounded(context)?;
            let _11 = abi_encode_address_uint256(_10, caller(context)?, var_assets, context)?;
            log4(_10, sub(_11, _10, context)?, U256::from_be_slice(&[0xe8, 0x0e, 0xbd, 0x7c, 0xc9, 0x22, 0x3d, 0x73, 0x82, 0xaa, 0xb2, 0xe0, 0xd1, 0xd6, 0x15, 0x5c, 0x65, 0x65, 0x1f, 0x83, 0xd5, 0x3c, 0x8b, 0x9b, 0x06, 0x90, 0x1d, 0x16, 0x7e, 0x32, 0x11, 0x42]), _7, _8, _9, context)?;
            let _12 = read_from_memoryt_address(add(var_marketParams_1249_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1343_address = convert_address_to_contract_IERC20(_12, context)?;
            fun_safeTransfer(expr_1343_address, var_receiver, var_assets, context)?;
            Ok(())
        }

        pub fn external_fun_withdrawCollateral<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3) = abi_decode_struct_MarketParamst_uint256t_addresst_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_withdrawCollateral(param, param_1, param_2, param_3, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                // switch
                let  = selector;
                if  == U256::from(0x13af4035u128) {
                    external_fun_setOwner(context)?;
                } else if  == U256::from(0x151c1adeu128) {
                    external_fun_accrueInterest(context)?;
                } else if  == U256::from(0x20b76e81u128) {
                    external_fun_repay(context)?;
                } else if  == U256::from(0x238d6579u128) {
                    external_fun_supplyCollateral(context)?;
                } else if  == U256::from(0x2b4f013cu128) {
                    external_fun_setFee(context)?;
                } else if  == U256::from(0x2c3c9157u128) {
                    external_fun_idToMarketParams(context)?;
                } else if  == U256::from(0x3644e515u128) {
                    external_fun_DOMAIN_SEPARATOR(context)?;
                } else if  == U256::from(0x46904840u128) {
                    external_fun_feeRecipient(context)?;
                } else if  == U256::from(0x4d98a93bu128) {
                    external_fun_enableLltv(context)?;
                } else if  == U256::from(0x50d8cd4bu128) {
                    external_fun_borrow(context)?;
                } else if  == U256::from(0x5a64f51eu128) {
                    external_fun_enableIrm(context)?;
                } else if  == U256::from(0x5c2bea49u128) {
                    external_fun_withdraw(context)?;
                } else if  == U256::from(0x5c60e39au128) {
                    external_fun_market(context)?;
                } else if  == U256::from(0x65e4ad9eu128) {
                    external_fun_isAuthorized(context)?;
                } else if  == U256::from(0x70ae92d2u128) {
                    external_fun_nonce(context)?;
                } else if  == U256::from(0x7784c685u128) {
                    external_fun_extSloads(context)?;
                } else if  == U256::from(0x8069218fu128) {
                    external_fun_setAuthorizationWithSig(context)?;
                } else if  == U256::from(0x8720316du128) {
                    external_fun_withdrawCollateral(context)?;
                } else if  == U256::from(0x8c1358a2u128) {
                    external_fun_createMarket(context)?;
                } else if  == U256::from(0x8da5cb5bu128) {
                    external_fun_owner(context)?;
                } else if  == U256::from(0x93c52062u128) {
                    external_fun_position(context)?;
                } else if  == U256::from(0xa99aad89u128) {
                    external_fun_supply(context)?;
                } else if  == U256::from(0xb485f3b8u128) {
                    external_fun_isLltvEnabled(context)?;
                } else if  == U256::from(0xd8eabcb8u128) {
                    external_fun_liquidate(context)?;
                } else if  == U256::from(0xe0232b42u128) {
                    external_fun_flashLoan(context)?;
                } else if  == U256::from(0xe74b981bu128) {
                    external_fun_setFeeRecipient(context)?;
                } else if  == U256::from(0xeecea000u128) {
                    external_fun_setAuthorization(context)?;
                } else if  == U256::from(0xf2b863ceu128) {
                    external_fun_isIrmEnabled(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let mut context = Context {
        contract_interactions: std::marker::PhantomData::<DummyContractInteractions>,
        memory: Memory::new(),
        immutables: std::collections::HashMap::new(),
        storage: std::collections::HashMap::new(),
        address: U256::from(123),
        caller: U256::from(124),
        callvalue: U256::from(12),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
        chain_id: U256::from(123456),
    };

    let result = morpho::morpho_deployed::fun_withdraw(
        U256::from(0),
        U256::from(1),
        U256::from(2),
        U256::from(3),
        U256::from(4),
        &mut context,
    );
    println!("result: {:#?}", result);
    println!("context: {:#?}", context);
}
