// Generated by Oxidefier

#![allow(mixed_script_confusables)]
#![allow(non_snake_case)]
#![allow(uncommon_codepoints)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod erc20 {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn array_storeLengthForEncoding_string<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut updated_pos = U256::ZERO;
        mstore(pos, length, context)?;
        updated_pos = add(pos, U256::from(0x20u128), context)?;
        Ok(updated_pos)
    }

    pub fn store_literal_in_memory_fc0b381caf0a47702017f3c4b358ebe3d3aff6c60ce819a8bf3ef5a95d4f202e<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("45524332303a206d696e7420746f20746865207a65726f206164647265737300"), context)?;
        Ok(())
    }

    pub fn abi_encode_stringliteral_fc0b381caf0a47702017f3c4b358ebe3d3aff6c60ce819a8bf3ef5a95d4f202e<CI>(mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut end_ = U256::ZERO;
        pos = array_storeLengthForEncoding_string(pos, U256::from(0x1fu128), context)?;
        store_literal_in_memory_fc0b381caf0a47702017f3c4b358ebe3d3aff6c60ce819a8bf3ef5a95d4f202e(pos, context)?;
        end_ = add(pos, U256::from(0x20u128), context)?;
        Ok(end_)
    }

    pub fn abi_encode_stringliteral_fc0b<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut tail = U256::ZERO;
        tail = add(headStart, U256::from(0x20u128), context)?;
        mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
        tail = abi_encode_stringliteral_fc0b381caf0a47702017f3c4b358ebe3d3aff6c60ce819a8bf3ef5a95d4f202e(tail, context)?;
        Ok(tail)
    }

    pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn abi_encode_uint256_to_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(pos, cleanup_uint256(value, context)?, context)?;
        Ok(())
    }

    pub fn abi_encode_uint256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut tail = U256::ZERO;
        tail = add(headStart, U256::from(0x20u128), context)?;
        abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
        Ok(tail)
    }

    pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn panic_error_0x11<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
        mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
        revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
        Ok(())
    }

    pub fn checked_add_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut sum = U256::ZERO;
        x = cleanup_uint256(x, context)?;
        y = cleanup_uint256(y, context)?;
        sum = add(x, y, context)?;
        if gt(x, sum, context)? != U256::ZERO {
            panic_error_0x11(context)?;
        }
        Ok(sum)
    }

    pub fn cleanup_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
        Ok(cleaned)
    }

    pub fn cleanup_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = cleanup_uint160(value, context)?;
        Ok(cleaned)
    }

    pub fn cleanup_from_storage_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn cleanup_t_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn convert_rational_by_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn convert_uint160_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint160(identity(cleanup_uint160(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn convert_uint160_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_uint160(value, context)?;
        Ok(converted)
    }

    pub fn convert_address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_address(value, context)?;
        Ok(converted)
    }

    pub fn convert_rational_by_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint160(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn convert_rational_by_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_rational_by_to_uint160(value, context)?;
        Ok(converted)
    }

    pub fn mapping_index_access_mapping_address_uint256_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut dataSlot = U256::ZERO;
        mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
        mstore(U256::from(0x20u128), slot, context)?;
        dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
        Ok(dataSlot)
    }

    pub fn shift_right_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shr(U256::from(0x0u128), value, context)?;
        Ok(newValue)
    }

    pub fn extract_from_storage_value_offset_uint256<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value = U256::ZERO;
        value = cleanup_from_storage_uint256(shift_right_unsigned(slot_value, context)?, context)?;
        Ok(value)
    }

    pub fn read_from_storage_split_offset_uint256<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value = U256::ZERO;
        value = extract_from_storage_value_offset_uint256(sload(slot, context)?, context)?;
        Ok(value)
    }

    pub fn require_helper_stringliteral_fc0b<CI>(condition: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if iszero(condition, context)? != U256::ZERO {
            let memPtr = allocate_unbounded(context)?;
            mstore(memPtr, shl(U256::from(0xe5u128), U256::from(0x461bcdu128), context)?, context)?;
            let end_ = abi_encode_stringliteral_fc0b(add(memPtr, U256::from(0x4u128), context)?, context)?;
            revert(memPtr, sub(end_, memPtr, context)?, context)?;
        }
        Ok(())
    }

    pub fn convert_uint256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn prepare_store_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn shift_left<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shl(U256::from(0x0u128), value, context)?;
        Ok(newValue)
    }

    pub fn update_byte_slice_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let mask = not(U256::from(0x0u128), context)?;
        toInsert = shift_left(toInsert, context)?;
        value = and(value, not(mask, context)?, context)?;
        result = or(value, and(toInsert, mask, context)?, context)?;
        Ok(result)
    }

    pub fn update_storage_value_offset_uint256_to_uint256<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let convertedValue = convert_uint256_to_uint256(value, context)?;
        sstore(slot, update_byte_slice_shift(sload(slot, context)?, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
        Ok(())
    }

    pub fn fun_mint<CI>(var_account: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
        let expr_1 = iszero(eq(cleanup_address(var_account, context)?, cleanup_address(expr, context)?, context)?, context)?;
        require_helper_stringliteral_fc0b(expr_1, context)?;
        let _1 = read_from_storage_split_offset_uint256(U256::from(0x2u128), context)?;
        let expr_2 = checked_add_uint256(_1, var_value, context)?;
        update_storage_value_offset_uint256_to_uint256(U256::from(0x2u128), expr_2, context)?;
        let _2 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_account, context)?;
        let _3 = read_from_storage_split_offset_uint256(_2, context)?;
        let expr_3 = checked_add_uint256(_3, var_value, context)?;
        let _4 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_account, context)?;
        update_storage_value_offset_uint256_to_uint256(_4, expr_3, context)?;
        let _5 = convert_address_to_address(expr, context)?;
        let _6 = convert_address_to_address(var_account, context)?;
        let _7 = allocate_unbounded(context)?;
        let _8 = abi_encode_uint256(_7, var_value, context)?;
        log3(_7, sub(_8, _7, context)?, U256::from_be_slice(&[0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b, 0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa, 0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16, 0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef]), _5, _6, context)?;
        Ok(())
    }

    pub fn constructor_ERC20<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let _1 = convert_rational_by_to_uint256(U256::from(0x14u128), context)?;
        fun_mint(caller(context)?, _1, context)?;
        Ok(())
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        constructor_ERC20(context)?;
        let _1 = allocate_unbounded(context)?;
        codecopy(_1, dataoffset(from_hex("45524332305f3430335f6465706c6f7965640000000000000000000000000000"), context)?, datasize(from_hex("45524332305f3430335f6465706c6f7965640000000000000000000000000000"), context)?, context)?;
        return_(_1, datasize(from_hex("45524332305f3430335f6465706c6f7965640000000000000000000000000000"), context)?, context)?;
        Ok(())
    }

    pub mod erc20_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            Ok(())
        }

        pub fn cleanup_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = cleanup_uint160(value, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_address(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_address<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_address(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_addresst_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_addresst_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_tuple_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn cleanup_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = iszero(iszero(value, context)?, context)?;
            Ok(cleaned)
        }

        pub fn abi_encode_bool_to_bool<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bool<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bool_to_bool(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_storeLengthForEncoding_string<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn store_literal_in_memory_0557e210f7a69a685100a7e4e3d0a7024c546085cee28910fd17d0b081d9516f<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("45524332303a207472616e7366657220746f20746865207a65726f2061646472"), context)?;
            mstore(add(memPtr, U256::from(0x20u128), context)?, from_hex("6573730000000000000000000000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn abi_encode_stringliteral_0557<CI>(mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = array_storeLengthForEncoding_string(pos, U256::from(0x23u128), context)?;
            store_literal_in_memory_0557e210f7a69a685100a7e4e3d0a7024c546085cee28910fd17d0b081d9516f(pos, context)?;
            end_ = add(pos, U256::from(0x40u128), context)?;
            Ok(end_)
        }

        pub fn store_literal_in_memory_24883cc5fe64ace9d0df1893501ecb93c77180f0ff69cca79affb3c316dc8029<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("45524332303a20617070726f766520746f20746865207a65726f206164647265"), context)?;
            mstore(add(memPtr, U256::from(0x20u128), context)?, from_hex("7373000000000000000000000000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn abi_encode_stringliteral_24883cc5fe64ace9d0df1893501ecb93c77180f0ff69cca79affb3c316dc8029<CI>(mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = array_storeLengthForEncoding_string(pos, U256::from(0x22u128), context)?;
            store_literal_in_memory_24883cc5fe64ace9d0df1893501ecb93c77180f0ff69cca79affb3c316dc8029(pos, context)?;
            end_ = add(pos, U256::from(0x40u128), context)?;
            Ok(end_)
        }

        pub fn abi_encode_stringliteral_2488<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_stringliteral_24883cc5fe64ace9d0df1893501ecb93c77180f0ff69cca79affb3c316dc8029(tail, context)?;
            Ok(tail)
        }

        pub fn store_literal_in_memory_c953f4879035ed60e766b34720f656aab5c697b141d924c283124ecedb91c208<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("45524332303a20617070726f76652066726f6d20746865207a65726f20616464"), context)?;
            mstore(add(memPtr, U256::from(0x20u128), context)?, from_hex("7265737300000000000000000000000000000000000000000000000000000000"), context)?;
            Ok(())
        }

        pub fn abi_encode_stringliteral_c953f4879035ed60e766b34720f656aab5c697b141d924c283124ecedb91c208<CI>(mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = array_storeLengthForEncoding_string(pos, U256::from(0x24u128), context)?;
            store_literal_in_memory_c953f4879035ed60e766b34720f656aab5c697b141d924c283124ecedb91c208(pos, context)?;
            end_ = add(pos, U256::from(0x40u128), context)?;
            Ok(end_)
        }

        pub fn abi_encode_stringliteral_c953<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_stringliteral_c953f4879035ed60e766b34720f656aab5c697b141d924c283124ecedb91c208(tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_stringliteral_0557<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_stringliteral_0557(tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_to_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x11<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_add_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            sum = add(x, y, context)?;
            if gt(x, sum, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn checked_sub_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            diff = sub(x, y, context)?;
            if gt(diff, x, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(diff)
        }

        pub fn cleanup_from_storage_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_uint160_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_uint160(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_rational_by_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn mapping_index_access_mapping_address_mapping_address_uint256__of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_address_uint256_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn shift_right_0_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_uint256<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint256(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_uint256<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_uint256(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_allowance<CI>(var_owner: U256, var_spender: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_ = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_ = zero_uint256;
            let _1 = mapping_index_access_mapping_address_mapping_address_uint256__of_address(U256::from(0x1u128), var_owner, context)?;
            let _2 = mapping_index_access_mapping_address_uint256_of_address(_1, var_spender, context)?;
            let _3 = read_from_storage_split_offset_uint256(_2, context)?;
            var_ = _3;
            Ok(var_)
        }

        pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn external_fun_allowance<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_allowance(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn require_helper_stringliteral_2488<CI>(condition: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(condition, context)? != U256::ZERO {
                let memPtr = allocate_unbounded(context)?;
                mstore(memPtr, shl(U256::from(0xe5u128), U256::from(0x461bcdu128), context)?, context)?;
                let end_ = abi_encode_stringliteral_2488(add(memPtr, U256::from(0x4u128), context)?, context)?;
                revert(memPtr, sub(end_, memPtr, context)?, context)?;
            }
            Ok(())
        }

        pub fn require_helper_stringliteral_c953<CI>(condition: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(condition, context)? != U256::ZERO {
                let memPtr = allocate_unbounded(context)?;
                mstore(memPtr, shl(U256::from(0xe5u128), U256::from(0x461bcdu128), context)?, context)?;
                let end_ = abi_encode_stringliteral_c953(add(memPtr, U256::from(0x4u128), context)?, context)?;
                revert(memPtr, sub(end_, memPtr, context)?, context)?;
            }
            Ok(())
        }

        pub fn prepare_store_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = not(U256::from(0x0u128), context)?;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_uint256_to_uint256<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint256_to_uint256(value, context)?;
            sstore(slot, update_byte_slice_shift(sload(slot, context)?, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn fun__approve<CI>(var_owner: U256, var_spender: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = iszero(eq(cleanup_address(var_owner, context)?, cleanup_address(expr, context)?, context)?, context)?;
            require_helper_stringliteral_c953(expr_1, context)?;
            let expr_2 = iszero(eq(cleanup_address(var_spender, context)?, cleanup_address(expr, context)?, context)?, context)?;
            require_helper_stringliteral_2488(expr_2, context)?;
            let _1 = mapping_index_access_mapping_address_mapping_address_uint256__of_address(U256::from(0x1u128), var_owner, context)?;
            let _2 = mapping_index_access_mapping_address_uint256_of_address(_1, var_spender, context)?;
            update_storage_value_offset_uint256_to_uint256(_2, var_value, context)?;
            let _3 = convert_address_to_address(var_owner, context)?;
            let _4 = convert_address_to_address(var_spender, context)?;
            let _5 = allocate_unbounded(context)?;
            let _6 = abi_encode_uint256(_5, var_value, context)?;
            log3(_5, sub(_6, _5, context)?, U256::from_be_slice(&[0x8c, 0x5b, 0xe1, 0xe5, 0xeb, 0xec, 0x7d, 0x5b, 0xd1, 0x4f, 0x71, 0x42, 0x7d, 0x1e, 0x84, 0xf3, 0xdd, 0x03, 0x14, 0xc0, 0xf7, 0xb2, 0x29, 0x1e, 0x5b, 0x20, 0x0a, 0xc8, 0xc7, 0xc3, 0xb9, 0x25]), _3, _4, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_bool<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_approve<CI>(var_spender: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            fun__approve(caller(context)?, var_spender, var_value, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_approve<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_approve(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_balanceOf<CI>(var_owner: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_t_uint256;
            let _1 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_owner, context)?;
            let _2 = read_from_storage_split_offset_uint256(_1, context)?;
            var = _2;
            Ok(var)
        }

        pub fn external_fun_balanceOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_balanceOf(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_decreaseAllowance<CI>(var_spender: U256, var_subtractedValue: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let _1 = mapping_index_access_mapping_address_mapping_address_uint256__of_address(U256::from(0x1u128), caller(context)?, context)?;
            let _2 = mapping_index_access_mapping_address_uint256_of_address(_1, var_spender, context)?;
            let _3 = read_from_storage_split_offset_uint256(_2, context)?;
            let expr = checked_sub_uint256(_3, var_subtractedValue, context)?;
            fun__approve(caller(context)?, var_spender, expr, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_decreaseAllowance<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_decreaseAllowance(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_increaseAllowance<CI>(var_spender: U256, var_addedValue: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_bool = zero_value_for_split_bool(context)?;
            var = zero_t_bool;
            let _1 = mapping_index_access_mapping_address_mapping_address_uint256__of_address(U256::from(0x1u128), caller(context)?, context)?;
            let _2 = mapping_index_access_mapping_address_uint256_of_address(_1, var_spender, context)?;
            let _3 = read_from_storage_split_offset_uint256(_2, context)?;
            let expr = checked_add_uint256(_3, var_addedValue, context)?;
            fun__approve(caller(context)?, var_spender, expr, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_increaseAllowance<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_increaseAllowance(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_totalSupply<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let _1 = read_from_storage_split_offset_uint256(U256::from(0x2u128), context)?;
            var = _1;
            Ok(var)
        }

        pub fn external_fun_totalSupply<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_totalSupply(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn require_helper_stringliteral_0557<CI>(condition: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(condition, context)? != U256::ZERO {
                let memPtr = allocate_unbounded(context)?;
                mstore(memPtr, shl(U256::from(0xe5u128), U256::from(0x461bcdu128), context)?, context)?;
                let end_ = abi_encode_tuple_stringliteral_0557(add(memPtr, U256::from(0x4u128), context)?, context)?;
                revert(memPtr, sub(end_, memPtr, context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_transfer<CI>(var_from: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = iszero(eq(cleanup_address(var_to, context)?, cleanup_address(expr, context)?, context)?, context)?;
            require_helper_stringliteral_0557(expr_1, context)?;
            let _1 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_from, context)?;
            let _2 = read_from_storage_split_offset_uint256(_1, context)?;
            let expr_2 = checked_sub_uint256(_2, var_value, context)?;
            let _3 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_from, context)?;
            update_storage_value_offset_uint256_to_uint256(_3, expr_2, context)?;
            let _4 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_to, context)?;
            let _5 = read_from_storage_split_offset_uint256(_4, context)?;
            let expr_3 = checked_add_uint256(_5, var_value, context)?;
            let _6 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_to, context)?;
            update_storage_value_offset_uint256_to_uint256(_6, expr_3, context)?;
            let _7 = convert_address_to_address(var_from, context)?;
            let _8 = convert_address_to_address(var_to, context)?;
            let _9 = allocate_unbounded(context)?;
            let _10 = abi_encode_uint256(_9, var_value, context)?;
            log3(_9, sub(_10, _9, context)?, U256::from_be_slice(&[0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b, 0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa, 0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16, 0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef]), _7, _8, context)?;
            Ok(())
        }

        pub fn fun_transfer_94<CI>(var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            fun_transfer(caller(context)?, var_to, var_value, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_transfer<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_transfer_94(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_transferFrom<CI>(var_from: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            fun_transfer(var_from, var_to, var_value, context)?;
            let _1 = mapping_index_access_mapping_address_mapping_address_uint256__of_address(U256::from(0x1u128), var_from, context)?;
            let _2 = mapping_index_access_mapping_address_uint256_of_address(_1, caller(context)?, context)?;
            let _3 = read_from_storage_split_offset_uint256(_2, context)?;
            let expr = checked_sub_uint256(_3, var_value, context)?;
            fun__approve(var_from, caller(context)?, expr, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_transferFrom<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2) = abi_decode_addresst_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_transferFrom(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                // switch
                let  = selector;
                if  == U256::from(0x95ea7b3u128) {
                    external_fun_approve(context)?;
                } else if  == U256::from(0x18160dddu128) {
                    external_fun_totalSupply(context)?;
                } else if  == U256::from(0x23b872ddu128) {
                    external_fun_transferFrom(context)?;
                } else if  == U256::from(0x39509351u128) {
                    external_fun_increaseAllowance(context)?;
                } else if  == U256::from(0x70a08231u128) {
                    external_fun_balanceOf(context)?;
                } else if  == U256::from(0xa457c2d7u128) {
                    external_fun_decreaseAllowance(context)?;
                } else if  == U256::from(0xa9059cbbu128) {
                    external_fun_transfer(context)?;
                } else if  == U256::from(0xdd62ed3eu128) {
                    external_fun_allowance(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let context = Context {
        contract_interactions: std::marker::PhantomData::<DummyContractInteractions>,
        memory: Memory::new(),
        immutables: std::collections::HashMap::new(),
        storage: std::collections::HashMap::new(),
        address: U256::from(123),
        caller: U256::from(124),
        callvalue: U256::from(12),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
        chain_id: U256::from(123456),
    };

    // let result = exp_unit_test::exp_unit_test_deployed::fun_test_Exp(&mut context);
    // println!("result: {:#?}", result);
    // println!("context: {:#?}", context);
}
