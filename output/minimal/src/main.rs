// Generated by Oxidefier

#![allow(mixed_script_confusables)]
#![allow(non_snake_case)]
#![allow(uncommon_codepoints)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod minimal {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let _1 = allocate_unbounded(context)?;
        codecopy(_1, dataoffset(from_hex("4d696e696d616c5f31345f6465706c6f79656400000000000000000000000000"), context)?, datasize(from_hex("4d696e696d616c5f31345f6465706c6f79656400000000000000000000000000"), context)?, context)?;
        return_(_1, datasize(from_hex("4d696e696d616c5f31345f6465706c6f79656400000000000000000000000000"), context)?, context)?;
        Ok(())
    }

    pub mod minimal_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_tuple_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_encode_uint256_to_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x11<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_add_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            sum = add(x, y, context)?;
            if gt(x, sum, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_rational_by_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_add_one<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = checked_add_uint256(var_x, convert_rational_by_to_uint256(U256::from(0x1u128), context)?, context)?;
            var = expr;
            Ok(var)
        }

        pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn external_fun_add_one<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_add_one(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                if eq(U256::from(0xdde38a34u128), selector, context)? != U256::ZERO {
                    external_fun_add_one(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let mut context = Context {
        contract_interactions: std::marker::PhantomData::<DummyContractInteractions>,
        memory: Memory::new(),
        immutables: std::collections::HashMap::new(),
        storage: std::collections::HashMap::new(),
        address: U256::from(123),
        caller: U256::from(124),
        callvalue: U256::from(12),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
        chain_id: U256::from(123456),
    };

    // let result = exp_unit_test::exp_unit_test_deployed::fun_test_Exp(&mut context);
    // println!("result: {:#?}", result);
    // println!("context: {:#?}", context);
}
