// Generated by Oxidefier

#![allow(mixed_script_confusables)]
#![allow(non_snake_case)]
#![allow(uncommon_codepoints)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod testopcodes {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let _1 = allocate_unbounded(context)?;
        codecopy(_1, dataoffset(from_hex("546573744f70636f6465735f3638345f6465706c6f7965640000000000000000"), context)?, datasize(from_hex("546573744f70636f6465735f3638345f6465706c6f7965640000000000000000"), context)?, context)?;
        return_(_1, datasize(from_hex("546573744f70636f6465735f3638345f6465706c6f7965640000000000000000"), context)?, context)?;
        Ok(())
    }

    pub mod testopcodes_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            Ok(())
        }

        pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x41<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn round_up_to_mul_of<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
            Ok(result)
        }

        pub fn finalize_allocation<CI>(memPtr: U256, size: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
            if or(gt(newFreePtr, U256::from(0xffffffffffffffffu128), context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            mstore(U256::from(0x40u128), newFreePtr, context)?;
            Ok(())
        }

        pub fn allocate_memory<CI>(size: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            finalize_allocation(memPtr, size, context)?;
            Ok(memPtr)
        }

        pub fn array_allocation_size_bytes<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = round_up_to_mul_of(length, context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn copy_calldata_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            calldatacopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_bytes<CI>(src: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_bytes(length, context)?, context)?;
            mstore(array, length, context)?;
            if gt(add(src, length, context)?, end_, context)? != U256::ZERO {
                revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(context)?;
            }
            copy_calldata_to_memory_with_cleanup(src, add(array, U256::from(0x20u128), context)?, length, context)?;
            Ok(array)
        }

        pub fn revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_bytes_memory_ptr<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_bytes(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_bytes<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_bytes_memory_ptr(add(headStart, offset, context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn cleanup_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_int256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_int256<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_int256(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_int256t_int256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_int256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_int256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_tuple_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_uint256t_int256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_int256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_uint256t_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_uint256t_uint256t_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn cleanup_bytes32<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn abi_encode_bytes32_to_bytes32<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bytes32(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bytes32<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bytes32_to_bytes32(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_int256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_int256(value, context)?, context)?;
            Ok(())
        }

        pub fn cleanup_rational_4660_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_uint16<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffu128), context)?;
            Ok(cleaned)
        }

        pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_rational_by_to_uint16<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint16(identity(cleanup_rational_4660_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_rational_by_to_uint16<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_rational_by_to_uint16(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_rational_by<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_rational_by_to_uint16(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x0u128), context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_int256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_int256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_to_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_dataslot_bytes<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_bytes<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn panic_error_0x01<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x1u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn assert_helper<CI>(condition: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(condition, context)? != U256::ZERO {
                panic_error_0x01(context)?;
            }
            Ok(())
        }

        pub fn cleanup_rational_0_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_115792089237316195423570985008687907853269984665640564039457584007913129639808_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_128_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_3_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_63_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_6_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_7_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_minus_3_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_minus_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_minus_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_minus_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_minus_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn convert_rational_0_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_0_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_115792089237316195423570985008687907853269984665640564039457584007913129639808_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_115792089237316195423570985008687907853269984665640564039457584007913129639808_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_127_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_128_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_128_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_32_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_3_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_3_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_3_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_3_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4660_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4660_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_7_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_7_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_2_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_63_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_minus_3_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_minus_3_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_minus_4_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_minus_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_minus_7_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_minus_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_minus_by_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_t_rational_minus_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_6_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_minus_by_to_t_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_t_rational_minus_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_testAdd<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = add(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testAddmod<CI>(var_x: U256, var_y: U256, var_z: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = addmod(var_x, var_y, var_z, context)?;
            Ok(var_result)
        }

        pub fn fun_testAnd<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = and(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testByte<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = byte(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testCalldatasize<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = calldatasize(context)?;
            Ok(var_result)
        }

        pub fn fun_testDiv<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = div(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testEq<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = eq(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testExp<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = exp(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testGas<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = gas(context)?;
            Ok(var_result)
        }

        pub fn fun_testGt<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = gt(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testIszero<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = iszero(var_x, context)?;
            Ok(var_result)
        }

        pub fn zero_value_for_split_bytes32<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_testKeccak256<CI>(var_data_mpos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bytes32 = zero_value_for_split_bytes32(context)?;
            var_result = zero_bytes32;
            var_result = keccak256(add(var_data_mpos, U256::from(0x20u128), context)?, mload(var_data_mpos, context)?, context)?;
            Ok(var_result)
        }

        pub fn fun_testLt<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = lt(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testMload<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = mload(var_x, context)?;
            Ok(var_result)
        }

        pub fn fun_testMod<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = mod_(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testMstore<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(var_x, var_y, context)?;
            Ok(())
        }

        pub fn fun_testMstore8<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore8(var_x, var_y, context)?;
            Ok(())
        }

        pub fn fun_testMul<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = mul(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testMulmod<CI>(var_x: U256, var_y: U256, var_z: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = mulmod(var_x, var_y, var_z, context)?;
            Ok(var_result)
        }

        pub fn fun_testNot<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = not(var_x, context)?;
            Ok(var_result)
        }

        pub fn fun_testOr<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = or(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn zero_value_for_split_int256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_testSar<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_t_int256 = zero_value_for_split_int256(context)?;
            var_result = zero_t_int256;
            var_result = sar(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testSdiv<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_int256 = zero_value_for_split_int256(context)?;
            var_result = zero_int256;
            var_result = sdiv(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testSgt<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = sgt(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testShl<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = shl(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testShr<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = shr(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testSignextend<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = signextend(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testSlt<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = slt(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testSmod<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_int256 = zero_value_for_split_int256(context)?;
            var_result = zero_int256;
            var_result = smod(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testSub<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_t_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_t_uint256;
            var_result = sub(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_testXor<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = xor(var_x, var_y, context)?;
            Ok(var_result)
        }

        pub fn fun_runTests<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            let expr = fun_testAdd(_1, _1, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, _1, context)?;
            assert_helper(expr_1, context)?;
            let expr_2 = U256::from(0x1u128);
            let expr_3 = U256::from(0x2u128);
            let _2 = convert_rational_1_by_1_to_uint256(expr_2, context)?;
            let _3 = convert_rational_2_by_1_to_uint256(expr_3, context)?;
            let expr_4 = fun_testAdd(_2, _3, context)?;
            let expr_5 = U256::from(0x3u128);
            let expr_6 = eq(cleanup_uint256(expr_4, context)?, convert_rational_3_by_1_to_uint256(expr_5, context)?, context)?;
            assert_helper(expr_6, context)?;
            let expr_7 = fun_testSub(_1, _1, context)?;
            let expr_8 = eq(cleanup_uint256(expr_7, context)?, _1, context)?;
            assert_helper(expr_8, context)?;
            let expr_9 = fun_testSub(_3, _2, context)?;
            let expr_10 = eq(cleanup_uint256(expr_9, context)?, _2, context)?;
            assert_helper(expr_10, context)?;
            let _4 = convert_rational_3_by_1_to_uint256(expr_5, context)?;
            let expr_11 = fun_testMul(_3, _4, context)?;
            let expr_12 = eq(cleanup_uint256(expr_11, context)?, convert_t_rational_by_to_t_uint256(U256::from(0x6u128), context)?, context)?;
            assert_helper(expr_12, context)?;
            let _5 = convert_t_rational_by_to_t_uint256(U256::from(0x6u128), context)?;
            let expr_13 = fun_testDiv(_5, _3, context)?;
            let expr_14 = eq(cleanup_uint256(expr_13, context)?, _4, context)?;
            assert_helper(expr_14, context)?;
            let _6 = convert_t_rational_minus_by_to_t_int256(not(U256::from(0x5u128), context)?, context)?;
            let _7 = convert_rational_by_to_int256(expr_3, context)?;
            let expr_15 = fun_testSdiv(_6, _7, context)?;
            let expr_16 = eq(cleanup_int256(expr_15, context)?, convert_rational_minus_3_by_1_to_int256(not(U256::from(0x2u128), context)?, context)?, context)?;
            assert_helper(expr_16, context)?;
            let _8 = convert_rational_7_by_1_to_uint256(U256::from(0x7u128), context)?;
            let expr_17 = fun_testMod(_8, _4, context)?;
            let expr_18 = eq(cleanup_uint256(expr_17, context)?, _2, context)?;
            assert_helper(expr_18, context)?;
            let _9 = convert_rational_minus_7_by_1_to_int256(not(U256::from(0x6u128), context)?, context)?;
            let _10 = convert_rational_3_by_1_to_int256(expr_5, context)?;
            let expr_19 = fun_testSmod(_9, _10, context)?;
            let expr_20 = not(U256::from(0x0u128), context)?;
            let expr_21 = eq(cleanup_int256(expr_19, context)?, convert_rational_minus_by_to_int256(expr_20, context)?, context)?;
            assert_helper(expr_21, context)?;
            let expr_22 = fun_testExp(_3, _4, context)?;
            let expr_23 = eq(cleanup_uint256(expr_22, context)?, convert_rational_8_by_1_to_uint256(U256::from(0x8u128), context)?, context)?;
            assert_helper(expr_23, context)?;
            let expr_24 = fun_testNot(_1, context)?;
            let expr_25 = eq(cleanup_uint256(expr_24, context)?, cleanup_uint256(expr_20, context)?, context)?;
            assert_helper(expr_25, context)?;
            let expr_26 = fun_testLt(_2, _3, context)?;
            let expr_27 = eq(cleanup_uint256(expr_26, context)?, _2, context)?;
            assert_helper(expr_27, context)?;
            let expr_28 = fun_testGt(_3, _2, context)?;
            let expr_29 = eq(cleanup_uint256(expr_28, context)?, _2, context)?;
            assert_helper(expr_29, context)?;
            let _11 = convert_rational_minus_by_to_int256(expr_20, context)?;
            let _12 = convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?;
            let expr_30 = fun_testSlt(_11, _12, context)?;
            let expr_31 = eq(cleanup_uint256(expr_30, context)?, _2, context)?;
            assert_helper(expr_31, context)?;
            let _13 = convert_t_rational_by_to_t_int256(expr_2, context)?;
            let expr_32 = fun_testSgt(_13, _11, context)?;
            let expr_33 = eq(cleanup_uint256(expr_32, context)?, _2, context)?;
            assert_helper(expr_33, context)?;
            let expr_34 = fun_testEq(_2, _2, context)?;
            let expr_35 = eq(cleanup_uint256(expr_34, context)?, _2, context)?;
            assert_helper(expr_35, context)?;
            let expr_36 = fun_testIszero(_1, context)?;
            let expr_37 = eq(cleanup_uint256(expr_36, context)?, _2, context)?;
            assert_helper(expr_37, context)?;
            let expr_38 = fun_testAnd(_4, _3, context)?;
            let expr_39 = eq(cleanup_uint256(expr_38, context)?, _3, context)?;
            assert_helper(expr_39, context)?;
            let expr_40 = fun_testOr(_2, _3, context)?;
            let expr_41 = eq(cleanup_uint256(expr_40, context)?, _4, context)?;
            assert_helper(expr_41, context)?;
            let expr_42 = fun_testXor(_4, _2, context)?;
            let expr_43 = eq(cleanup_uint256(expr_42, context)?, _3, context)?;
            assert_helper(expr_43, context)?;
            let expr_44 = U256::from(0x1234u128);
            let _14 = convert_rational_4660_by_1_to_uint256(expr_44, context)?;
            let expr_45 = fun_testByte(_1, _14, context)?;
            let expr_46 = eq(cleanup_uint256(expr_45, context)?, _1, context)?;
            assert_helper(expr_46, context)?;
            let expr_47 = fun_testShl(_3, _2, context)?;
            let expr_48 = eq(cleanup_uint256(expr_47, context)?, convert_rational_4_by_1_to_uint256(U256::from(0x4u128), context)?, context)?;
            assert_helper(expr_48, context)?;
            let _15 = convert_rational_4_by_1_to_uint256(U256::from(0x4u128), context)?;
            let expr_49 = fun_testShr(_3, _15, context)?;
            let expr_50 = eq(cleanup_uint256(expr_49, context)?, _2, context)?;
            assert_helper(expr_50, context)?;
            let _16 = convert_rational_minus_4_by_1_to_int256(not(U256::from(0x3u128), context)?, context)?;
            let expr_51 = fun_testSar(_3, _16, context)?;
            let expr_52 = eq(cleanup_int256(expr_51, context)?, _11, context)?;
            assert_helper(expr_52, context)?;
            let expr_53 = fun_testAddmod(_3, _4, _15, context)?;
            let expr_54 = eq(cleanup_uint256(expr_53, context)?, _2, context)?;
            assert_helper(expr_54, context)?;
            let expr_55 = fun_testMulmod(_3, _4, _15, context)?;
            let expr_56 = eq(cleanup_uint256(expr_55, context)?, _3, context)?;
            assert_helper(expr_56, context)?;
            let _17 = convert_rational_127_by_1_to_uint256(U256::from(0x7fu128), context)?;
            let expr_57 = fun_testSignextend(_1, _17, context)?;
            let expr_58 = eq(cleanup_uint256(expr_57, context)?, _17, context)?;
            assert_helper(expr_58, context)?;
            let _18 = convert_rational_128_by_1_to_uint256(U256::from(0x80u128), context)?;
            let expr_59 = fun_testSignextend(_1, _18, context)?;
            let expr_60 = eq(cleanup_uint256(expr_59, context)?, convert_rational_115792089237316195423570985008687907853269984665640564039457584007913129639808_by_1_to_uint256(not(U256::from(0x7fu128), context)?, context)?, context)?;
            assert_helper(expr_60, context)?;
            let expr_mpos = allocate_unbounded(context)?;
            let _19 = add(expr_mpos, U256::from(0x20u128), context)?;
            let _20 = abi_encode_rational_by(_19, expr_44, context)?;
            mstore(expr_mpos, sub(_20, _19, context)?, context)?;
            finalize_allocation(expr_mpos, sub(_20, expr_mpos, context)?, context)?;
            let expr_61 = fun_testKeccak256(expr_mpos, context)?;
            let expr_631_mpos = allocate_unbounded(context)?;
            let _21 = add(expr_631_mpos, U256::from(0x20u128), context)?;
            let _22 = abi_encode_rational_by(_21, expr_44, context)?;
            mstore(expr_631_mpos, sub(_22, _21, context)?, context)?;
            finalize_allocation(expr_631_mpos, sub(_22, expr_631_mpos, context)?, context)?;
            let expr_62 = keccak256(array_dataslot_bytes(expr_631_mpos, context)?, array_length_bytes(expr_631_mpos, context)?, context)?;
            let expr_63 = eq(cleanup_bytes32(expr_61, context)?, cleanup_bytes32(expr_62, context)?, context)?;
            assert_helper(expr_63, context)?;
            fun_testMstore(_1, _14, context)?;
            let expr_64 = fun_testMload(_1, context)?;
            let expr_65 = eq(cleanup_uint256(expr_64, context)?, _14, context)?;
            assert_helper(expr_65, context)?;
            let _23 = convert_rational_by_to_uint256(U256::from(0x3fu128), context)?;
            let _24 = convert_rational_18_by_1_to_uint256(U256::from(0x12u128), context)?;
            fun_testMstore8(_23, _24, context)?;
            let _25 = convert_rational_32_by_1_to_uint256(U256::from(0x20u128), context)?;
            let expr_66 = fun_testMload(_25, context)?;
            let expr_67 = eq(cleanup_uint256(expr_66, context)?, _24, context)?;
            assert_helper(expr_67, context)?;
            let expr_68 = fun_testGas(context)?;
            let expr_69 = gt(cleanup_uint256(expr_68, context)?, _1, context)?;
            assert_helper(expr_69, context)?;
            let expr_70 = fun_testCalldatasize(context)?;
            let expr_71 = eq(cleanup_uint256(expr_70, context)?, _1, context)?;
            assert_helper(expr_71, context)?;
            Ok(())
        }

        pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn external_fun_runTests<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_runTests(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testAdd<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testAdd(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testAddmod<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2) = abi_decode_uint256t_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testAddmod(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testAnd<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testAnd(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testByte<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testByte(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_testCalldatacopy<CI>(var_t: U256, var_f: U256, var_s: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            calldatacopy(var_t, var_f, var_s, context)?;
            Ok(())
        }

        pub fn external_fun_testCalldatacopy<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2) = abi_decode_uint256t_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_testCalldatacopy(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_testCalldataload<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            var_result = calldataload(var_x, context)?;
            Ok(var_result)
        }

        pub fn external_fun_testCalldataload<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testCalldataload(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testCalldatasize<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testCalldatasize(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testDiv<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testDiv(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testEq<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testEq(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testExp<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testExp(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testGas<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testGas(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testGt<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testGt(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testIszero<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testIszero(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testKeccak256<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_bytes(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testKeccak256(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bytes32(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testLt<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testLt(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testMload<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testMload(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testMod<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testMod(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testMstore<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_testMstore(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testMstore8<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_testMstore8(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testMul<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testMul(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testMulmod<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2) = abi_decode_uint256t_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testMulmod(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testNot<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testNot(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testOr<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testOr(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testPop<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            pop(abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testSar<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_int256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testSar(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_int256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testSdiv<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_int256t_int256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testSdiv(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_int256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testSgt<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_int256t_int256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testSgt(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testShl<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testShl(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testShr<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testShr(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testSignextend<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testSignextend(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testSlt<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_int256t_int256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testSlt(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testSmod<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_int256t_int256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testSmod(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_int256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testSub<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testSub(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_testXor<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_uint256t_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_testXor(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x40u128), U256::from(0x80u128), context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                // switch
                let  = selector;
                if  == U256::from(0x4037b50u128) {
                    external_fun_testMod(context)?;
                } else if  == U256::from(0x1599feefu128) {
                    external_fun_testSgt(context)?;
                } else if  == U256::from(0x20e86ef0u128) {
                    external_fun_testExp(context)?;
                } else if  == U256::from(0x22142229u128) {
                    external_fun_testNot(context)?;
                } else if  == U256::from(0x23d74628u128) {
                    external_fun_runTests(context)?;
                } else if  == U256::from(0x2679e1a6u128) {
                    external_fun_testGt(context)?;
                } else if  == U256::from(0x2736cb7au128) {
                    external_fun_testMload(context)?;
                } else if  == U256::from(0x287be169u128) {
                    external_fun_testOr(context)?;
                } else if  == U256::from(0x2d05c232u128) {
                    external_fun_testSar(context)?;
                } else if  == U256::from(0x3b3a7e31u128) {
                    external_fun_testDiv(context)?;
                } else if  == U256::from(0x4042e866u128) {
                    external_fun_testSmod(context)?;
                } else if  == U256::from(0x4076d69au128) {
                    external_fun_testCalldatacopy(context)?;
                } else if  == U256::from(0x42c63801u128) {
                    external_fun_testShl(context)?;
                } else if  == U256::from(0x459a065au128) {
                    external_fun_testEq(context)?;
                } else if  == U256::from(0x49b2cc61u128) {
                    external_fun_testMstore(context)?;
                } else if  == U256::from(0x4a6661ffu128) {
                    external_fun_testGas(context)?;
                } else if  == U256::from(0x4bb77da7u128) {
                    external_fun_testSlt(context)?;
                } else if  == U256::from(0x6e8e4a48u128) {
                    external_fun_testByte(context)?;
                } else if  == U256::from(0x7137d86fu128) {
                    external_fun_testIszero(context)?;
                } else if  == U256::from(0x74e28498u128) {
                    external_fun_testXor(context)?;
                } else if  == U256::from(0x7c3ffef2u128) {
                    external_fun_testAdd(context)?;
                } else if  == U256::from(0x7fe73789u128) {
                    external_fun_testShr(context)?;
                } else if  == U256::from(0x967577f5u128) {
                    external_fun_testAddmod(context)?;
                } else if  == U256::from(0x981f398bu128) {
                    external_fun_testCalldataload(context)?;
                } else if  == U256::from(0xa274ef8cu128) {
                    external_fun_testCalldatasize(context)?;
                } else if  == U256::from(0xb2d508efu128) {
                    external_fun_testAnd(context)?;
                } else if  == U256::from(0xb4955827u128) {
                    external_fun_testSdiv(context)?;
                } else if  == U256::from(0xbd27b6c3u128) {
                    external_fun_testSignextend(context)?;
                } else if  == U256::from(0xbd2c7195u128) {
                    external_fun_testMul(context)?;
                } else if  == U256::from(0xc07b7402u128) {
                    external_fun_testMstore8(context)?;
                } else if  == U256::from(0xc4e4ddc6u128) {
                    external_fun_testPop(context)?;
                } else if  == U256::from(0xc8ec99f1u128) {
                    external_fun_testKeccak256(context)?;
                } else if  == U256::from(0xcb63f201u128) {
                    external_fun_testLt(context)?;
                } else if  == U256::from(0xdb0721d0u128) {
                    external_fun_testSub(context)?;
                } else if  == U256::from(0xe5a30eacu128) {
                    external_fun_testMulmod(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let mut context = Context {
        contract_interactions: std::marker::PhantomData::<DummyContractInteractions>,
        memory: Memory::new(),
        immutables: std::collections::HashMap::new(),
        storage: std::collections::HashMap::new(),
        address: U256::from(123),
        caller: U256::from(124),
        callvalue: U256::from(12),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
        chain_id: U256::from(123456),
    };

    let result = exp_unit_test::exp_unit_test_deployed::fun_test_Exp(&mut context);
    println!("result: {:#?}", result);
    println!("context: {:#?}", context);
}
