// Generated by Oxidefier

#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod vestingmath_6163 {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn allocate_unbounded(context: &mut Context) -> YulOutput<U256> {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context: &mut Context) -> YulOutput<()> {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body(context: &mut Context) -> YulOutput<()> {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let _1 = allocate_unbounded(context)?;
        codecopy(_1, dataoffset(from_hex("56657374696e674d6174685f363136335f6465706c6f79656400000000000000"), context)?, datasize(from_hex("56657374696e674d6174685f363136335f6465706c6f79656400000000000000"), context)?, context)?;
        setimmutable(_1, from_hex("6c6962726172795f6465706c6f795f6164647265737300000000000000000000"), address(context)?, context)?;
        return_(_1, datasize(from_hex("56657374696e674d6174685f363136335f6465706c6f79656400000000000000"), context)?, context)?;
        Ok(())
    }

    pub mod vestingmath_6163_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn cleanup_uint128(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_uint128(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint128(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint128(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint128(value, context)?;
            Ok(value)
        }

        pub fn cleanup_uint40(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_uint40(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint40(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint40(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint40(value, context)?;
            Ok(value)
        }

        pub fn cleanup_uint64(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_userDefinedValueType_UD2x18(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint64(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_userDefinedValueType_UD2x18(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_userDefinedValueType_UD2x18(value, context)?;
            Ok(value)
        }

        pub fn allocate_unbounded(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x41(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn round_up_to_mul_of(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
            Ok(result)
        }

        pub fn finalize_allocation(memPtr: U256, size: U256, context: &mut Context) -> YulOutput<()> {
            let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
            if or(gt(newFreePtr, U256::from(0xffffffffffffffffu128), context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            mstore(U256::from(0x40u128), newFreePtr, context)?;
            Ok(())
        }

        pub fn allocate_memory(size: U256, context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            finalize_allocation(memPtr, size, context)?;
            Ok(memPtr)
        }

        pub fn revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_struct_Segment(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x60u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_userDefinedValueType_UD2x18(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_Segment_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_array_struct_Segment_dyn(offset: U256, length: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_Segment_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x60u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_Segment(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x60u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_array_struct_Segment_dyn(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_array_struct_Segment_dyn(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_struct_Tranche(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_Tranche_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_Tranche_dyn(offset: U256, length: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_Tranche_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x40u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_Tranche(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x40u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn abi_decode_array_struct_Tranche_dyn(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_array_struct_Tranche_dyn(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_struct_Timestamps(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn abi_decode_struct_UnlockAmounts(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_uint128t_array_struct_Segment_dynt_uint40t_struct_Timestampst_uint128(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256, U256, U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0xc0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x20u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value1 = abi_decode_array_struct_Segment_dyn(add(headStart, offset, context)?, dataEnd, context)?;
            value2 = abi_decode_uint40(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            value3 = abi_decode_struct_Timestamps(add(headStart, U256::from(0x60u128), context)?, dataEnd, context)?;
            value4 = abi_decode_uint128(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4))
        }

        pub fn abi_decode_uint128t_uint40t_struct_Timestampst_array_struct_Tranche_dyn(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256, U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0xa0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_struct_Timestamps(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x80u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value3 = abi_decode_array_struct_Tranche_dyn(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3))
        }

        pub fn abi_decode_uint128t_uint40t_struct_Timestampst_uint40t_struct_UnlockAmountst_uint128(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256, U256, U256, U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            let mut value5 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x100u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_struct_Timestamps(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            value3 = abi_decode_uint40(add(headStart, U256::from(0x80u128), context)?, dataEnd, context)?;
            value4 = abi_decode_struct_UnlockAmounts(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value5 = abi_decode_uint128(add(headStart, U256::from(0xe0u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4, value5))
        }

        pub fn abi_encode_tuple(headStart: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x0u128), context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_tuple_uint128(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn cleanup_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn abi_encode_uint256(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256_uint256(headStart: U256, value0: U256, value1: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint256_uint256(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn cleanup_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn identity(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_int256_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_int256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_userDefinedValueType_SD59x18_to_int256(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, convert_int256_to_int256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_userDefinedValueType_SD59x18(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_userDefinedValueType_SD59x18_to_int256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_userDefinedValueType_SD59x18_userDefinedValueType_SD59x18(headStart: U256, value0: U256, value1: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_userDefinedValueType_SD59x18_to_int256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_userDefinedValueType_SD59x18_to_int256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn convert_uint256_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_userDefinedValueType_UD60x18_to_uint256(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, convert_uint256_to_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_userDefinedValueType_UD60x18(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_userDefinedValueType_UD60x18_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_length_array_struct_Segment_dyn(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_struct_Tranche_dyn(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn cleanup_rational_0_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1000000000000000000000000000000000000_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1000000000000000000_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1024_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1048576_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1073741824_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1095216660480_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1099511627776_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1125899906842624_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1152921504606846976_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_128_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_131072_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_134217728_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_137438953472_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_140737488355328_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_144115188075855872_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16384_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16711680_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16777216_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_17179869184_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_17592186044416_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18014398509481984_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18374686479671623680_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551617_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551619_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551622_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551627_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551638_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551660_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551705_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551793_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551971_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709552326_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709553036_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709554455_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709557294_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709562973_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709574329_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709597042_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709642468_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709733320_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709915025_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073710278433_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073711005251_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073712458886_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073715366156_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073721180696_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073732809776_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073756067936_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073802584256_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073895616895_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744074081682175_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744074453812734_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744075198073852_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744076686596088_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744079663640561_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744085617729507_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744097525907406_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744121342263227_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744168974974960_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744264240398796_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744454771247945_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744835832952145_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446745597956384162_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446747122203342655_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446750170697637486_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446756267687738522_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446768461673986097_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446792849670663277_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446841625760745902_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446939178327825412_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18447134285009651015_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18447524504564044946_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18448304968436414829_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18449865995240371898_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18452988445124272033_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18459234930309000272_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18471734244850835106_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18496758270674070881_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18546908069882975960_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18647615946650685159_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18850675170876015534_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_191999999999999999999_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_191_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_19263451207323153962_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2000000000000000000_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_20116317054877281742_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2048_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2097152_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2147483648_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_21936999301089678047_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2199023255552_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2251799813685248_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2305843009213693952_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_255_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_256_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_26087635650665564425_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_262144_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_268435456_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_274877906944_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_280375465082880_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_281474976710656_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_288230376151711744_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_3138550867693340381917894711603833208051177722232017256448_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_32768_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_32_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_33554432_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_34359738368_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_35184372088832_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_36028797018963968_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_3_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4194304_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4294967296_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4398046511104_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4503599627370496_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4611686018427387904_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_500000000000000000_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_512_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_524288_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_536870912_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_549755813888_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_562949953421312_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_576460752303423488_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_64_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_65280_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_65536_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_67108864_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_68719476736_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_70368744177664_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_72057594037927936_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8192_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8388608_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8589934592_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8796093022208_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_9007199254740992_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_9223372036854775808_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by_1(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_minus_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_minus_by_1(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by_1(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_minus_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_uint8(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffu128), context)?;
            Ok(cleaned)
        }

        pub fn constant_MAX_UINT128(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let expr = U256::from(0xffffffffffffffffffffffffffffffffu128);
            ret = expr;
            Ok(ret)
        }

        pub fn convert_rational_1000000000000000000_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_UNIT(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000000000000000_by_1_to_uint256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_1000000000000000000_by_1_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_1000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_UNIT_12227(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let expr = convert_rational_1000000000000000000_by_1_to_int256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = expr;
            Ok(ret)
        }

        pub fn convert_rational_0_by_1_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_ZERO(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let expr = convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?;
            ret = expr;
            Ok(ret)
        }

        pub fn convert_rational_191999999999999999999_by_1_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_191999999999999999999_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uEXP2_MAX_INPUT(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_191999999999999999999_by_1_to_int256(U256::from(0xa688906bd8affffffu128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_minus_59794705707972522261_by_1_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_minus_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uEXP2_MIN_THRESHOLD(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_minus_59794705707972522261_by_1_to_int256(not(U256::from(0x33dd1780914b97114u128), context)?, context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_500000000000000000_by_1_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_500000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uHALF_UNIT(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_500000000000000000_by_1_to_int256(U256::from(0x6f05b59d3b20000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by_1_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uMAX_SD59x18(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by_1_to_int256(sub(shl(U256::from(0xffu128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_t_rational_minus_by_to_t_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_minus_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uMIN_SD59x18(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_t_rational_minus_by_to_t_int256(shl(U256::from(0xffu128), U256::from(0x1u128), context)?, context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn constant_uUNIT(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000000000000000_by_1_to_uint256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn constant_uUNIT_12220(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000000000000000_by_1_to_int256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_by_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_1000000000000000000000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uUNIT_SQUARED(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_by_to_int256(U256::from(0xc097ce7bc90715b34b9f1000000000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_int256_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_int256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_0_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1024_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1024_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1048576_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1048576_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1073741824_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1073741824_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1095216660480_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1095216660480_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1099511627776_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1099511627776_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1125899906842624_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1125899906842624_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1152921504606846976_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1152921504606846976_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_128_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_128_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_131072_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_131072_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_134217728_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_134217728_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_137438953472_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_137438953472_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_140737488355328_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_140737488355328_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_144115188075855872_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_144115188075855872_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16384_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16384_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16711680_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16711680_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16777216_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16777216_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_17179869184_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_17179869184_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_17592186044416_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_17592186044416_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18014398509481984_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18014398509481984_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18374686479671623680_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18374686479671623680_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551617_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551617_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551619_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551619_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551622_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551622_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551627_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551627_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551638_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551638_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551660_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551660_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551705_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551705_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551793_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551793_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551971_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551971_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709552326_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709552326_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709553036_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709553036_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709554455_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709554455_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709557294_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709557294_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709562973_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709562973_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709574329_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709574329_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709597042_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709597042_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709642468_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709642468_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709733320_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709733320_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709915025_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709915025_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073710278433_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073710278433_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073711005251_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073711005251_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073712458886_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073712458886_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073715366156_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073715366156_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073721180696_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073721180696_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073732809776_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073732809776_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073756067936_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073756067936_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073802584256_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073802584256_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073895616895_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073895616895_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744074081682175_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744074081682175_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744074453812734_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744074453812734_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744075198073852_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744075198073852_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744076686596088_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744076686596088_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744079663640561_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744079663640561_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744085617729507_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744085617729507_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744097525907406_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744097525907406_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744121342263227_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744121342263227_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744168974974960_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744168974974960_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744264240398796_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744264240398796_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744454771247945_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744454771247945_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744835832952145_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744835832952145_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446745597956384162_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446745597956384162_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446747122203342655_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446747122203342655_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446750170697637486_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446750170697637486_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446756267687738522_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446756267687738522_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446768461673986097_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446768461673986097_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446792849670663277_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446792849670663277_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446841625760745902_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446841625760745902_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446939178327825412_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446939178327825412_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18447134285009651015_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18447134285009651015_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18447524504564044946_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18447524504564044946_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18448304968436414829_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18448304968436414829_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18449865995240371898_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18449865995240371898_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18452988445124272033_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18452988445124272033_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18459234930309000272_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18459234930309000272_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18471734244850835106_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18471734244850835106_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18496758270674070881_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18496758270674070881_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18546908069882975960_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18546908069882975960_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18647615946650685159_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18647615946650685159_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18850675170876015534_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18850675170876015534_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_191_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_191_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1_by_1_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_20116317054877281742_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_20116317054877281742_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2048_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2048_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2097152_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2097152_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2147483648_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2147483648_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_21936999301089678047_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_21936999301089678047_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2199023255552_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2199023255552_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2251799813685248_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2251799813685248_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2305843009213693952_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2305843009213693952_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_255_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_255_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_256_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_256_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_26087635650665564425_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_26087635650665564425_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_262144_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_262144_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_268435456_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_268435456_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_274877906944_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_274877906944_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_280375465082880_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_280375465082880_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_281474976710656_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_281474976710656_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_288230376151711744_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_288230376151711744_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_3138550867693340381917894711603833208051177722232017256448_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_3138550867693340381917894711603833208051177722232017256448_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_32768_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_32768_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_32_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_32_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_33554432_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_33554432_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_34359738368_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_34359738368_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_35184372088832_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_35184372088832_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_36028797018963968_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_36028797018963968_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_3_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_3_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4194304_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4194304_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4278190080_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4294967296_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4294967296_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4398046511104_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4398046511104_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4503599627370496_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4503599627370496_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4611686018427387904_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4611686018427387904_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_512_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_512_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_524288_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_524288_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_536870912_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_536870912_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_549755813888_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_549755813888_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_562949953421312_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_562949953421312_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_576460752303423488_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_576460752303423488_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_64_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_64_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_65280_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_65280_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_65536_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_65536_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_67108864_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_67108864_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_68719476736_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_68719476736_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_70368744177664_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_70368744177664_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_71776119061217280_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_72057594037927936_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_72057594037927936_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8192_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8192_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8388608_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8388608_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8589934592_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8589934592_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8796093022208_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8796093022208_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_9007199254740992_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_9007199254740992_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_9223372036854775808_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_9223372036854775808_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint128(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_19263451207323153962_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint40(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint40(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint8(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint8(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_minus_by_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_t_rational_minus_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_2000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_uint8(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint8(identity(cleanup_rational_64_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint128_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint128(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint128(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint40_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint40(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint64_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint64(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint64_to_uint64(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint64(identity(cleanup_uint64(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn wrapping_add_uint256(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut sum = U256::ZERO;
            sum = cleanup_uint256(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn panic_error_0x12(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x12u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn wrapping_div_uint256(mut x: U256, mut y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut r = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            if iszero(y, context)? != U256::ZERO {
                panic_error_0x12(context)?;
            }
            r = div(x, y, context)?;
            Ok(r)
        }

        pub fn wrapping_mul_uint256(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut product = U256::ZERO;
            product = cleanup_uint256(mul(x, y, context)?, context)?;
            Ok(product)
        }

        pub fn wrapping_sub_uint256(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut diff = U256::ZERO;
            diff = cleanup_uint256(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn zero_value_for_split_uint256(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_mulDiv(var_x: U256, var_y: U256, mut var_denominator: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let mut var_prod0 = U256::ZERO;
            var_prod0 = zero_uint256;
            let mut var_prod1 = U256::ZERO;
            var_prod1 = zero_uint256;
            let mm = mulmod(var_x, var_y, not(U256::from(0x0u128), context)?, context)?;
            var_prod0 = mul(var_x, var_y, context)?;
            var_prod1 = sub(sub(mm, var_prod0, context)?, lt(mm, var_prod0, context)?, context)?;
            let expr = eq(cleanup_uint256(var_prod1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                let expr_1 = wrapping_div_uint256(var_prod0, var_denominator, context)?;
                var_result = expr_1;
                return Ok(var_result);
            }
            let expr_2 = iszero(lt(cleanup_uint256(var_prod1, context)?, cleanup_uint256(var_denominator, context)?, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0xc740aefu128), context)?, context)?;
                let _1 = abi_encode_uint256_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, var_denominator, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_remainder = U256::ZERO;
            var_remainder = zero_uint256;
            var_remainder = mulmod(var_x, var_y, var_denominator, context)?;
            var_prod1 = sub(var_prod1, gt(var_remainder, var_prod0, context)?, context)?;
            var_prod0 = sub(var_prod0, var_remainder, context)?;
            let expr_3 = cleanup_uint256(not(var_denominator, context)?, context)?;
            let expr_4 = wrapping_add_uint256(expr_3, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let expr_5 = and(var_denominator, expr_4, context)?;
            let mut var_flippedLpotdod = U256::ZERO;
            var_flippedLpotdod = zero_uint256;
            var_denominator = div(var_denominator, expr_5, context)?;
            var_prod0 = div(var_prod0, expr_5, context)?;
            var_flippedLpotdod = add(div(sub(U256::from(0x0u128), expr_5, context)?, expr_5, context)?, U256::from(0x1u128), context)?;
            let expr_6 = wrapping_mul_uint256(var_prod1, var_flippedLpotdod, context)?;
            let expr_7 = or(var_prod0, expr_6, context)?;
            var_prod0 = expr_7;
            let expr_8 = wrapping_mul_uint256(convert_rational_3_by_1_to_uint256(U256::from(0x3u128), context)?, var_denominator, context)?;
            let expr_9 = U256::from(0x2u128);
            let expr_10 = xor(expr_8, convert_rational_2_by_1_to_uint256(expr_9, context)?, context)?;
            let mut var_inverse = expr_10;
            let expr_11 = wrapping_mul_uint256(var_denominator, expr_10, context)?;
            let expr_12 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_11, context)?;
            let expr_13 = wrapping_mul_uint256(expr_10, expr_12, context)?;
            var_inverse = expr_13;
            let expr_14 = wrapping_mul_uint256(var_denominator, expr_13, context)?;
            let expr_15 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_14, context)?;
            let expr_16 = wrapping_mul_uint256(expr_13, expr_15, context)?;
            var_inverse = expr_16;
            let expr_17 = wrapping_mul_uint256(var_denominator, expr_16, context)?;
            let expr_18 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_17, context)?;
            let expr_19 = wrapping_mul_uint256(expr_16, expr_18, context)?;
            var_inverse = expr_19;
            let expr_20 = wrapping_mul_uint256(var_denominator, expr_19, context)?;
            let expr_21 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_20, context)?;
            let expr_22 = wrapping_mul_uint256(expr_19, expr_21, context)?;
            var_inverse = expr_22;
            let expr_23 = wrapping_mul_uint256(var_denominator, expr_22, context)?;
            let expr_24 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_23, context)?;
            let expr_25 = wrapping_mul_uint256(expr_22, expr_24, context)?;
            var_inverse = expr_25;
            let expr_26 = wrapping_mul_uint256(var_denominator, expr_25, context)?;
            let expr_27 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_26, context)?;
            let expr_28 = wrapping_mul_uint256(expr_25, expr_27, context)?;
            var_inverse = expr_28;
            let expr_29 = wrapping_mul_uint256(expr_7, expr_28, context)?;
            var_result = expr_29;
            Ok(var_result)
        }

        pub fn zero_value_for_split_int256(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_unwrap_12052(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_t_int256 = zero_value_for_split_int256(context)?;
            var_result = zero_t_int256;
            let expr = convert_int256_to_int256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn zero_value_for_split_userDefinedValueType_SD59x18(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_wrap(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_int256_to_int256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn negate_wrapping_int256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = cleanup_int256(sub(U256::from(0x0u128), value, context)?, context)?;
            Ok(ret)
        }

        pub fn fun_div_13328(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12052(var_x, context)?;
            let expr_1 = fun_unwrap_12052(var_y, context)?;
            let expr_2 = constant_uMIN_SD59x18(context)?;
            let expr_3 = eq(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?;
            let mut expr_4 = expr_3;
            if iszero(expr_3, context)? != U256::ZERO {
                let expr_5 = eq(cleanup_int256(expr_1, context)?, cleanup_int256(expr_2, context)?, context)?;
                expr_4 = expr_5;
            }
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe4u128), U256::from(0x9fe2b45u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_xAbs = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_xAbs = zero_uint256;
            let mut var_yAbs = U256::ZERO;
            var_yAbs = zero_uint256;
            let expr_6 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_7 = U256::ZERO;
            // switch
            let  = expr_6;
            if  == U256::from(0x0u128) {
                let expr_8 = convert_int256_to_uint256(expr, context)?;
                expr_7 = expr_8;
            }
            var_xAbs = expr_7;
            let expr_11 = slt(cleanup_int256(expr_1, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_12 = U256::ZERO;
            // switch
            let  = expr_11;
            if  == U256::from(0x0u128) {
                let expr_13 = convert_int256_to_uint256(expr_1, context)?;
                expr_12 = expr_13;
            }
            var_yAbs = expr_12;
            let expr_16 = constant_uUNIT_12220(context)?;
            let expr_17 = convert_int256_to_uint256(expr_16, context)?;
            let expr_18 = fun_mulDiv(expr_7, expr_17, expr_12, context)?;
            let expr_19 = constant_uMAX_SD59x18(context)?;
            let expr_20 = convert_int256_to_uint256(expr_19, context)?;
            let expr_21 = gt(cleanup_uint256(expr_18, context)?, cleanup_uint256(expr_20, context)?, context)?;
            if expr_21 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xd49c26b3u128), context)?, context)?;
                let _2 = abi_encode_userDefinedValueType_SD59x18_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let expr_22 = xor(expr, expr_1, context)?;
            let expr_23 = sgt(cleanup_int256(expr_22, context)?, convert_rational_minus_by_to_int256(not(U256::from(0x0u128), context)?, context)?, context)?;
            let mut expr_24 = U256::ZERO;
            // switch
            let  = expr_23;
            if  == U256::from(0x0u128) {
                let expr_25 = convert_uint256_to_int256(expr_18, context)?;
                let expr_26 = negate_wrapping_int256(expr_25, context)?;
                expr_24 = expr_26;
            }
            let expr_28 = fun_wrap(expr_24, context)?;
            var_result = expr_28;
            Ok(var_result)
        }

        pub fn zero_value_for_split_bool(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_gt(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            let expr = fun_unwrap_12052(var_x, context)?;
            let expr_1 = fun_unwrap_12052(var_y, context)?;
            let expr_2 = sgt(cleanup_int256(expr, context)?, cleanup_int256(expr_1, context)?, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_intoSD59x18(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_uint128_to_uint256(var_x, context)?;
            let expr_1 = convert_uint256_to_int256(expr, context)?;
            let expr_2 = convert_int256_to_int256(expr_1, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_intoSD59x18_14592(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_uint64_to_uint64(var_x, context)?;
            let expr_1 = convert_uint64_to_uint256(expr, context)?;
            let expr_2 = convert_uint256_to_int256(expr_1, context)?;
            let expr_3 = convert_int256_to_int256(expr_2, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_intoSD59x18_8304(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_uint40_to_uint256(var_x, context)?;
            let expr_1 = convert_uint256_to_int256(expr, context)?;
            let expr_2 = convert_int256_to_int256(expr_1, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_intoUint256(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let expr = convert_int256_to_int256(var_x, context)?;
            let expr_1 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x2463f3d5u128), context)?, context)?;
                let _1 = abi_encode_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = convert_int256_to_uint256(expr, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_mulDiv18(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let mut var_prod0 = U256::ZERO;
            var_prod0 = zero_uint256;
            let mut var_prod1 = U256::ZERO;
            var_prod1 = zero_uint256;
            let mm = mulmod(var_x, var_y, not(U256::from(0x0u128), context)?, context)?;
            var_prod0 = mul(var_x, var_y, context)?;
            var_prod1 = sub(sub(mm, var_prod0, context)?, lt(mm, var_prod0, context)?, context)?;
            let expr = eq(cleanup_uint256(var_prod1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                let expr_1 = constant_UNIT(context)?;
                let expr_2 = wrapping_div_uint256(var_prod0, expr_1, context)?;
                var_result = expr_2;
                return Ok(var_result);
            }
            let expr_3 = constant_UNIT(context)?;
            let expr_4 = iszero(lt(cleanup_uint256(var_prod1, context)?, cleanup_uint256(expr_3, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5173648du128), context)?, context)?;
                let _1 = abi_encode_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_remainder = U256::ZERO;
            var_remainder = zero_uint256;
            var_remainder = mulmod(var_x, var_y, U256::from(0xde0b6b3a7640000u128), context)?;
            var_result = mul(or(div(sub(var_prod0, var_remainder, context)?, U256::from(0x40000u128), context)?, mul(sub(var_prod1, gt(var_remainder, var_prod0, context)?, context)?, add(div(sub(U256::from(0x0u128), U256::from(0x40000u128), context)?, U256::from(0x40000u128), context)?, U256::from(0x1u128), context)?, context)?, context)?, U256::from_be_slice(&[0xac, 0xcb, 0x18, 0x16, 0x5b, 0xd6, 0xfe, 0x31, 0xae, 0x1c, 0xf3, 0x18, 0xdc, 0x5b, 0x51, 0xee, 0xe0, 0xe1, 0xba, 0x56, 0x9b, 0x88, 0xcd, 0x74, 0xc1, 0x77, 0x3b, 0x91, 0xfa, 0xc1, 0x06, 0x69]), context)?;
            Ok(var_result)
        }

        pub fn fun_mul(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_t_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_t_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12052(var_x, context)?;
            let expr_1 = fun_unwrap_12052(var_y, context)?;
            let expr_2 = constant_uMIN_SD59x18(context)?;
            let expr_3 = eq(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?;
            let mut expr_4 = expr_3;
            if iszero(expr_3, context)? != U256::ZERO {
                let expr_5 = eq(cleanup_int256(expr_1, context)?, cleanup_int256(expr_2, context)?, context)?;
                expr_4 = expr_5;
            }
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xa6070c25u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_xAbs = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_xAbs = zero_uint256;
            let mut var_yAbs = U256::ZERO;
            var_yAbs = zero_uint256;
            let expr_6 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_7 = U256::ZERO;
            // switch
            let  = expr_6;
            if  == U256::from(0x0u128) {
                let expr_8 = convert_int256_to_uint256(expr, context)?;
                expr_7 = expr_8;
            }
            var_xAbs = expr_7;
            let expr_11 = slt(cleanup_int256(expr_1, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_12 = U256::ZERO;
            // switch
            let  = expr_11;
            if  == U256::from(0x0u128) {
                let expr_13 = convert_int256_to_uint256(expr_1, context)?;
                expr_12 = expr_13;
            }
            var_yAbs = expr_12;
            let expr_16 = fun_mulDiv18(expr_7, expr_12, context)?;
            let expr_17 = constant_uMAX_SD59x18(context)?;
            let expr_18 = convert_int256_to_uint256(expr_17, context)?;
            let expr_19 = gt(cleanup_uint256(expr_16, context)?, cleanup_uint256(expr_18, context)?, context)?;
            if expr_19 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x120b5b43u128), context)?, context)?;
                let _2 = abi_encode_userDefinedValueType_SD59x18_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let expr_20 = xor(expr, expr_1, context)?;
            let expr_21 = sgt(cleanup_int256(expr_20, context)?, convert_rational_minus_by_to_int256(not(U256::from(0x0u128), context)?, context)?, context)?;
            let mut expr_22 = U256::ZERO;
            // switch
            let  = expr_21;
            if  == U256::from(0x0u128) {
                let expr_23 = convert_uint256_to_int256(expr_16, context)?;
                let expr_24 = negate_wrapping_int256(expr_23, context)?;
                expr_22 = expr_24;
            }
            let expr_26 = fun_wrap(expr_22, context)?;
            var_result = expr_26;
            Ok(var_result)
        }

        pub fn shift_right_unsigned_dynamic(bits: U256, value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut newValue = U256::ZERO;
            newValue = shr(bits, value, context)?;
            Ok(newValue)
        }

        pub fn shift_right_uint256_uint256(value: U256, mut bits: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            bits = cleanup_uint256(bits, context)?;
            result = cleanup_uint256(shift_right_unsigned_dynamic(bits, cleanup_uint256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn shift_right_uint256_uint8(value: U256, mut bits: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            bits = cleanup_uint8(bits, context)?;
            result = cleanup_uint256(shift_right_unsigned_dynamic(bits, cleanup_uint256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn fun_exp2_15925(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_t_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_t_uint256;
            let _1 = convert_rational_3138550867693340381917894711603833208051177722232017256448_by_1_to_uint256(shl(U256::from(0xbfu128), U256::from(0x1u128), context)?, context)?;
            var_result = _1;
            let expr = and(var_x, convert_rational_18374686479671623680_by_1_to_uint256(U256::from(0xff00000000000000u128), context)?, context)?;
            let expr_1 = gt(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                let expr_2 = and(var_x, convert_rational_9223372036854775808_by_1_to_uint256(U256::from(0x8000000000000000u128), context)?, context)?;
                let expr_3 = gt(cleanup_uint256(expr_2, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_3 != U256::ZERO {
                    let expr_4 = wrapping_mul_uint256(_1, convert_rational_26087635650665564425_by_1_to_uint256(U256::from(0x16a09e667f3bcc909u128), context)?, context)?;
                    let _2 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_5 = shift_right_uint256_uint8(expr_4, _2, context)?;
                    var_result = expr_5;
                }
                let expr_6 = and(var_x, convert_rational_4611686018427387904_by_1_to_uint256(U256::from(0x4000000000000000u128), context)?, context)?;
                let expr_7 = gt(cleanup_uint256(expr_6, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_7 != U256::ZERO {
                    let expr_8 = wrapping_mul_uint256(var_result, convert_rational_21936999301089678047_by_1_to_uint256(U256::from(0x1306fe0a31b7152dfu128), context)?, context)?;
                    let _3 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_9 = shift_right_uint256_uint8(expr_8, _3, context)?;
                    var_result = expr_9;
                }
                let expr_10 = and(var_x, convert_rational_2305843009213693952_by_1_to_uint256(U256::from(0x2000000000000000u128), context)?, context)?;
                let expr_11 = gt(cleanup_uint256(expr_10, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_11 != U256::ZERO {
                    let expr_12 = wrapping_mul_uint256(var_result, convert_rational_20116317054877281742_by_1_to_uint256(U256::from(0x1172b83c7d517adceu128), context)?, context)?;
                    let _4 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_13 = shift_right_uint256_uint8(expr_12, _4, context)?;
                    var_result = expr_13;
                }
                let expr_14 = and(var_x, convert_rational_1152921504606846976_by_1_to_uint256(U256::from(0x1000000000000000u128), context)?, context)?;
                let expr_15 = gt(cleanup_uint256(expr_14, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_15 != U256::ZERO {
                    let expr_16 = wrapping_mul_uint256(var_result, convert_rational_by_to_uint256(U256::from(0x10b5586cf9890f62au128), context)?, context)?;
                    let _5 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_17 = shift_right_uint256_uint8(expr_16, _5, context)?;
                    var_result = expr_17;
                }
                let expr_18 = and(var_x, convert_rational_576460752303423488_by_1_to_uint256(U256::from(0x800000000000000u128), context)?, context)?;
                let expr_19 = gt(cleanup_uint256(expr_18, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_19 != U256::ZERO {
                    let expr_20 = wrapping_mul_uint256(var_result, convert_rational_18850675170876015534_by_1_to_uint256(U256::from(0x1059b0d31585743aeu128), context)?, context)?;
                    let _6 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_21 = shift_right_uint256_uint8(expr_20, _6, context)?;
                    var_result = expr_21;
                }
                let expr_22 = and(var_x, convert_rational_288230376151711744_by_1_to_uint256(U256::from(0x400000000000000u128), context)?, context)?;
                let expr_23 = gt(cleanup_uint256(expr_22, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_23 != U256::ZERO {
                    let expr_24 = wrapping_mul_uint256(var_result, convert_rational_18647615946650685159_by_1_to_uint256(U256::from(0x102c9a3e778060ee7u128), context)?, context)?;
                    let _7 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_25 = shift_right_uint256_uint8(expr_24, _7, context)?;
                    var_result = expr_25;
                }
                let expr_26 = and(var_x, convert_rational_144115188075855872_by_1_to_uint256(U256::from(0x200000000000000u128), context)?, context)?;
                let expr_27 = gt(cleanup_uint256(expr_26, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_27 != U256::ZERO {
                    let expr_28 = wrapping_mul_uint256(var_result, convert_rational_18546908069882975960_by_1_to_uint256(U256::from(0x10163da9fb33356d8u128), context)?, context)?;
                    let _8 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_29 = shift_right_uint256_uint8(expr_28, _8, context)?;
                    var_result = expr_29;
                }
                let expr_30 = and(var_x, convert_rational_72057594037927936_by_1_to_uint256(U256::from(0x100000000000000u128), context)?, context)?;
                let expr_31 = gt(cleanup_uint256(expr_30, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_31 != U256::ZERO {
                    let expr_32 = wrapping_mul_uint256(var_result, convert_rational_18496758270674070881_by_1_to_uint256(U256::from(0x100b1afa5abcbed61u128), context)?, context)?;
                    let _9 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_33 = shift_right_uint256_uint8(expr_32, _9, context)?;
                    var_result = expr_33;
                }
            }
            let expr_34 = and(var_x, convert_rational_71776119061217280_by_1_to_uint256(U256::from(0xff000000000000u128), context)?, context)?;
            let expr_35 = gt(cleanup_uint256(expr_34, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_35 != U256::ZERO {
                let expr_36 = and(var_x, convert_rational_36028797018963968_by_1_to_uint256(U256::from(0x80000000000000u128), context)?, context)?;
                let expr_37 = gt(cleanup_uint256(expr_36, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_37 != U256::ZERO {
                    let expr_38 = wrapping_mul_uint256(var_result, convert_rational_18471734244850835106_by_1_to_uint256(U256::from(0x10058c86da1c09ea2u128), context)?, context)?;
                    let _10 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_39 = shift_right_uint256_uint8(expr_38, _10, context)?;
                    var_result = expr_39;
                }
                let expr_40 = and(var_x, convert_rational_18014398509481984_by_1_to_uint256(U256::from(0x40000000000000u128), context)?, context)?;
                let expr_41 = gt(cleanup_uint256(expr_40, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_41 != U256::ZERO {
                    let expr_42 = wrapping_mul_uint256(var_result, convert_rational_18459234930309000272_by_1_to_uint256(U256::from(0x1002c605e2e8cec50u128), context)?, context)?;
                    let _11 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_43 = shift_right_uint256_uint8(expr_42, _11, context)?;
                    var_result = expr_43;
                }
                let expr_44 = and(var_x, convert_rational_9007199254740992_by_1_to_uint256(U256::from(0x20000000000000u128), context)?, context)?;
                let expr_45 = gt(cleanup_uint256(expr_44, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_45 != U256::ZERO {
                    let expr_46 = wrapping_mul_uint256(var_result, convert_rational_18452988445124272033_by_1_to_uint256(U256::from(0x100162f3904051fa1u128), context)?, context)?;
                    let _12 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_47 = shift_right_uint256_uint8(expr_46, _12, context)?;
                    var_result = expr_47;
                }
                let expr_48 = and(var_x, convert_rational_4503599627370496_by_1_to_uint256(U256::from(0x10000000000000u128), context)?, context)?;
                let expr_49 = gt(cleanup_uint256(expr_48, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_49 != U256::ZERO {
                    let expr_50 = wrapping_mul_uint256(var_result, convert_rational_18449865995240371898_by_1_to_uint256(U256::from(0x1000b175effdc76bau128), context)?, context)?;
                    let _13 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_51 = shift_right_uint256_uint8(expr_50, _13, context)?;
                    var_result = expr_51;
                }
                let expr_52 = and(var_x, convert_rational_2251799813685248_by_1_to_uint256(U256::from(0x8000000000000u128), context)?, context)?;
                let expr_53 = gt(cleanup_uint256(expr_52, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_53 != U256::ZERO {
                    let expr_54 = wrapping_mul_uint256(var_result, convert_rational_18448304968436414829_by_1_to_uint256(U256::from(0x100058ba01fb9f96du128), context)?, context)?;
                    let _14 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_55 = shift_right_uint256_uint8(expr_54, _14, context)?;
                    var_result = expr_55;
                }
                let expr_56 = and(var_x, convert_rational_1125899906842624_by_1_to_uint256(U256::from(0x4000000000000u128), context)?, context)?;
                let expr_57 = gt(cleanup_uint256(expr_56, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_57 != U256::ZERO {
                    let expr_58 = wrapping_mul_uint256(var_result, convert_rational_18447524504564044946_by_1_to_uint256(U256::from(0x10002c5cc37da9492u128), context)?, context)?;
                    let _15 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_59 = shift_right_uint256_uint8(expr_58, _15, context)?;
                    var_result = expr_59;
                }
                let expr_60 = and(var_x, convert_rational_562949953421312_by_1_to_uint256(U256::from(0x2000000000000u128), context)?, context)?;
                let expr_61 = gt(cleanup_uint256(expr_60, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_61 != U256::ZERO {
                    let expr_62 = wrapping_mul_uint256(var_result, convert_rational_18447134285009651015_by_1_to_uint256(U256::from(0x1000162e525ee0547u128), context)?, context)?;
                    let _16 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_63 = shift_right_uint256_uint8(expr_62, _16, context)?;
                    var_result = expr_63;
                }
                let expr_64 = and(var_x, convert_rational_281474976710656_by_1_to_uint256(U256::from(0x1000000000000u128), context)?, context)?;
                let expr_65 = gt(cleanup_uint256(expr_64, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_65 != U256::ZERO {
                    let expr_66 = wrapping_mul_uint256(var_result, convert_rational_18446939178327825412_by_1_to_uint256(U256::from(0x10000b17255775c04u128), context)?, context)?;
                    let _17 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_67 = shift_right_uint256_uint8(expr_66, _17, context)?;
                    var_result = expr_67;
                }
            }
            let expr_68 = and(var_x, convert_rational_280375465082880_by_1_to_uint256(U256::from(0xff0000000000u128), context)?, context)?;
            let expr_69 = gt(cleanup_uint256(expr_68, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_69 != U256::ZERO {
                let expr_70 = and(var_x, convert_rational_140737488355328_by_1_to_uint256(U256::from(0x800000000000u128), context)?, context)?;
                let expr_71 = gt(cleanup_uint256(expr_70, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_71 != U256::ZERO {
                    let expr_72 = wrapping_mul_uint256(var_result, convert_rational_18446841625760745902_by_1_to_uint256(U256::from(0x1000058b91b5bc9aeu128), context)?, context)?;
                    let _18 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_73 = shift_right_uint256_uint8(expr_72, _18, context)?;
                    var_result = expr_73;
                }
                let expr_74 = and(var_x, convert_rational_70368744177664_by_1_to_uint256(U256::from(0x400000000000u128), context)?, context)?;
                let expr_75 = gt(cleanup_uint256(expr_74, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_75 != U256::ZERO {
                    let expr_76 = wrapping_mul_uint256(var_result, convert_rational_18446792849670663277_by_1_to_uint256(U256::from(0x100002c5c89d5ec6du128), context)?, context)?;
                    let _19 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_77 = shift_right_uint256_uint8(expr_76, _19, context)?;
                    var_result = expr_77;
                }
                let expr_78 = and(var_x, convert_rational_35184372088832_by_1_to_uint256(U256::from(0x200000000000u128), context)?, context)?;
                let expr_79 = gt(cleanup_uint256(expr_78, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_79 != U256::ZERO {
                    let expr_80 = wrapping_mul_uint256(var_result, convert_rational_18446768461673986097_by_1_to_uint256(U256::from(0x10000162e43f4f831u128), context)?, context)?;
                    let _20 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_81 = shift_right_uint256_uint8(expr_80, _20, context)?;
                    var_result = expr_81;
                }
                let expr_82 = and(var_x, convert_rational_17592186044416_by_1_to_uint256(U256::from(0x100000000000u128), context)?, context)?;
                let expr_83 = gt(cleanup_uint256(expr_82, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_83 != U256::ZERO {
                    let expr_84 = wrapping_mul_uint256(var_result, convert_rational_18446756267687738522_by_1_to_uint256(U256::from(0x100000b1721bcfc9au128), context)?, context)?;
                    let _21 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_85 = shift_right_uint256_uint8(expr_84, _21, context)?;
                    var_result = expr_85;
                }
                let expr_86 = and(var_x, convert_rational_8796093022208_by_1_to_uint256(U256::from(0x80000000000u128), context)?, context)?;
                let expr_87 = gt(cleanup_uint256(expr_86, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_87 != U256::ZERO {
                    let expr_88 = wrapping_mul_uint256(var_result, convert_rational_18446750170697637486_by_1_to_uint256(U256::from(0x10000058b90cf1e6eu128), context)?, context)?;
                    let _22 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_89 = shift_right_uint256_uint8(expr_88, _22, context)?;
                    var_result = expr_89;
                }
                let expr_90 = and(var_x, convert_rational_4398046511104_by_1_to_uint256(U256::from(0x40000000000u128), context)?, context)?;
                let expr_91 = gt(cleanup_uint256(expr_90, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_91 != U256::ZERO {
                    let expr_92 = wrapping_mul_uint256(var_result, convert_rational_18446747122203342655_by_1_to_uint256(U256::from(0x1000002c5c863b73fu128), context)?, context)?;
                    let _23 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_93 = shift_right_uint256_uint8(expr_92, _23, context)?;
                    var_result = expr_93;
                }
                let expr_94 = and(var_x, convert_rational_2199023255552_by_1_to_uint256(U256::from(0x20000000000u128), context)?, context)?;
                let expr_95 = gt(cleanup_uint256(expr_94, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_95 != U256::ZERO {
                    let expr_96 = wrapping_mul_uint256(var_result, convert_rational_18446745597956384162_by_1_to_uint256(U256::from(0x100000162e430e5a2u128), context)?, context)?;
                    let _24 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_97 = shift_right_uint256_uint8(expr_96, _24, context)?;
                    var_result = expr_97;
                }
                let expr_98 = and(var_x, convert_rational_1099511627776_by_1_to_uint256(U256::from(0x10000000000u128), context)?, context)?;
                let expr_99 = gt(cleanup_uint256(expr_98, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_99 != U256::ZERO {
                    let expr_100 = wrapping_mul_uint256(var_result, convert_rational_18446744835832952145_by_1_to_uint256(U256::from(0x1000000b172183551u128), context)?, context)?;
                    let _25 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_101 = shift_right_uint256_uint8(expr_100, _25, context)?;
                    var_result = expr_101;
                }
            }
            let expr_102 = and(var_x, convert_rational_1095216660480_by_1_to_uint256(U256::from(0xff00000000u128), context)?, context)?;
            let expr_103 = gt(cleanup_uint256(expr_102, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_103 != U256::ZERO {
                let expr_104 = and(var_x, convert_rational_549755813888_by_1_to_uint256(U256::from(0x8000000000u128), context)?, context)?;
                let expr_105 = gt(cleanup_uint256(expr_104, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_105 != U256::ZERO {
                    let expr_106 = wrapping_mul_uint256(var_result, convert_rational_18446744454771247945_by_1_to_uint256(U256::from(0x100000058b90c0b49u128), context)?, context)?;
                    let _26 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_107 = shift_right_uint256_uint8(expr_106, _26, context)?;
                    var_result = expr_107;
                }
                let expr_108 = and(var_x, convert_rational_274877906944_by_1_to_uint256(U256::from(0x4000000000u128), context)?, context)?;
                let expr_109 = gt(cleanup_uint256(expr_108, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_109 != U256::ZERO {
                    let expr_110 = wrapping_mul_uint256(var_result, convert_rational_18446744264240398796_by_1_to_uint256(U256::from(0x10000002c5c8601ccu128), context)?, context)?;
                    let _27 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_111 = shift_right_uint256_uint8(expr_110, _27, context)?;
                    var_result = expr_111;
                }
                let expr_112 = and(var_x, convert_rational_137438953472_by_1_to_uint256(U256::from(0x2000000000u128), context)?, context)?;
                let expr_113 = gt(cleanup_uint256(expr_112, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_113 != U256::ZERO {
                    let expr_114 = wrapping_mul_uint256(var_result, convert_rational_18446744168974974960_by_1_to_uint256(U256::from(0x1000000162e42fff0u128), context)?, context)?;
                    let _28 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_115 = shift_right_uint256_uint8(expr_114, _28, context)?;
                    var_result = expr_115;
                }
                let expr_116 = and(var_x, convert_rational_68719476736_by_1_to_uint256(U256::from(0x1000000000u128), context)?, context)?;
                let expr_117 = gt(cleanup_uint256(expr_116, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_117 != U256::ZERO {
                    let expr_118 = wrapping_mul_uint256(var_result, convert_rational_18446744121342263227_by_1_to_uint256(U256::from(0x10000000b17217fbbu128), context)?, context)?;
                    let _29 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_119 = shift_right_uint256_uint8(expr_118, _29, context)?;
                    var_result = expr_119;
                }
                let expr_120 = and(var_x, convert_rational_34359738368_by_1_to_uint256(U256::from(0x800000000u128), context)?, context)?;
                let expr_121 = gt(cleanup_uint256(expr_120, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_121 != U256::ZERO {
                    let expr_122 = wrapping_mul_uint256(var_result, convert_rational_18446744097525907406_by_1_to_uint256(U256::from(0x1000000058b90bfceu128), context)?, context)?;
                    let _30 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_123 = shift_right_uint256_uint8(expr_122, _30, context)?;
                    var_result = expr_123;
                }
                let expr_124 = and(var_x, convert_rational_17179869184_by_1_to_uint256(U256::from(0x400000000u128), context)?, context)?;
                let expr_125 = gt(cleanup_uint256(expr_124, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_125 != U256::ZERO {
                    let expr_126 = wrapping_mul_uint256(var_result, convert_rational_18446744085617729507_by_1_to_uint256(U256::from(0x100000002c5c85fe3u128), context)?, context)?;
                    let _31 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_127 = shift_right_uint256_uint8(expr_126, _31, context)?;
                    var_result = expr_127;
                }
                let expr_128 = and(var_x, convert_rational_8589934592_by_1_to_uint256(U256::from(0x200000000u128), context)?, context)?;
                let expr_129 = gt(cleanup_uint256(expr_128, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_129 != U256::ZERO {
                    let expr_130 = wrapping_mul_uint256(var_result, convert_rational_18446744079663640561_by_1_to_uint256(U256::from(0x10000000162e42ff1u128), context)?, context)?;
                    let _32 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_131 = shift_right_uint256_uint8(expr_130, _32, context)?;
                    var_result = expr_131;
                }
                let expr_132 = and(var_x, convert_rational_4294967296_by_1_to_uint256(U256::from(0x100000000u128), context)?, context)?;
                let expr_133 = gt(cleanup_uint256(expr_132, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_133 != U256::ZERO {
                    let expr_134 = wrapping_mul_uint256(var_result, convert_rational_18446744076686596088_by_1_to_uint256(U256::from(0x100000000b17217f8u128), context)?, context)?;
                    let _33 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_135 = shift_right_uint256_uint8(expr_134, _33, context)?;
                    var_result = expr_135;
                }
            }
            let expr_136 = and(var_x, convert_rational_4278190080_by_1_to_uint256(U256::from(0xff000000u128), context)?, context)?;
            let expr_137 = gt(cleanup_uint256(expr_136, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_137 != U256::ZERO {
                let expr_138 = and(var_x, convert_rational_2147483648_by_1_to_uint256(U256::from(0x80000000u128), context)?, context)?;
                let expr_139 = gt(cleanup_uint256(expr_138, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_139 != U256::ZERO {
                    let expr_140 = wrapping_mul_uint256(var_result, convert_rational_18446744075198073852_by_1_to_uint256(U256::from(0x10000000058b90bfcu128), context)?, context)?;
                    let _34 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_141 = shift_right_uint256_uint8(expr_140, _34, context)?;
                    var_result = expr_141;
                }
                let expr_142 = and(var_x, convert_rational_1073741824_by_1_to_uint256(U256::from(0x40000000u128), context)?, context)?;
                let expr_143 = gt(cleanup_uint256(expr_142, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_143 != U256::ZERO {
                    let expr_144 = wrapping_mul_uint256(var_result, convert_rational_18446744074453812734_by_1_to_uint256(U256::from(0x1000000002c5c85feu128), context)?, context)?;
                    let _35 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_145 = shift_right_uint256_uint8(expr_144, _35, context)?;
                    var_result = expr_145;
                }
                let expr_146 = and(var_x, convert_rational_536870912_by_1_to_uint256(U256::from(0x20000000u128), context)?, context)?;
                let expr_147 = gt(cleanup_uint256(expr_146, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_147 != U256::ZERO {
                    let expr_148 = wrapping_mul_uint256(var_result, convert_rational_18446744074081682175_by_1_to_uint256(U256::from(0x100000000162e42ffu128), context)?, context)?;
                    let _36 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_149 = shift_right_uint256_uint8(expr_148, _36, context)?;
                    var_result = expr_149;
                }
                let expr_150 = and(var_x, convert_rational_268435456_by_1_to_uint256(U256::from(0x10000000u128), context)?, context)?;
                let expr_151 = gt(cleanup_uint256(expr_150, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_151 != U256::ZERO {
                    let expr_152 = wrapping_mul_uint256(var_result, convert_rational_18446744073895616895_by_1_to_uint256(U256::from(0x1000000000b17217fu128), context)?, context)?;
                    let _37 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_153 = shift_right_uint256_uint8(expr_152, _37, context)?;
                    var_result = expr_153;
                }
                let expr_154 = and(var_x, convert_rational_134217728_by_1_to_uint256(U256::from(0x8000000u128), context)?, context)?;
                let expr_155 = gt(cleanup_uint256(expr_154, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_155 != U256::ZERO {
                    let expr_156 = wrapping_mul_uint256(var_result, convert_rational_18446744073802584256_by_1_to_uint256(U256::from(0x100000000058b90c0u128), context)?, context)?;
                    let _38 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_157 = shift_right_uint256_uint8(expr_156, _38, context)?;
                    var_result = expr_157;
                }
                let expr_158 = and(var_x, convert_rational_67108864_by_1_to_uint256(U256::from(0x4000000u128), context)?, context)?;
                let expr_159 = gt(cleanup_uint256(expr_158, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_159 != U256::ZERO {
                    let expr_160 = wrapping_mul_uint256(var_result, convert_rational_18446744073756067936_by_1_to_uint256(U256::from(0x10000000002c5c860u128), context)?, context)?;
                    let _39 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_161 = shift_right_uint256_uint8(expr_160, _39, context)?;
                    var_result = expr_161;
                }
                let expr_162 = and(var_x, convert_rational_33554432_by_1_to_uint256(U256::from(0x2000000u128), context)?, context)?;
                let expr_163 = gt(cleanup_uint256(expr_162, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_163 != U256::ZERO {
                    let expr_164 = wrapping_mul_uint256(var_result, convert_rational_18446744073732809776_by_1_to_uint256(U256::from(0x1000000000162e430u128), context)?, context)?;
                    let _40 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_165 = shift_right_uint256_uint8(expr_164, _40, context)?;
                    var_result = expr_165;
                }
                let expr_166 = and(var_x, convert_rational_16777216_by_1_to_uint256(U256::from(0x1000000u128), context)?, context)?;
                let expr_167 = gt(cleanup_uint256(expr_166, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_167 != U256::ZERO {
                    let expr_168 = wrapping_mul_uint256(var_result, convert_rational_18446744073721180696_by_1_to_uint256(U256::from(0x10000000000b17218u128), context)?, context)?;
                    let _41 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_169 = shift_right_uint256_uint8(expr_168, _41, context)?;
                    var_result = expr_169;
                }
            }
            let expr_170 = and(var_x, convert_rational_16711680_by_1_to_uint256(U256::from(0xff0000u128), context)?, context)?;
            let expr_171 = gt(cleanup_uint256(expr_170, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_171 != U256::ZERO {
                let expr_172 = and(var_x, convert_rational_8388608_by_1_to_uint256(U256::from(0x800000u128), context)?, context)?;
                let expr_173 = gt(cleanup_uint256(expr_172, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_173 != U256::ZERO {
                    let expr_174 = wrapping_mul_uint256(var_result, convert_rational_18446744073715366156_by_1_to_uint256(U256::from(0x1000000000058b90cu128), context)?, context)?;
                    let _42 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_175 = shift_right_uint256_uint8(expr_174, _42, context)?;
                    var_result = expr_175;
                }
                let expr_176 = and(var_x, convert_rational_4194304_by_1_to_uint256(U256::from(0x400000u128), context)?, context)?;
                let expr_177 = gt(cleanup_uint256(expr_176, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_177 != U256::ZERO {
                    let expr_178 = wrapping_mul_uint256(var_result, convert_rational_18446744073712458886_by_1_to_uint256(U256::from(0x100000000002c5c86u128), context)?, context)?;
                    let _43 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_179 = shift_right_uint256_uint8(expr_178, _43, context)?;
                    var_result = expr_179;
                }
                let expr_180 = and(var_x, convert_rational_2097152_by_1_to_uint256(U256::from(0x200000u128), context)?, context)?;
                let expr_181 = gt(cleanup_uint256(expr_180, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_181 != U256::ZERO {
                    let expr_182 = wrapping_mul_uint256(var_result, convert_rational_18446744073711005251_by_1_to_uint256(U256::from(0x10000000000162e43u128), context)?, context)?;
                    let _44 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_183 = shift_right_uint256_uint8(expr_182, _44, context)?;
                    var_result = expr_183;
                }
                let expr_184 = and(var_x, convert_rational_1048576_by_1_to_uint256(U256::from(0x100000u128), context)?, context)?;
                let expr_185 = gt(cleanup_uint256(expr_184, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_185 != U256::ZERO {
                    let expr_186 = wrapping_mul_uint256(var_result, convert_rational_18446744073710278433_by_1_to_uint256(U256::from(0x100000000000b1721u128), context)?, context)?;
                    let _45 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_187 = shift_right_uint256_uint8(expr_186, _45, context)?;
                    var_result = expr_187;
                }
                let expr_188 = and(var_x, convert_rational_524288_by_1_to_uint256(U256::from(0x80000u128), context)?, context)?;
                let expr_189 = gt(cleanup_uint256(expr_188, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_189 != U256::ZERO {
                    let expr_190 = wrapping_mul_uint256(var_result, convert_rational_18446744073709915025_by_1_to_uint256(U256::from(0x10000000000058b91u128), context)?, context)?;
                    let _46 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_191 = shift_right_uint256_uint8(expr_190, _46, context)?;
                    var_result = expr_191;
                }
                let expr_192 = and(var_x, convert_rational_262144_by_1_to_uint256(U256::from(0x40000u128), context)?, context)?;
                let expr_193 = gt(cleanup_uint256(expr_192, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_193 != U256::ZERO {
                    let expr_194 = wrapping_mul_uint256(var_result, convert_rational_18446744073709733320_by_1_to_uint256(U256::from(0x1000000000002c5c8u128), context)?, context)?;
                    let _47 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_195 = shift_right_uint256_uint8(expr_194, _47, context)?;
                    var_result = expr_195;
                }
                let expr_196 = and(var_x, convert_rational_131072_by_1_to_uint256(U256::from(0x20000u128), context)?, context)?;
                let expr_197 = gt(cleanup_uint256(expr_196, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_197 != U256::ZERO {
                    let expr_198 = wrapping_mul_uint256(var_result, convert_rational_18446744073709642468_by_1_to_uint256(U256::from(0x100000000000162e4u128), context)?, context)?;
                    let _48 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_199 = shift_right_uint256_uint8(expr_198, _48, context)?;
                    var_result = expr_199;
                }
                let expr_200 = and(var_x, convert_rational_65536_by_1_to_uint256(U256::from(0x10000u128), context)?, context)?;
                let expr_201 = gt(cleanup_uint256(expr_200, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_201 != U256::ZERO {
                    let expr_202 = wrapping_mul_uint256(var_result, convert_rational_18446744073709597042_by_1_to_uint256(U256::from(0x1000000000000b172u128), context)?, context)?;
                    let _49 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_203 = shift_right_uint256_uint8(expr_202, _49, context)?;
                    var_result = expr_203;
                }
            }
            let expr_204 = and(var_x, convert_rational_65280_by_1_to_uint256(U256::from(0xff00u128), context)?, context)?;
            let expr_205 = gt(cleanup_uint256(expr_204, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_205 != U256::ZERO {
                let expr_206 = and(var_x, convert_rational_32768_by_1_to_uint256(U256::from(0x8000u128), context)?, context)?;
                let expr_207 = gt(cleanup_uint256(expr_206, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_207 != U256::ZERO {
                    let expr_208 = wrapping_mul_uint256(var_result, convert_rational_18446744073709574329_by_1_to_uint256(U256::from(0x100000000000058b9u128), context)?, context)?;
                    let _50 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_209 = shift_right_uint256_uint8(expr_208, _50, context)?;
                    var_result = expr_209;
                }
                let expr_210 = and(var_x, convert_rational_16384_by_1_to_uint256(U256::from(0x4000u128), context)?, context)?;
                let expr_211 = gt(cleanup_uint256(expr_210, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_211 != U256::ZERO {
                    let expr_212 = wrapping_mul_uint256(var_result, convert_rational_18446744073709562973_by_1_to_uint256(U256::from(0x10000000000002c5du128), context)?, context)?;
                    let _51 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_213 = shift_right_uint256_uint8(expr_212, _51, context)?;
                    var_result = expr_213;
                }
                let expr_214 = and(var_x, convert_rational_8192_by_1_to_uint256(U256::from(0x2000u128), context)?, context)?;
                let expr_215 = gt(cleanup_uint256(expr_214, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_215 != U256::ZERO {
                    let expr_216 = wrapping_mul_uint256(var_result, convert_rational_18446744073709557294_by_1_to_uint256(U256::from(0x1000000000000162eu128), context)?, context)?;
                    let _52 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_217 = shift_right_uint256_uint8(expr_216, _52, context)?;
                    var_result = expr_217;
                }
                let expr_218 = and(var_x, convert_t_rational_by_to_t_uint256(U256::from(0x1000u128), context)?, context)?;
                let expr_219 = gt(cleanup_uint256(expr_218, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_219 != U256::ZERO {
                    let expr_220 = wrapping_mul_uint256(var_result, convert_rational_18446744073709554455_by_1_to_uint256(U256::from(0x10000000000000b17u128), context)?, context)?;
                    let _53 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_221 = shift_right_uint256_uint8(expr_220, _53, context)?;
                    var_result = expr_221;
                }
                let expr_222 = and(var_x, convert_rational_2048_by_1_to_uint256(U256::from(0x800u128), context)?, context)?;
                let expr_223 = gt(cleanup_uint256(expr_222, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_223 != U256::ZERO {
                    let expr_224 = wrapping_mul_uint256(var_result, convert_rational_18446744073709553036_by_1_to_uint256(U256::from(0x1000000000000058cu128), context)?, context)?;
                    let _54 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_225 = shift_right_uint256_uint8(expr_224, _54, context)?;
                    var_result = expr_225;
                }
                let expr_226 = and(var_x, convert_rational_1024_by_1_to_uint256(U256::from(0x400u128), context)?, context)?;
                let expr_227 = gt(cleanup_uint256(expr_226, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_227 != U256::ZERO {
                    let expr_228 = wrapping_mul_uint256(var_result, convert_rational_18446744073709552326_by_1_to_uint256(U256::from(0x100000000000002c6u128), context)?, context)?;
                    let _55 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_229 = shift_right_uint256_uint8(expr_228, _55, context)?;
                    var_result = expr_229;
                }
                let expr_230 = and(var_x, convert_rational_512_by_1_to_uint256(U256::from(0x200u128), context)?, context)?;
                let expr_231 = gt(cleanup_uint256(expr_230, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_231 != U256::ZERO {
                    let expr_232 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551971_by_1_to_uint256(U256::from(0x10000000000000163u128), context)?, context)?;
                    let _56 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_233 = shift_right_uint256_uint8(expr_232, _56, context)?;
                    var_result = expr_233;
                }
                let expr_234 = and(var_x, convert_rational_256_by_1_to_uint256(U256::from(0x100u128), context)?, context)?;
                let expr_235 = gt(cleanup_uint256(expr_234, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_235 != U256::ZERO {
                    let expr_236 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551793_by_1_to_uint256(U256::from(0x100000000000000b1u128), context)?, context)?;
                    let _57 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_237 = shift_right_uint256_uint8(expr_236, _57, context)?;
                    var_result = expr_237;
                }
            }
            let expr_238 = and(var_x, convert_rational_255_by_1_to_uint256(U256::from(0xffu128), context)?, context)?;
            let expr_239 = gt(cleanup_uint256(expr_238, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_239 != U256::ZERO {
                let expr_240 = and(var_x, convert_rational_128_by_1_to_uint256(U256::from(0x80u128), context)?, context)?;
                let expr_241 = gt(cleanup_uint256(expr_240, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_241 != U256::ZERO {
                    let expr_242 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551705_by_1_to_uint256(U256::from(0x10000000000000059u128), context)?, context)?;
                    let _58 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_243 = shift_right_uint256_uint8(expr_242, _58, context)?;
                    var_result = expr_243;
                }
                let expr_244 = U256::from(0x40u128);
                let expr_245 = and(var_x, convert_rational_64_by_1_to_uint256(expr_244, context)?, context)?;
                let expr_246 = gt(cleanup_uint256(expr_245, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_246 != U256::ZERO {
                    let expr_247 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551660_by_1_to_uint256(U256::from(0x1000000000000002cu128), context)?, context)?;
                    let _59 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_248 = shift_right_uint256_uint8(expr_247, _59, context)?;
                    var_result = expr_248;
                }
                let expr_249 = and(var_x, convert_rational_32_by_1_to_uint256(U256::from(0x20u128), context)?, context)?;
                let expr_250 = gt(cleanup_uint256(expr_249, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_250 != U256::ZERO {
                    let expr_251 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551638_by_1_to_uint256(U256::from(0x10000000000000016u128), context)?, context)?;
                    let _60 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_252 = shift_right_uint256_uint8(expr_251, _60, context)?;
                    var_result = expr_252;
                }
                let expr_253 = and(var_x, convert_rational_16_by_1_to_uint256(U256::from(0x10u128), context)?, context)?;
                let expr_254 = gt(cleanup_uint256(expr_253, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_254 != U256::ZERO {
                    let expr_255 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551627_by_1_to_uint256(U256::from(0x1000000000000000bu128), context)?, context)?;
                    let _61 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_256 = shift_right_uint256_uint8(expr_255, _61, context)?;
                    var_result = expr_256;
                }
                let expr_257 = and(var_x, convert_rational_8_by_1_to_uint256(U256::from(0x8u128), context)?, context)?;
                let expr_258 = gt(cleanup_uint256(expr_257, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_258 != U256::ZERO {
                    let expr_259 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551622_by_1_to_uint256(U256::from(0x10000000000000006u128), context)?, context)?;
                    let _62 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_260 = shift_right_uint256_uint8(expr_259, _62, context)?;
                    var_result = expr_260;
                }
                let expr_261 = and(var_x, convert_rational_4_by_1_to_uint256(U256::from(0x4u128), context)?, context)?;
                let expr_262 = gt(cleanup_uint256(expr_261, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_262 != U256::ZERO {
                    let expr_263 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551619_by_1_to_uint256(U256::from(0x10000000000000003u128), context)?, context)?;
                    let _63 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_264 = shift_right_uint256_uint8(expr_263, _63, context)?;
                    var_result = expr_264;
                }
                let expr_265 = and(var_x, convert_rational_2_by_1_to_uint256(U256::from(0x2u128), context)?, context)?;
                let expr_266 = gt(cleanup_uint256(expr_265, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_266 != U256::ZERO {
                    let expr_267 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551617_by_1_to_uint256(U256::from(0x10000000000000001u128), context)?, context)?;
                    let _64 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_268 = shift_right_uint256_uint8(expr_267, _64, context)?;
                    var_result = expr_268;
                }
                let expr_269 = and(var_x, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let expr_270 = gt(cleanup_uint256(expr_269, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_270 != U256::ZERO {
                    let expr_271 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551617_by_1_to_uint256(U256::from(0x10000000000000001u128), context)?, context)?;
                    let _65 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_272 = shift_right_uint256_uint8(expr_271, _65, context)?;
                    var_result = expr_272;
                }
            }
            let expr_273 = constant_UNIT(context)?;
            let expr_274 = wrapping_mul_uint256(var_result, expr_273, context)?;
            var_result = expr_274;
            let _66 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
            let expr_275 = shift_right_uint256_uint8(var_x, _66, context)?;
            let expr_276 = wrapping_sub_uint256(convert_rational_191_by_1_to_uint256(U256::from(0xbfu128), context)?, expr_275, context)?;
            let expr_277 = shift_right_uint256_uint256(expr_274, expr_276, context)?;
            var_result = expr_277;
            Ok(var_result)
        }

        pub fn shift_left_dynamic(bits: U256, value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut newValue = U256::ZERO;
            newValue = shl(bits, value, context)?;
            Ok(newValue)
        }

        pub fn shift_left_int256_uint8(value: U256, mut bits: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            bits = cleanup_uint8(bits, context)?;
            result = cleanup_int256(shift_left_dynamic(bits, cleanup_int256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn wrapping_div_int256(mut x: U256, mut y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut r = U256::ZERO;
            x = cleanup_int256(x, context)?;
            y = cleanup_int256(y, context)?;
            if iszero(y, context)? != U256::ZERO {
                panic_error_0x12(context)?;
            }
            r = sdiv(x, y, context)?;
            Ok(r)
        }

        pub fn fun_exp2(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12052(var_x, context)?;
            let expr_1 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_1;
            if  == U256::from(0x0u128) {
                let expr_2 = constant_uEXP2_MAX_INPUT(context)?;
                let expr_3 = sgt(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?;
                if expr_3 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0x6c1a05u128), context)?, context)?;
                    let _1 = abi_encode_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                    revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
                }
                let _2 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                let expr_4 = shift_left_int256_uint8(expr, _2, context)?;
                let expr_5 = constant_uUNIT_12220(context)?;
                let expr_6 = wrapping_div_int256(expr_4, expr_5, context)?;
                let expr_7 = convert_int256_to_uint256(expr_6, context)?;
                let expr_8 = fun_exp2_15925(expr_7, context)?;
                let expr_9 = convert_uint256_to_int256(expr_8, context)?;
                let expr_10 = fun_wrap(expr_9, context)?;
                var_result = expr_10;
            }
            Ok(var_result)
        }

        pub fn fun_msb(mut var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let factor = shl(U256::from(0x7u128), gt(var_x, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?, context)?;
            var_x = shr(factor, var_x, context)?;
            var_result = or(zero_uint256, factor, context)?;
            let factor_1 = shl(U256::from(0x6u128), gt(var_x, U256::from(0xffffffffffffffffu128), context)?, context)?;
            var_x = shr(factor_1, var_x, context)?;
            var_result = or(var_result, factor_1, context)?;
            let factor_2 = shl(U256::from(0x5u128), gt(var_x, U256::from(0xffffffffu128), context)?, context)?;
            var_x = shr(factor_2, var_x, context)?;
            var_result = or(var_result, factor_2, context)?;
            let factor_3 = shl(U256::from(0x4u128), gt(var_x, U256::from(0xffffu128), context)?, context)?;
            var_x = shr(factor_3, var_x, context)?;
            var_result = or(var_result, factor_3, context)?;
            let factor_4 = shl(U256::from(0x3u128), gt(var_x, U256::from(0xffu128), context)?, context)?;
            var_x = shr(factor_4, var_x, context)?;
            var_result = or(var_result, factor_4, context)?;
            let factor_5 = shl(U256::from(0x2u128), gt(var_x, U256::from(0xfu128), context)?, context)?;
            var_x = shr(factor_5, var_x, context)?;
            var_result = or(var_result, factor_5, context)?;
            let factor_6 = shl(U256::from(0x1u128), gt(var_x, U256::from(0x3u128), context)?, context)?;
            var_x = shr(factor_6, var_x, context)?;
            var_result = or(var_result, factor_6, context)?;
            var_result = or(var_result, gt(var_x, U256::from(0x1u128), context)?, context)?;
            Ok(var_result)
        }

        pub fn shift_right_signed_dynamic(bits: U256, value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            result = sar(bits, value, context)?;
            Ok(result)
        }

        pub fn shift_right_int256_uint256(value: U256, mut bits: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            bits = cleanup_uint256(bits, context)?;
            result = cleanup_int256(shift_right_signed_dynamic(bits, cleanup_int256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn shift_right_int256_uint8(value: U256, mut bits: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            bits = cleanup_uint8(bits, context)?;
            result = cleanup_int256(shift_right_signed_dynamic(bits, cleanup_int256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn wrapping_add_int256(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut sum = U256::ZERO;
            sum = cleanup_int256(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn wrapping_mul_int256(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut product = U256::ZERO;
            product = cleanup_int256(mul(x, y, context)?, context)?;
            Ok(product)
        }

        pub fn fun_log2(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12052(var_x, context)?;
            let mut var_xInt = expr;
            let expr_1 = iszero(sgt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x59b101bu128), context)?, context)?;
                let _1 = abi_encode_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_sign = U256::ZERO;
            let zero_int256 = zero_value_for_split_int256(context)?;
            var_sign = zero_int256;
            let expr_2 = constant_uUNIT_12220(context)?;
            let expr_3 = iszero(slt(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?, context)?;
            // switch
            let  = expr_3;
            if  == U256::from(0x0u128) {
                let _2 = convert_rational_minus_by_to_int256(not(U256::from(0x0u128), context)?, context)?;
                var_sign = _2;
                let expr_4 = constant_uUNIT_SQUARED(context)?;
                let expr_5 = wrapping_div_int256(expr_4, expr, context)?;
                var_xInt = expr_5;
            }
            let expr_6 = wrapping_div_int256(var_xInt, expr_2, context)?;
            let expr_7 = convert_int256_to_uint256(expr_6, context)?;
            let expr_8 = fun_msb(expr_7, context)?;
            let expr_9 = convert_uint256_to_int256(expr_8, context)?;
            let expr_10 = wrapping_mul_int256(expr_9, expr_2, context)?;
            let mut var_resultInt = expr_10;
            let expr_11 = shift_right_int256_uint256(var_xInt, expr_8, context)?;
            let mut var_y = expr_11;
            let expr_12 = eq(cleanup_int256(expr_11, context)?, cleanup_int256(expr_2, context)?, context)?;
            if expr_12 != U256::ZERO {
                let expr_13 = wrapping_mul_int256(expr_10, var_sign, context)?;
                let expr_14 = fun_wrap(expr_13, context)?;
                var_result = expr_14;
                return Ok(var_result);
            }
            let var_DOUBLE_UNIT = convert_t_rational_by_to_t_int256(U256::from(0x1bc16d674ec80000u128), context)?;
            let expr_15 = constant_uHALF_UNIT(context)?;
            let mut var_delta = expr_15;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_17 = sgt(cleanup_int256(var_delta, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
                    if iszero(expr_17, context)? != U256::ZERO {
                        break;
                    }
                    let expr_18 = wrapping_mul_int256(var_y, var_y, context)?;
                    let expr_19 = wrapping_div_int256(expr_18, expr_2, context)?;
                    var_y = expr_19;
                    let expr_20 = iszero(slt(cleanup_int256(expr_19, context)?, cleanup_int256(var_DOUBLE_UNIT, context)?, context)?, context)?;
                    if expr_20 != U256::ZERO {
                        let expr_21 = wrapping_add_int256(var_resultInt, var_delta, context)?;
                        var_resultInt = expr_21;
                        let _5 = convert_rational_by_to_uint8(U256::from(0x1u128), context)?;
                        let expr_22 = shift_right_int256_uint8(expr_19, _5, context)?;
                        var_y = expr_22;
                    }
                }
                // post
                {
                    let _4 = convert_rational_by_to_uint8(U256::from(0x1u128), context)?;
                    let expr_16 = shift_right_int256_uint8(var_delta, _4, context)?;
                    var_delta = expr_16;
                }
            }
            let expr_23 = wrapping_mul_int256(var_resultInt, var_sign, context)?;
            var_resultInt = expr_23;
            let expr_24 = fun_wrap(expr_23, context)?;
            var_result = expr_24;
            Ok(var_result)
        }

        pub fn fun_pow(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12052(var_x, context)?;
            let expr_1 = fun_unwrap_12052(var_y, context)?;
            let expr_2 = eq(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_2;
            if  == U256::from(0x0u128) {
                let expr_3 = constant_uUNIT_12220(context)?;
                let expr_4 = eq(cleanup_int256(expr, context)?, cleanup_int256(expr_3, context)?, context)?;
                if expr_4 != U256::ZERO {
                    let expr_5 = constant_UNIT_12227(context)?;
                    var_result = expr_5;
                    return Ok(var_result);
                }
            }
            let expr_10 = eq(cleanup_int256(expr_1, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_10;
            if  == U256::from(0x0u128) {
                let expr_11 = constant_uUNIT_12220(context)?;
                let expr_12 = eq(cleanup_int256(expr_1, context)?, cleanup_int256(expr_11, context)?, context)?;
                if expr_12 != U256::ZERO {
                    var_result = var_x;
                    return Ok(var_result);
                }
            }
            let expr_14 = fun_log2(var_x, context)?;
            let expr_15 = fun_mul(expr_14, var_y, context)?;
            let expr_16 = fun_exp2(expr_15, context)?;
            var_result = expr_16;
            Ok(var_result)
        }

        pub fn panic_error_0x32(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x32u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn memory_array_index_access_struct_Segment_dyn(baseRef: U256, index: U256, context: &mut Context) -> YulOutput<U256> {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_Segment_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn read_from_memoryt_uint128(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint128(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_uint40(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint40(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_userDefinedValueType_UD2x18(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint64(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn wrapping_add_uint128(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut sum = U256::ZERO;
            sum = cleanup_uint128(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn wrapping_sub_uint40(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut diff = U256::ZERO;
            diff = cleanup_uint40(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn zero_value_for_split_uint128(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_split_uint40(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_calculateLockupDynamicStreamedAmount(var_depositedAmount: U256, var_segments_mpos: U256, var_blockTimestamp: U256, var_timestamps_5748_mpos: U256, var_withdrawnAmount: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let _1 = read_from_memoryt_uint40(add(var_timestamps_5748_mpos, U256::from(0x0u128), context)?, context)?;
            let expr = gt(cleanup_uint40(_1, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr != U256::ZERO {
                var = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var);
            }
            let _2 = read_from_memoryt_uint40(add(var_timestamps_5748_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1 = iszero(gt(cleanup_uint40(_2, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                var = var_depositedAmount;
                return Ok(var);
            }
            let mut var_previousSegmentAmounts = U256::ZERO;
            var_previousSegmentAmounts = zero_uint128;
            let _109_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _3 = read_from_memoryt_uint40(add(_109_mpos, U256::from(0x40u128), context)?, context)?;
            let mut var_currentSegmentTimestamp = _3;
            let mut var_index = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_2 = lt(cleanup_uint40(var_currentSegmentTimestamp, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
                    if iszero(expr_2, context)? != U256::ZERO {
                        break;
                    }
                    let _116_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, var_index, context)?, context)?;
                    let _4 = read_from_memoryt_uint128(add(_116_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_3 = wrapping_add_uint128(var_previousSegmentAmounts, _4, context)?;
                    var_previousSegmentAmounts = expr_3;
                    let _5 = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
                    let expr_4 = wrapping_add_uint256(var_index, _5, context)?;
                    var_index = expr_4;
                    let _mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, expr_4, context)?, context)?;
                    let _6 = read_from_memoryt_uint40(add(_mpos, U256::from(0x40u128), context)?, context)?;
                    var_currentSegmentTimestamp = _6;
                }
                // post
                {

                }
            }
            let _129_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, var_index, context)?, context)?;
            let _7 = read_from_memoryt_uint128(add(_129_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_5 = fun_intoSD59x18(_7, context)?;
            let _134_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, var_index, context)?, context)?;
            let _8 = read_from_memoryt_userDefinedValueType_UD2x18(add(_134_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_6 = fun_intoSD59x18_14592(_8, context)?;
            let _139_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, var_index, context)?, context)?;
            let _9 = read_from_memoryt_uint40(add(_139_mpos, U256::from(0x40u128), context)?, context)?;
            var_currentSegmentTimestamp = _9;
            let mut var_previousTimestamp = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_previousTimestamp = zero_uint40;
            let expr_7 = eq(cleanup_uint256(var_index, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_7;
            if  == U256::from(0x0u128) {
                let expr_8 = wrapping_sub_uint256(var_index, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let _146_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, expr_8, context)?, context)?;
                let _10 = read_from_memoryt_uint40(add(_146_mpos, U256::from(0x40u128), context)?, context)?;
                var_previousTimestamp = _10;
            }
            let expr_9 = wrapping_sub_uint40(var_blockTimestamp, var_previousTimestamp, context)?;
            let expr_10 = fun_intoSD59x18_8304(expr_9, context)?;
            let expr_11 = wrapping_sub_uint40(_9, var_previousTimestamp, context)?;
            let expr_12 = fun_intoSD59x18_8304(expr_11, context)?;
            let expr_13 = fun_div_13328(expr_10, expr_12, context)?;
            let expr_14 = fun_pow(expr_13, expr_6, context)?;
            let expr_15 = fun_mul(expr_14, expr_5, context)?;
            let expr_16 = fun_gt(expr_15, expr_5, context)?;
            if expr_16 != U256::ZERO {
                let expr_17 = gt(cleanup_uint128(var_previousSegmentAmounts, context)?, cleanup_uint128(var_withdrawnAmount, context)?, context)?;
                let mut expr_18 = U256::ZERO;
                // switch
                let  = expr_17;
                if  == U256::from(0x0u128) {
                    expr_18 = var_withdrawnAmount;
                }
                var = expr_18;
                return Ok(var);
            }
            let expr_19 = fun_intoUint256(expr_15, context)?;
            let expr_20 = convert_uint256_to_uint128(expr_19, context)?;
            let expr_21 = wrapping_add_uint128(var_previousSegmentAmounts, expr_20, context)?;
            var = expr_21;
            Ok(var)
        }

        pub fn external_fun_calculateLockupDynamicStreamedAmount(context: &mut Context) -> YulOutput<()> {
            let (param, param_1, param_2, param_3, param_4) = abi_decode_uint128t_array_struct_Segment_dynt_uint40t_struct_Timestampst_uint128(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_calculateLockupDynamicStreamedAmount(param, param_1, param_2, param_3, param_4, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_unwrap(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn zero_value_for_split_userDefinedValueType_UD60x18(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_wrap_9921(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn fun_div(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = constant_uUNIT(context)?;
            let expr_2 = fun_unwrap(var_y, context)?;
            let expr_3 = fun_mulDiv(expr, expr_1, expr_2, context)?;
            let expr_4 = fun_wrap_9921(expr_3, context)?;
            var_result = expr_4;
            Ok(var_result)
        }

        pub fn fun_intoUint128(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_result = zero_uint128;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            let expr_1 = constant_MAX_UINT128(context)?;
            let expr_2 = gt(cleanup_uint256(expr, context)?, convert_uint128_to_uint256(expr_1, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x248b56e7u128), context)?, context)?;
                let _1 = abi_encode_userDefinedValueType_UD60x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_3 = convert_uint256_to_uint128(expr, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_mul_11195(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = fun_unwrap(var_y, context)?;
            let expr_2 = fun_mulDiv18(expr, expr_1, context)?;
            let expr_3 = fun_wrap_9921(expr_2, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_ud(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_t_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_t_userDefinedValueType_UD60x18;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn wrapping_sub_uint128(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut diff = U256::ZERO;
            diff = cleanup_uint128(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn fun_calculateLockupLinearStreamedAmount(var_depositedAmount: U256, var_blockTimestamp: U256, var_timestamps_mpos: U256, var_cliffTime: U256, var_unlockAmounts_mpos: U256, var_withdrawnAmount: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_ = U256::ZERO;
            let zero_t_uint128 = zero_value_for_split_uint128(context)?;
            var_ = zero_t_uint128;
            let _1 = read_from_memoryt_uint40(add(var_timestamps_mpos, U256::from(0x0u128), context)?, context)?;
            let expr = gt(cleanup_uint40(_1, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr != U256::ZERO {
                var_ = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var_);
            }
            let _2 = add(var_timestamps_mpos, U256::from(0x20u128), context)?;
            let _3 = read_from_memoryt_uint40(_2, context)?;
            let expr_1 = iszero(gt(cleanup_uint40(_3, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                var_ = var_depositedAmount;
                return Ok(var_);
            }
            let expr_2 = gt(cleanup_uint40(var_cliffTime, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr_2 != U256::ZERO {
                let _4 = read_from_memoryt_uint128(add(var_unlockAmounts_mpos, U256::from(0x0u128), context)?, context)?;
                var_ = _4;
                return Ok(var_);
            }
            let _5 = read_from_memoryt_uint128(add(var_unlockAmounts_mpos, U256::from(0x0u128), context)?, context)?;
            let _6 = read_from_memoryt_uint128(add(var_unlockAmounts_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_3 = wrapping_add_uint128(_5, _6, context)?;
            let expr_4 = iszero(lt(cleanup_uint128(expr_3, context)?, cleanup_uint128(var_depositedAmount, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                var_ = var_depositedAmount;
                return Ok(var_);
            }
            let mut var_elapsedTime = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_elapsedTime = zero_userDefinedValueType_UD60x18;
            let mut var_streamableRange = U256::ZERO;
            var_streamableRange = zero_userDefinedValueType_UD60x18;
            let expr_5 = eq(cleanup_uint40(var_cliffTime, context)?, convert_rational_by_to_uint40(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr_5;
            if  == U256::from(0x0u128) {
                let expr_6 = wrapping_sub_uint40(var_blockTimestamp, var_cliffTime, context)?;
                let _7 = convert_uint40_to_uint256(expr_6, context)?;
                let expr_7 = fun_ud(_7, context)?;
                var_elapsedTime = expr_7;
                let _8 = read_from_memoryt_uint40(_2, context)?;
                let expr_8 = wrapping_sub_uint40(_8, var_cliffTime, context)?;
                let _9 = convert_uint40_to_uint256(expr_8, context)?;
                let expr_9 = fun_ud(_9, context)?;
                var_streamableRange = expr_9;
            }
            let expr_14 = fun_div(var_elapsedTime, var_streamableRange, context)?;
            let expr_15 = wrapping_sub_uint128(var_depositedAmount, expr_3, context)?;
            let _16 = convert_uint128_to_uint256(expr_15, context)?;
            let expr_16 = fun_ud(_16, context)?;
            let expr_17 = fun_mul_11195(expr_14, expr_16, context)?;
            let expr_18 = fun_intoUint128(expr_17, context)?;
            let expr_19 = wrapping_add_uint128(expr_3, expr_18, context)?;
            let expr_20 = gt(cleanup_uint128(expr_19, context)?, cleanup_uint128(var_depositedAmount, context)?, context)?;
            if expr_20 != U256::ZERO {
                var_ = var_withdrawnAmount;
                return Ok(var_);
            }
            var_ = expr_19;
            Ok(var_)
        }

        pub fn external_fun_calculateLockupLinearStreamedAmount(context: &mut Context) -> YulOutput<()> {
            let (param, param_1, param_2, param_3, param_4, param_5) = abi_decode_uint128t_uint40t_struct_Timestampst_uint40t_struct_UnlockAmountst_uint128(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_calculateLockupLinearStreamedAmount(param, param_1, param_2, param_3, param_4, param_5, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn increment_wrapping_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = cleanup_uint256(add(value, U256::from(0x1u128), context)?, context)?;
            Ok(ret)
        }

        pub fn memory_array_index_access_struct_Tranche_dyn(baseRef: U256, index: U256, context: &mut Context) -> YulOutput<U256> {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_Tranche_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn fun_calculateLockupTranchedStreamedAmount(var_depositedAmount: U256, var_blockTimestamp: U256, var_timestamps_6083_mpos: U256, var_tranches_mpos: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let _1 = read_from_memoryt_uint40(add(var_timestamps_6083_mpos, U256::from(0x0u128), context)?, context)?;
            let expr = gt(cleanup_uint40(_1, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr != U256::ZERO {
                var = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var);
            }
            let _2 = read_from_memoryt_uint40(add(var_timestamps_6083_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1 = iszero(gt(cleanup_uint40(_2, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                var = var_depositedAmount;
                return Ok(var);
            }
            let _12_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _3 = read_from_memoryt_uint40(add(_12_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_2 = gt(cleanup_uint40(_3, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr_2 != U256::ZERO {
                var = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var);
            }
            let _17_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _4 = read_from_memoryt_uint128(add(_17_mpos, U256::from(0x0u128), context)?, context)?;
            let mut var_streamedAmount = _4;
            let expr_3 = array_length_array_struct_Tranche_dyn(var_tranches_mpos, context)?;
            let expr_4 = U256::from(0x1u128);
            let mut var_i = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
            // for loop
            while expr_4 != U256::ZERO {
                // body
                {
                    let expr_5 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr_3, context)?, context)?;
                    if iszero(expr_5, context)? != U256::ZERO {
                        break;
                    }
                    let _27_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_mpos, var_i, context)?, context)?;
                    let _6 = read_from_memoryt_uint40(add(_27_mpos, U256::from(0x20u128), context)?, context)?;
                    let expr_6 = gt(cleanup_uint40(_6, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
                    if expr_6 != U256::ZERO {
                        break;
                    }
                    let _33_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_mpos, var_i, context)?, context)?;
                    let _7 = read_from_memoryt_uint128(add(_33_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_7 = wrapping_add_uint128(var_streamedAmount, _7, context)?;
                    var_streamedAmount = expr_7;
                }
                // post
                {
                    let _5 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _5;
                }
            }
            var = var_streamedAmount;
            Ok(var)
        }

        pub fn external_fun_calculateLockupTranchedStreamedAmount(context: &mut Context) -> YulOutput<()> {
            let (param, param_1, param_2, param_3) = abi_decode_uint128t_uint40t_struct_Timestampst_array_struct_Tranche_dyn(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_calculateLockupTranchedStreamedAmount(param, param_1, param_2, param_3, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                // switch
                let  = selector;
                if  == U256::from(0x485c4f5du128) {
                    external_fun_calculateLockupTranchedStreamedAmount(context)?;
                } else if  == U256::from(0x987117a3u128) {
                    external_fun_calculateLockupLinearStreamedAmount(context)?;
                } else if  == U256::from(0xcd82e8d2u128) {
                    external_fun_calculateLockupDynamicStreamedAmount(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let context = Context {
        memory: Memory::new(),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
    };
    // let result = vestingmath_6163::vestingmath_6163_deployed::fun_runTests(
    //     &mut context
    // );
    // println!("result: {:#?}", result);
    // println!("context: {:#?}", context);
}
