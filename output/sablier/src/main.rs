// Generated by Oxidefier

#![allow(mixed_script_confusables)]
#![allow(non_snake_case)]
#![allow(uncommon_codepoints)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod sablierlockup {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn cleanup_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
        Ok(cleaned)
    }

    pub fn cleanup_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = cleanup_uint160(value, context)?;
        Ok(cleaned)
    }

    pub fn validator_revert_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if iszero(eq(value, cleanup_address(value, context)?, context)?, context)? != U256::ZERO {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        }
        Ok(())
    }

    pub fn abi_decode_address_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value = U256::ZERO;
        value = mload(offset, context)?;
        validator_revert_address(value, context)?;
        Ok(value)
    }

    pub fn cleanup_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = cleanup_address(value, context)?;
        Ok(cleaned)
    }

    pub fn validator_revert_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if iszero(eq(value, cleanup_contract_ILockupNFTDescriptor(value, context)?, context)?, context)? != U256::ZERO {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        }
        Ok(())
    }

    pub fn abi_decode_contract_ILockupNFTDescriptor_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value = U256::ZERO;
        value = mload(offset, context)?;
        validator_revert_contract_ILockupNFTDescriptor(value, context)?;
        Ok(value)
    }

    pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn validator_revert_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        }
        Ok(())
    }

    pub fn abi_decode_uint256_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value = U256::ZERO;
        value = mload(offset, context)?;
        validator_revert_uint256(value, context)?;
        Ok(value)
    }

    pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn abi_decode_addresst_contract_ILockupNFTDescriptort_uint256_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value0 = U256::ZERO;
        let mut value1 = U256::ZERO;
        let mut value2 = U256::ZERO;
        if slt(sub(dataEnd, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
        }
        value0 = abi_decode_address_fromMemory(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
        value1 = abi_decode_contract_ILockupNFTDescriptor_fromMemory(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
        value2 = abi_decode_uint256_fromMemory(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
        Ok((value0, value1, value2))
    }

    pub fn abi_encode_tuple<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut tail = U256::ZERO;
        tail = add(headStart, U256::from(0x0u128), context)?;
        Ok(tail)
    }

    pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn panic_error_0x41<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
        mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
        revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
        Ok(())
    }

    pub fn round_up_to_mul_of<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
        Ok(result)
    }

    pub fn finalize_allocation<CI>(memPtr: U256, size: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
        if or(gt(newFreePtr, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        mstore(U256::from(0x40u128), newFreePtr, context)?;
        Ok(())
    }

    pub fn allocate_memory<CI>(size: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = allocate_unbounded(context)?;
        finalize_allocation(memPtr, size, context)?;
        Ok(memPtr)
    }

    pub fn array_allocation_size_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut size = U256::ZERO;
        if gt(length, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        size = round_up_to_mul_of(length, context)?;
        size = add(size, U256::from(0x20u128), context)?;
        Ok(size)
    }

    pub fn allocate_memory_array_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        let allocSize = array_allocation_size_string(length, context)?;
        memPtr = allocate_memory(allocSize, context)?;
        mstore(memPtr, length, context)?;
        Ok(memPtr)
    }

    pub fn array_dataslot_string_storage<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut data = U256::ZERO;
        data = ptr;
        mstore(U256::from(0x0u128), ptr, context)?;
        data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
        Ok(data)
    }

    pub fn array_length_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut length = U256::ZERO;
        length = mload(value, context)?;
        Ok(length)
    }

    pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn convert_uint256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn prepare_store_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn shift_left_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shl(bits, value, context)?;
        Ok(newValue)
    }

    pub fn update_byte_slice_dynamic32<CI>(mut value: U256, shiftBytes: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let shiftBits = mul(shiftBytes, U256::from(0x8u128), context)?;
        let mask = shift_left_dynamic(shiftBits, not(U256::from(0x0u128), context)?, context)?;
        toInsert = shift_left_dynamic(shiftBits, toInsert, context)?;
        value = and(value, not(mask, context)?, context)?;
        result = or(value, and(toInsert, mask, context)?, context)?;
        Ok(result)
    }

    pub fn update_storage_value_uint256_to_uint256<CI>(slot: U256, offset: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let convertedValue = convert_uint256_to_uint256(value, context)?;
        sstore(slot, update_byte_slice_dynamic32(sload(slot, context)?, offset, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
        Ok(())
    }

    pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = U256::from(0x0u128);
        Ok(ret)
    }

    pub fn storage_set_to_zero_uint256<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let zero = zero_value_for_split_uint256(context)?;
        update_storage_value_uint256_to_uint256(slot, offset, zero, context)?;
        Ok(())
    }

    pub fn clear_storage_range_bytes1<CI>(mut start: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        // for loop
        while lt(start, end_, context)? != U256::ZERO {
            // body
            {
                storage_set_to_zero_uint256(start, U256::from(0x0u128), context)?;
            }
            // post
            {
                start = add(start, U256::from(0x1u128), context)?;
            }
        }
        Ok(())
    }

    pub fn divide_by_ceil<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        result = div(add(value, U256::from(0x1fu128), context)?, U256::from(0x20u128), context)?;
        Ok(result)
    }

    pub fn clean_up_bytearray_end_slots_string_storage<CI>(array: U256, len: U256, startIndex: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if gt(len, U256::from(0x1fu128), context)? != U256::ZERO {
            let dataArea = array_dataslot_string_storage(array, context)?;
            let mut deleteStart = add(dataArea, divide_by_ceil(startIndex, context)?, context)?;
            if lt(startIndex, U256::from(0x20u128), context)? != U256::ZERO {
                deleteStart = dataArea;
            }
            clear_storage_range_bytes1(deleteStart, add(dataArea, divide_by_ceil(len, context)?, context)?, context)?;
        }
        Ok(())
    }

    pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn cleanup_t_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn convert_uint160_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint160(identity(cleanup_uint160(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn convert_uint160_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_uint160(value, context)?;
        Ok(converted)
    }

    pub fn convert_contract_NoDelegateCall_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_address(value, context)?;
        Ok(converted)
    }

    pub fn constructor_NoDelegateCall<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let expr = convert_contract_NoDelegateCall_to_address(address(context)?, context)?;
        mstore(U256::from(0x80u128), expr, context)?;
        Ok(())
    }

    pub fn convert_address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_address(value, context)?;
        Ok(converted)
    }

    pub fn convert_rational_by_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint160(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn convert_rational_by_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_rational_by_to_uint160(value, context)?;
        Ok(converted)
    }

    pub fn prepare_store_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn shift_left<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shl(U256::from(0x0u128), value, context)?;
        Ok(newValue)
    }

    pub fn update_byte_slice_shift_0<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let mask = sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?;
        toInsert = shift_left(toInsert, context)?;
        value = and(value, not(mask, context)?, context)?;
        result = or(value, and(toInsert, mask, context)?, context)?;
        Ok(result)
    }

    pub fn update_storage_value_offsett_address_to_address<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let convertedValue = convert_address_to_address(value, context)?;
        sstore(slot, update_byte_slice_shift_0(sload(slot, context)?, prepare_store_address(convertedValue, context)?, context)?, context)?;
        Ok(())
    }

    pub fn constructor_Adminable<CI>(var_initialAdmin: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_NoDelegateCall(context)?;
        update_storage_value_offsett_address_to_address(U256::from(0x0u128), var_initialAdmin, context)?;
        let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
        let _1 = convert_address_to_address(expr, context)?;
        let _2 = convert_address_to_address(var_initialAdmin, context)?;
        let _3 = allocate_unbounded(context)?;
        let _4 = abi_encode_tuple(_3, context)?;
        log3(_3, sub(_4, _3, context)?, U256::from_be_slice(&[0xbd, 0xd3, 0x61, 0x43, 0xee, 0x09, 0xde, 0x60, 0xbd, 0xef, 0xca, 0x70, 0x68, 0x0e, 0x0f, 0x71, 0x18, 0x9b, 0x2e, 0xd7, 0xac, 0xee, 0x36, 0x4b, 0x53, 0x91, 0x7a, 0xd4, 0x33, 0xfd, 0xaf, 0x80]), _1, _2, context)?;
        Ok(())
    }

    pub fn constructor_Context<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_Adminable(_1, context)?;
        Ok(())
    }

    pub fn constructor_IERC165<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_Context(_1, context)?;
        Ok(())
    }

    pub fn constructor_ERC165<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_IERC165(_1, context)?;
        Ok(())
    }

    pub fn constructor_IERC721<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_ERC165(_1, context)?;
        Ok(())
    }

    pub fn constructor_IERC4906<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_IERC721(_1, context)?;
        Ok(())
    }

    pub fn constructor_IERC721Metadata<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_IERC4906(_1, context)?;
        Ok(())
    }

    pub fn constructor_ISablierLockupBase<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_IERC721Metadata(_1, context)?;
        Ok(())
    }

    pub fn constructor_ISablierLockup<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_ISablierLockupBase(_1, context)?;
        Ok(())
    }

    pub fn constructor_IERC721Errors<CI>(_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_ISablierLockup(_1, context)?;
        Ok(())
    }

    pub fn panic_error_0x22<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
        mstore(U256::from(0x4u128), U256::from(0x22u128), context)?;
        revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
        Ok(())
    }

    pub fn extract_byte_array_length<CI>(data: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut length = U256::ZERO;
        length = div(data, U256::from(0x2u128), context)?;
        let outOfPlaceEncoding = and(data, U256::from(0x1u128), context)?;
        if iszero(outOfPlaceEncoding, context)? != U256::ZERO {
            length = and(length, U256::from(0x7fu128), context)?;
        }
        if eq(outOfPlaceEncoding, lt(length, U256::from(0x20u128), context)?, context)? != U256::ZERO {
            panic_error_0x22(context)?;
        }
        Ok(length)
    }

    pub fn shift_right_unsigned_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shr(bits, value, context)?;
        Ok(newValue)
    }

    pub fn mask_bytes_dynamic<CI>(data: U256, bytes: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let mask = not(shift_right_unsigned_dynamic(mul(U256::from(0x8u128), bytes, context)?, not(U256::from(0x0u128), context)?, context)?, context)?;
        result = and(data, mask, context)?;
        Ok(result)
    }

    pub fn extract_used_part_and_set_length_of_short_byte_array<CI>(mut data: U256, len: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut used = U256::ZERO;
        data = mask_bytes_dynamic(data, len, context)?;
        used = or(data, mul(U256::from(0x2u128), len, context)?, context)?;
        Ok(used)
    }

    pub fn copy_byte_array_to_storage_from_string_to_string<CI>(slot: U256, src: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let newLen = array_length_string(src, context)?;
        if gt(newLen, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        let oldLen = extract_byte_array_length(sload(slot, context)?, context)?;
        clean_up_bytearray_end_slots_string_storage(slot, oldLen, newLen, context)?;
        let mut srcOffset = U256::from(0x0u128);
        srcOffset = U256::from(0x20u128);
        // switch
        let δ = gt(newLen, U256::from(0x1fu128), context)?;
        if δ == U256::from(0x1u128) {
            let loopEnd = and(newLen, not(U256::from(0x1fu128), context)?, context)?;
            let mut dstPtr = array_dataslot_string_storage(slot, context)?;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, loopEnd, context)? != U256::ZERO {
                // body
                {
                    sstore(dstPtr, mload(add(src, srcOffset, context)?, context)?, context)?;
                    dstPtr = add(dstPtr, U256::from(0x1u128), context)?;
                    srcOffset = add(srcOffset, U256::from(0x20u128), context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x20u128), context)?;
                }
            }
            if lt(loopEnd, newLen, context)? != U256::ZERO {
                let lastValue = mload(add(src, srcOffset, context)?, context)?;
                sstore(dstPtr, mask_bytes_dynamic(lastValue, and(newLen, U256::from(0x1fu128), context)?, context)?, context)?;
            }
            sstore(slot, add(mul(newLen, U256::from(0x2u128), context)?, U256::from(0x1u128), context)?, context)?;
        }
        Ok(())
    }

    pub fn update_storage_value_offsett_string_to_string<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        copy_byte_array_to_storage_from_string_to_string(slot, value, context)?;
        Ok(())
    }

    pub fn constructor_ERC721<CI>(var_name_mpos: U256, var_symbol_mpos: U256, _1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_IERC721Errors(_1, context)?;
        update_storage_value_offsett_string_to_string(U256::from(0x1u128), var_name_mpos, context)?;
        update_storage_value_offsett_string_to_string(U256::from(0x2u128), var_symbol_mpos, context)?;
        Ok(())
    }

    pub fn convert_uint160_to_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_uint160(value, context)?;
        Ok(converted)
    }

    pub fn convert_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = convert_uint160_to_contract_ILockupNFTDescriptor(value, context)?;
        Ok(converted)
    }

    pub fn prepare_store_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn update_storage_value_offsett_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let convertedValue = convert_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor(value, context)?;
        sstore(slot, update_byte_slice_shift_0(sload(slot, context)?, prepare_store_contract_ILockupNFTDescriptor(convertedValue, context)?, context)?, context)?;
        Ok(())
    }

    pub fn constructor_SablierLockupBase<CI>(var_initialAdmin: U256, var_initialNFTDescriptor_address: U256, _mpos: U256, _mpos_1: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        constructor_ERC721(_mpos, _mpos_1, var_initialAdmin, context)?;
        update_storage_value_offsett_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor(U256::from(0x8u128), var_initialNFTDescriptor_address, context)?;
        Ok(())
    }

    pub fn convert_rational_by_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn store_literal_in_memory_31c34ea71f24b7f68c0b2e31ced0ad9cb69f9560f60470997defcbadb6b14ecf<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("5341422d4c4f434b555000000000000000000000000000000000000000000000"), context)?;
        Ok(())
    }

    pub fn copy_literal_to_memory_31c34ea71f24b7f68c0b2e31ced0ad9cb69f9560f60470997defcbadb6b14ecf<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = allocate_memory_array_string(U256::from(0xau128), context)?;
        store_literal_in_memory_31c34ea71f24b7f68c0b2e31ced0ad9cb69f9560f60470997defcbadb6b14ecf(add(memPtr, U256::from(0x20u128), context)?, context)?;
        Ok(memPtr)
    }

    pub fn convert_stringliteral_31c3_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = copy_literal_to_memory_31c34ea71f24b7f68c0b2e31ced0ad9cb69f9560f60470997defcbadb6b14ecf(context)?;
        Ok(converted)
    }

    pub fn store_literal_in_memory_4e121b40d352f11b41ad026fe106b6b950dbd2d8c2343274d08cdef8edd909a5<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(add(memPtr, U256::from(0x0u128), context)?, from_hex("5361626c696572204c6f636b7570204e46540000000000000000000000000000"), context)?;
        Ok(())
    }

    pub fn copy_literal_to_memory_4e121b40d352f11b41ad026fe106b6b950dbd2d8c2343274d08cdef8edd909a5<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = allocate_memory_array_string(U256::from(0x12u128), context)?;
        store_literal_in_memory_4e121b40d352f11b41ad026fe106b6b950dbd2d8c2343274d08cdef8edd909a5(add(memPtr, U256::from(0x20u128), context)?, context)?;
        Ok(memPtr)
    }

    pub fn convert_stringliteral_4e12_to_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = copy_literal_to_memory_4e121b40d352f11b41ad026fe106b6b950dbd2d8c2343274d08cdef8edd909a5(context)?;
        Ok(converted)
    }

    pub fn update_byte_slice_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let mask = not(U256::from(0x0u128), context)?;
        toInsert = shift_left(toInsert, context)?;
        value = and(value, not(mask, context)?, context)?;
        result = or(value, and(toInsert, mask, context)?, context)?;
        Ok(result)
    }

    pub fn update_storage_value_offsett_uint256_to_uint256<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let convertedValue = convert_uint256_to_uint256(value, context)?;
        sstore(slot, update_byte_slice_shift(sload(slot, context)?, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
        Ok(())
    }

    pub fn constructor_SablierLockup<CI>(var_initialAdmin: U256, var_initialNFTDescriptor_74_address: U256, var_maxCount: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let _9_mpos = convert_stringliteral_4e12_to_string(context)?;
        let _10_mpos = convert_stringliteral_31c3_to_string(context)?;
        constructor_SablierLockupBase(var_initialAdmin, var_initialNFTDescriptor_74_address, _9_mpos, _10_mpos, context)?;
        mstore(U256::from(0xa0u128), var_maxCount, context)?;
        let _1 = convert_rational_by_to_uint256(U256::from(0x1u128), context)?;
        update_storage_value_offsett_uint256_to_uint256(U256::from(0x7u128), _1, context)?;
        Ok(())
    }

    pub fn copy_arguments_for_constructor_object_SablierLockup<CI>(context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret_param = U256::ZERO;
        let mut ret_param_1 = U256::ZERO;
        let mut ret_param_2 = U256::ZERO;
        let programSize = datasize(from_hex("5361626c6965724c6f636b75705f313131340000000000000000000000000000"), context)?;
        let argSize = sub(codesize(context)?, programSize, context)?;
        let memoryDataOffset = allocate_memory(argSize, context)?;
        codecopy(memoryDataOffset, programSize, argSize, context)?;
        (ret_param, ret_param_1, ret_param_2) = abi_decode_addresst_contract_ILockupNFTDescriptort_uint256_fromMemory(memoryDataOffset, add(memoryDataOffset, argSize, context)?, context)?;
        Ok((ret_param, ret_param_1, ret_param_2))
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0xc0u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let (_1, _2, _3) = copy_arguments_for_constructor_object_SablierLockup(context)?;
        constructor_SablierLockup(_1, _2, _3, context)?;
        let _4 = allocate_unbounded(context)?;
        codecopy(_4, dataoffset(from_hex("5361626c6965724c6f636b75705f313131345f6465706c6f7965640000000000"), context)?, datasize(from_hex("5361626c6965724c6f636b75705f313131345f6465706c6f7965640000000000"), context)?, context)?;
        setimmutable(_4, from_hex("3735363100000000000000000000000000000000000000000000000000000000"), mload(U256::from(0x80u128), context)?, context)?;
        setimmutable(_4, from_hex("3433000000000000000000000000000000000000000000000000000000000000"), mload(U256::from(0xa0u128), context)?, context)?;
        return_(_4, datasize(from_hex("5361626c6965724c6f636b75705f313131345f6465706c6f7965640000000000"), context)?, context)?;
        Ok(())
    }

    pub mod sablierlockup_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            Ok(())
        }

        pub fn cleanup_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = cleanup_uint160(value, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_address(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_address<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_address(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_addresst_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x41<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn round_up_to_mul_of<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
            Ok(result)
        }

        pub fn finalize_allocation<CI>(memPtr: U256, size: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
            if or(gt(newFreePtr, U256::from(0xffffffffffffffffu128), context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            mstore(U256::from(0x40u128), newFreePtr, context)?;
            Ok(())
        }

        pub fn allocate_memory<CI>(size: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            finalize_allocation(memPtr, size, context)?;
            Ok(memPtr)
        }

        pub fn array_allocation_size_bytes<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = round_up_to_mul_of(length, context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn copy_calldata_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            calldatacopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_bytes<CI>(src: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_bytes(length, context)?, context)?;
            mstore(array, length, context)?;
            if gt(add(src, length, context)?, end_, context)? != U256::ZERO {
                revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(context)?;
            }
            copy_calldata_to_memory_with_cleanup(src, add(array, U256::from(0x20u128), context)?, length, context)?;
            Ok(array)
        }

        pub fn revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_bytes<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_bytes(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_addresst_addresst_uint256t_bytes<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x80u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x60u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value3 = abi_decode_bytes(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3))
        }

        pub fn cleanup_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = iszero(iszero(value, context)?, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_bool(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_bool<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_bool(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_bool<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_bool(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_addresst_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_array_bytes_calldata_ptr_dyn_calldata_ptr<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x20u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_bytes_calldata_dyn_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value0, value1) = abi_decode_array_bytes_calldata_ptr_dyn_calldata_ptr(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_array_struct_SegmentWithDuration_calldata_dyn_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x60u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_struct_Segment_calldata_dyn_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x60u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_struct_TrancheWithDuration_calldata_dyn_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x40u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_struct_Tranche_calldata_dyn_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x40u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_uint128_dyn_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x20u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_uint256_dyn_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut arrayPos = U256::ZERO;
            let mut length = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            length = calldataload(offset, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_15abf5612cd996bc235ba1e55a4a30ac60e6bb601ff7ba4ad3f179b6be8d0490(context)?;
            }
            arrayPos = add(offset, U256::from(0x20u128), context)?;
            if gt(add(arrayPos, mul(length, U256::from(0x20u128), context)?, context)?, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            Ok((arrayPos, length))
        }

        pub fn abi_decode_array_uint256_dyn_calldata_ptr<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value0, value1) = abi_decode_array_uint256_dyn_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_array_uint256_dyn_calldatat_array_uint128_dyn_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value0, value1) = abi_decode_array_uint256_dyn_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0x20u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value2, value3) = abi_decode_array_uint128_dyn_calldata(add(headStart, offset_1, context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3))
        }

        pub fn cleanup_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint128(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint128<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint128(value, context)?;
            Ok(value)
        }

        pub fn cleanup_uint40<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_uint40<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint40(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint40<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint40(value, context)?;
            Ok(value)
        }

        pub fn cleanup_uint64<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_userDefinedValueType_UD2x18<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint64(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_userDefinedValueType_UD2x18<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_userDefinedValueType_UD2x18(value, context)?;
            Ok(value)
        }

        pub fn revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_struct_SegmentWithDuration<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x60u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_userDefinedValueType_UD2x18(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_SegmentWithDuration_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_SegmentWithDuration_dyn<CI>(offset: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_SegmentWithDuration_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x60u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_SegmentWithDuration(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x60u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn abi_decode_struct_Segment<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x60u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_userDefinedValueType_UD2x18(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_Segment_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_Segment_dyn<CI>(offset: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_Segment_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x60u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_Segment(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x60u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn abi_decode_struct_TrancheWithDuration<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_TrancheWithDuration_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_TrancheWithDuration_dyn<CI>(offset: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_TrancheWithDuration_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x40u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_TrancheWithDuration(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x40u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn abi_decode_struct_Tranche<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_Tranche_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_Tranche_dyn<CI>(offset: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_Tranche_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x40u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_Tranche(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x40u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn array_allocation_size_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = round_up_to_mul_of(length, context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_string<CI>(src: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_string(length, context)?, context)?;
            mstore(array, length, context)?;
            if gt(add(src, length, context)?, end_, context)? != U256::ZERO {
                revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(context)?;
            }
            copy_calldata_to_memory_with_cleanup(src, add(array, U256::from(0x20u128), context)?, length, context)?;
            Ok(array)
        }

        pub fn copy_memory_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mcopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_string_fromMemory<CI>(src: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_string(length, context)?, context)?;
            mstore(array, length, context)?;
            if gt(add(src, length, context)?, end_, context)? != U256::ZERO {
                revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(context)?;
            }
            copy_memory_to_memory_with_cleanup(src, add(array, U256::from(0x20u128), context)?, length, context)?;
            Ok(array)
        }

        pub fn abi_decode_t_bool_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = mload(offset, context)?;
            validator_revert_bool(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_bool_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_t_bool_fromMemory(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn cleanup_bytes4<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, shl(U256::from(0xe0u128), U256::from(0xffffffffu128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_bytes4<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_bytes4(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_t_bytes4<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_bytes4(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_bytes4<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_t_bytes4(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_bytes4_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = mload(offset, context)?;
            validator_revert_bytes4(value, context)?;
            Ok(value)
        }

        pub fn cleanup_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = cleanup_address(value, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_contract_IERC20(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_contract_IERC20<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_contract_IERC20(value, context)?;
            Ok(value)
        }

        pub fn cleanup_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = cleanup_address(value, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_contract_ILockupNFTDescriptor(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_t_contract_ILockupNFTDescriptor<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_contract_ILockupNFTDescriptor(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_contract_ILockupNFTDescriptor<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_t_contract_ILockupNFTDescriptor(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_string<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_string(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_string_memory_ptr_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            let length = mload(offset, context)?;
            array = abi_decode_available_length_string_fromMemory(add(offset, U256::from(0x20u128), context)?, length, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_string_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = mload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_string_memory_ptr_fromMemory(add(headStart, offset, context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn validator_revert_userDefinedValueType_UD60x18<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_userDefinedValueType_UD60x18<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_userDefinedValueType_UD60x18(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_struct_Broker<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_address(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_userDefinedValueType_UD60x18(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn revert_error_21fe6b43b4db61d76a176e95bf1a6b9ede4c301f93a4246f41fecb96e160861d<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_struct_CreateWithDurations_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, offset, context)?, U256::from(0x120u128), context)? != U256::ZERO {
                revert_error_21fe6b43b4db61d76a176e95bf1a6b9ede4c301f93a4246f41fecb96e160861d(context)?;
            }
            value = offset;
            Ok(value)
        }

        pub fn abi_decode_struct_CreateWithDurations_calldatat_array_struct_SegmentWithDuration_calldata_dyn_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_struct_CreateWithDurations_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0x20u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value1, value2) = abi_decode_array_struct_SegmentWithDuration_calldata_dyn_calldata(add(headStart, offset_1, context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_struct_CreateWithDurations_calldatat_array_struct_TrancheWithDuration_calldata_dyn_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_struct_CreateWithDurations_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0x20u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value1, value2) = abi_decode_array_struct_TrancheWithDuration_calldata_dyn_calldata(add(headStart, offset_1, context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_struct_Durations_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, offset, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_21fe6b43b4db61d76a176e95bf1a6b9ede4c301f93a4246f41fecb96e160861d(context)?;
            }
            value = offset;
            Ok(value)
        }

        pub fn abi_decode_struct_UnlockAmounts_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, offset, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_21fe6b43b4db61d76a176e95bf1a6b9ede4c301f93a4246f41fecb96e160861d(context)?;
            }
            value = offset;
            Ok(value)
        }

        pub fn abi_decode_struct_CreateWithDurations_calldatat_struct_UnlockAmounts_calldatat_struct_Durations_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0xa0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_struct_CreateWithDurations_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            value1 = abi_decode_struct_UnlockAmounts_calldata(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_struct_Durations_calldata(add(headStart, U256::from(0x60u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_struct_Timestamps<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn revert_error_5e8f644817bc4960744f35c15999b6eff64ae702f94b1c46297cfd4e1aec2421<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_struct_CreateWithTimestamps<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x160u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x120u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_address(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_address(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x60u128), context)?, abi_decode_contract_IERC20(add(headStart, U256::from(0x60u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x80u128), context)?, abi_decode_bool(add(headStart, U256::from(0x80u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0xa0u128), context)?, abi_decode_bool(add(headStart, U256::from(0xa0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0xc0u128), context)?, abi_decode_struct_Timestamps(add(headStart, U256::from(0xc0u128), context)?, end_, context)?, context)?;
            let offset = calldataload(add(headStart, U256::from(0x100u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_5e8f644817bc4960744f35c15999b6eff64ae702f94b1c46297cfd4e1aec2421(context)?;
            }
            mstore(add(value, U256::from(0xe0u128), context)?, abi_decode_string(add(headStart, offset, context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x100u128), context)?, abi_decode_struct_Broker(add(headStart, U256::from(0x120u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn abi_decode_struct_CreateWithTimestamps_calldata<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, offset, context)?, U256::from(0x160u128), context)? != U256::ZERO {
                revert_error_21fe6b43b4db61d76a176e95bf1a6b9ede4c301f93a4246f41fecb96e160861d(context)?;
            }
            value = offset;
            Ok(value)
        }

        pub fn abi_decode_struct_CreateWithTimestamps_calldatat_array_struct_Segment_calldata_dyn_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_struct_CreateWithTimestamps_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0x20u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value1, value2) = abi_decode_array_struct_Segment_calldata_dyn_calldata(add(headStart, offset_1, context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_struct_CreateWithTimestamps_calldatat_array_struct_Tranche_calldata_dyn_calldata<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_struct_CreateWithTimestamps_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0x20u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            (value1, value2) = abi_decode_array_struct_Tranche_calldata_dyn_calldata(add(headStart, offset_1, context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_struct_CreateWithTimestamps_calldatat_struct_UnlockAmounts_calldatat_uint40<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x80u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_struct_CreateWithTimestamps_calldata(add(headStart, offset, context)?, dataEnd, context)?;
            value1 = abi_decode_struct_UnlockAmounts_calldata(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint40(add(headStart, U256::from(0x60u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_struct_UnlockAmounts<CI>(headStart: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn abi_decode_tuple_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_tuple_bytes4_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_bytes4_fromMemory(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_tuple_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn abi_decode_uint256t_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_uint256t_addresst_uint128<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_uint256(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint128(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn array_length_bytes<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_storeLengthForEncoding_bytes_memory_ptr<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_bytes_memory_ptr<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_bytes(value, context)?;
            pos = array_storeLengthForEncoding_bytes_memory_ptr(pos, length, context)?;
            copy_memory_to_memory_with_cleanup(add(value, U256::from(0x20u128), context)?, pos, length, context)?;
            end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
            Ok(end_)
        }

        pub fn abi_encodeUpdatedPos_bytes<CI>(value0: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updatedPos = U256::ZERO;
            updatedPos = abi_encode_bytes_memory_ptr(value0, pos, context)?;
            Ok(updatedPos)
        }

        pub fn array_dataslot_string_storage<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            mstore(U256::from(0x0u128), ptr, context)?;
            data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_storeLengthForEncoding_string<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn panic_error_0x22<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x22u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn extract_byte_array_length<CI>(data: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = div(data, U256::from(0x2u128), context)?;
            let outOfPlaceEncoding = and(data, U256::from(0x1u128), context)?;
            if iszero(outOfPlaceEncoding, context)? != U256::ZERO {
                length = and(length, U256::from(0x7fu128), context)?;
            }
            if eq(outOfPlaceEncoding, lt(length, U256::from(0x20u128), context)?, context)? != U256::ZERO {
                panic_error_0x22(context)?;
            }
            Ok(length)
        }

        pub fn abi_encode_string_storage<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let slotValue = sload(value, context)?;
            let length = extract_byte_array_length(slotValue, context)?;
            pos = array_storeLengthForEncoding_string(pos, length, context)?;
            // switch
            let δ = and(slotValue, U256::from(0x1u128), context)?;
            if δ == U256::from(0x0u128) {
                mstore(pos, and(slotValue, not(U256::from(0xffu128), context)?, context)?, context)?;
                ret = add(pos, mul(U256::from(0x20u128), iszero(iszero(length, context)?, context)?, context)?, context)?;
            } else if δ == U256::from(0x1u128) {
                let mut dataPos = array_dataslot_string_storage(value, context)?;
                let mut i = U256::from(0x0u128);
                // for loop
                while lt(i, length, context)? != U256::ZERO {
                    // body
                    {
                        mstore(add(pos, i, context)?, sload(dataPos, context)?, context)?;
                        dataPos = add(dataPos, U256::from(0x1u128), context)?;
                    }
                    // post
                    {
                        i = add(i, U256::from(0x20u128), context)?;
                    }
                }
                ret = add(pos, i, context)?;
            }
            Ok(ret)
        }

        pub fn abi_encodeUpdatedPos_string_storage<CI>(value0: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updatedPos = U256::ZERO;
            updatedPos = abi_encode_string_storage(value0, pos, context)?;
            Ok(updatedPos)
        }

        pub fn abi_encode_uint128_to_uint128<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint40<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint40(value, context)?, context)?;
            Ok(())
        }

        pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_uint64_to_uint64<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint64(identity(cleanup_uint64(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_userDefinedValueType_UD2x18<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_uint64_to_uint64(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_Segment<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128_to_uint128(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_userDefinedValueType_UD2x18(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            let memberValue0_2 = mload(add(value, U256::from(0x40u128), context)?, context)?;
            abi_encode_uint40(memberValue0_2, add(pos, U256::from(0x40u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encodeUpdatedPos_struct_Segment<CI>(value0: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updatedPos = U256::ZERO;
            abi_encode_struct_Segment(value0, pos, context)?;
            updatedPos = add(pos, U256::from(0x60u128), context)?;
            Ok(updatedPos)
        }

        pub fn abi_encode_struct_Tranche<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128_to_uint128(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint40(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encodeUpdatedPos_struct_Tranche<CI>(value0: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updatedPos = U256::ZERO;
            abi_encode_struct_Tranche(value0, pos, context)?;
            updatedPos = add(pos, U256::from(0x40u128), context)?;
            Ok(updatedPos)
        }

        pub fn abi_encode_address<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_address_address<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_to_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_address_address_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_storeLengthForEncoding_bytes<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_bytes<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_bytes(value, context)?;
            pos = array_storeLengthForEncoding_bytes(pos, length, context)?;
            copy_memory_to_memory_with_cleanup(add(value, U256::from(0x20u128), context)?, pos, length, context)?;
            end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
            Ok(end_)
        }

        pub fn abi_encode_address_address_uint256_bytes<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, value3: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x80u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            mstore(add(headStart, U256::from(0x60u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_bytes(value3, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_address_to_address<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_address_uint256<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_address_uint256_address<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_address(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_dataslot_array_bytes_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_bytes_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_nextElement_array_bytes_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut next = U256::ZERO;
            next = add(ptr, U256::from(0x20u128), context)?;
            Ok(next)
        }

        pub fn array_storeLengthForEncoding_array_bytes_dyn<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_array_bytes_dyn<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_array_bytes_dyn(value, context)?;
            pos = array_storeLengthForEncoding_array_bytes_dyn(pos, length, context)?;
            let headStart = pos;
            let mut tail = add(pos, mul(length, U256::from(0x20u128), context)?, context)?;
            let baseRef = array_dataslot_array_bytes_dyn(value, context)?;
            let mut srcPtr = baseRef;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    mstore(pos, sub(tail, headStart, context)?, context)?;
                    let elementValue0 = mload(srcPtr, context)?;
                    tail = abi_encodeUpdatedPos_bytes(elementValue0, tail, context)?;
                    srcPtr = array_nextElement_array_bytes_dyn(srcPtr, context)?;
                    pos = add(pos, U256::from(0x20u128), context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            pos = tail;
            end_ = tail;
            Ok(end_)
        }

        pub fn abi_encode_array_bytes_memory_ptr_dyn_memory_ptr<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_bytes_dyn(value0, tail, context)?;
            Ok(tail)
        }

        pub fn array_dataslot_array_struct_Segment_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_struct_Segment_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_nextElement_array_struct_Segment_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut next = U256::ZERO;
            next = add(ptr, U256::from(0x20u128), context)?;
            Ok(next)
        }

        pub fn array_storeLengthForEncoding_array_struct_Segment_dyn<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_array_struct_Segment_memory_ptr_dyn_memory_ptr<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_array_struct_Segment_dyn(value, context)?;
            pos = array_storeLengthForEncoding_array_struct_Segment_dyn(pos, length, context)?;
            let baseRef = array_dataslot_array_struct_Segment_dyn(value, context)?;
            let mut srcPtr = baseRef;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    let elementValue0 = mload(srcPtr, context)?;
                    pos = abi_encodeUpdatedPos_struct_Segment(elementValue0, pos, context)?;
                    srcPtr = array_nextElement_array_struct_Segment_dyn(srcPtr, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            end_ = pos;
            Ok(end_)
        }

        pub fn abi_encode_array_struct_Segment_dyn<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_struct_Segment_memory_ptr_dyn_memory_ptr(value0, tail, context)?;
            Ok(tail)
        }

        pub fn array_dataslot_array_struct_Tranche_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_struct_Tranche_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_nextElement_array_struct_Tranche_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut next = U256::ZERO;
            next = add(ptr, U256::from(0x20u128), context)?;
            Ok(next)
        }

        pub fn array_storeLengthForEncoding_array_struct_Tranche_dyn<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_array_struct_Tranche_dyn<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_array_struct_Tranche_dyn(value, context)?;
            pos = array_storeLengthForEncoding_array_struct_Tranche_dyn(pos, length, context)?;
            let baseRef = array_dataslot_array_struct_Tranche_dyn(value, context)?;
            let mut srcPtr = baseRef;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    let elementValue0 = mload(srcPtr, context)?;
                    pos = abi_encodeUpdatedPos_struct_Tranche(elementValue0, pos, context)?;
                    srcPtr = array_nextElement_array_struct_Tranche_dyn(srcPtr, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            end_ = pos;
            Ok(end_)
        }

        pub fn abi_encode_array_struct_Tranche_memory_ptr_dyn_memory_ptr<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_struct_Tranche_dyn(value0, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_bool<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bool_to_bool<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bytes4<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bytes4(value, context)?, context)?;
            Ok(())
        }

        pub fn array_storeLengthForEncoding_bytes_nonPadded_inplace<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            updated_pos = pos;
            Ok(updated_pos)
        }

        pub fn abi_encode_bytes_calldata<CI>(start: U256, length: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = array_storeLengthForEncoding_bytes_nonPadded_inplace(pos, length, context)?;
            copy_calldata_to_memory_with_cleanup(start, pos, length, context)?;
            end_ = add(pos, length, context)?;
            Ok(end_)
        }

        pub fn convert_uint160_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_uint160(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IERC20_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn abi_encode_contract_IERC20<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_contract_IERC20_to_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_contract_IERC20_to_address<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_contract_IERC20_to_address(value, context)?, context)?;
            Ok(())
        }

        pub fn convert_contract_ILockupNFTDescriptor_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn abi_encode_contract_ILockupNFTDescriptor<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_contract_ILockupNFTDescriptor_to_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_contract_ILockupNFTDescriptor_contract_ILockupNFTDescriptor<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_contract_ILockupNFTDescriptor(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_contract_ILockupNFTDescriptor(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn convert_contract_SablierLockupBase_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn abi_encode_contract_SablierLockupBase<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_contract_SablierLockupBase_to_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_contract_SablierLockupBase_uint256<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_contract_SablierLockupBase(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn panic_error_0x21<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x21u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn validator_assert_enum_Model<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(lt(value, U256::from(0x3u128), context)?, context)? != U256::ZERO {
                panic_error_0x21(context)?;
            }
            Ok(())
        }

        pub fn cleanup_enum_Model<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            validator_assert_enum_Model(value, context)?;
            Ok(cleaned)
        }

        pub fn convert_enum_Model_to_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_enum_Model(value, context)?;
            Ok(converted)
        }

        pub fn abi_encode_enum_Model<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_enum_Model_to_uint8(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_enum_Model_enum_Model<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_enum_Model(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_enum_Model(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn validator_assert_enum_Status<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(lt(value, U256::from(0x5u128), context)?, context)? != U256::ZERO {
                panic_error_0x21(context)?;
            }
            Ok(())
        }

        pub fn cleanup_enum_Status<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            validator_assert_enum_Status(value, context)?;
            Ok(cleaned)
        }

        pub fn convert_enum_Status_to_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_enum_Status(value, context)?;
            Ok(converted)
        }

        pub fn abi_encode_enum_Status_to_uint8<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_enum_Status_to_uint8(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_enum_Status<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_enum_Status_to_uint8(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_packed_bytes_calldata<CI>(mut pos: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = abi_encode_bytes_calldata(value0, value1, pos, context)?;
            end_ = pos;
            Ok(end_)
        }

        pub fn abi_encode_stringliteral_c5d2<CI>(mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = array_storeLengthForEncoding_bytes_nonPadded_inplace(pos, U256::from(0x0u128), context)?;
            end_ = add(pos, U256::from(0x0u128), context)?;
            Ok(end_)
        }

        pub fn abi_encode_packed_stringliteral_c5d2<CI>(mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            pos = abi_encode_stringliteral_c5d2(pos, context)?;
            end_ = pos;
            Ok(end_)
        }

        pub fn cleanup_rational_1_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn convert_rational_1_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_rational_by<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_rational_1_by_1_to_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_rational_by_uint256<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_rational_by(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_length_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_storeLengthForEncoding_string_fromStack<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_string_memory_ptr<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_string(value, context)?;
            pos = array_storeLengthForEncoding_string_fromStack(pos, length, context)?;
            copy_memory_to_memory_with_cleanup(add(value, U256::from(0x20u128), context)?, pos, length, context)?;
            end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
            Ok(end_)
        }

        pub fn abi_encode_string<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_string_memory_ptr(value0, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_string_to_string<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_string(value, context)?;
            pos = array_storeLengthForEncoding_string(pos, length, context)?;
            copy_memory_to_memory_with_cleanup(add(value, U256::from(0x20u128), context)?, pos, length, context)?;
            end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
            Ok(end_)
        }

        pub fn abi_encode_struct_CreateAmounts<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128_to_uint128(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128_to_uint128(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_Timestamps<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint40(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint40(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_CreateEventCommon<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let mut tail = add(pos, U256::from(0x180u128), context)?;
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            let memberValue0_2 = mload(add(value, U256::from(0x40u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0_2, add(pos, U256::from(0x40u128), context)?, context)?;
            let memberValue0_3 = mload(add(value, U256::from(0x60u128), context)?, context)?;
            abi_encode_struct_CreateAmounts(memberValue0_3, add(pos, U256::from(0x60u128), context)?, context)?;
            let memberValue0_4 = mload(add(value, U256::from(0x80u128), context)?, context)?;
            abi_encode_contract_IERC20(memberValue0_4, add(pos, U256::from(0xa0u128), context)?, context)?;
            let memberValue0_5 = mload(add(value, U256::from(0xa0u128), context)?, context)?;
            abi_encode_bool(memberValue0_5, add(pos, U256::from(0xc0u128), context)?, context)?;
            let memberValue0_6 = mload(add(value, U256::from(0xc0u128), context)?, context)?;
            abi_encode_bool(memberValue0_6, add(pos, U256::from(0xe0u128), context)?, context)?;
            let memberValue0_7 = mload(add(value, U256::from(0xe0u128), context)?, context)?;
            abi_encode_struct_Timestamps(memberValue0_7, add(pos, U256::from(0x100u128), context)?, context)?;
            let memberValue0_8 = mload(add(value, U256::from(0x100u128), context)?, context)?;
            mstore(add(pos, U256::from(0x140u128), context)?, sub(tail, pos, context)?, context)?;
            tail = abi_encode_string_to_string(memberValue0_8, tail, context)?;
            let memberValue0_9 = mload(add(value, U256::from(0x120u128), context)?, context)?;
            abi_encode_address_to_address(memberValue0_9, add(pos, U256::from(0x160u128), context)?, context)?;
            end_ = tail;
            Ok(end_)
        }

        pub fn abi_encode_struct_CreateEventCommon_array_struct_Segment_dyn<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_struct_CreateEventCommon(value0, tail, context)?;
            mstore(add(headStart, U256::from(0x20u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_struct_Segment_memory_ptr_dyn_memory_ptr(value1, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_struct_CreateEventCommon_array_struct_Tranche_dyn<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_struct_CreateEventCommon(value0, tail, context)?;
            mstore(add(headStart, U256::from(0x20u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_struct_Tranche_dyn(value1, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_struct_UnlockAmounts<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128_to_uint128(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128_to_uint128(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint40_to_uint40<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint40(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_CreateEventCommon_uint40_struct_UnlockAmounts<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x80u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_struct_CreateEventCommon(value0, tail, context)?;
            abi_encode_uint40_to_uint40(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_struct_UnlockAmounts(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_struct_UnlockAmounts_memory_ptr<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_struct_UnlockAmounts(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple<CI>(headStart: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x0u128), context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_address<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_bool<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bool_to_bool(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_bytes4<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bytes4(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_contract_IERC20<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_contract_IERC20_to_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_contract_ILockupNFTDescriptor<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_contract_ILockupNFTDescriptor(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_enum_Model<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_enum_Model(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_tuple_uint128<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_uint40<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint40_to_uint40(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn convert_uint256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_userDefinedValueType_UD60x18<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_uint256_to_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_tuple_userDefinedValueType_UD60x18<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_userDefinedValueType_UD60x18(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128_uint128<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128_uint128_uint128<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_address<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_address_address<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_address(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_address_address_uint128<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, value3: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x80u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_address(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            abi_encode_uint128(value3, add(headStart, U256::from(0x60u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_address_uint128<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_address_uint128_uint128<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, value3: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x80u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_address(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            abi_encode_uint128(value3, add(headStart, U256::from(0x60u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_bytes<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            mstore(add(headStart, U256::from(0x20u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_bytes(value1, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint128_uint128<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint256<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint256_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint40_uint40<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint40_to_uint40(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint40_to_uint40(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint40_uint40<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint40_to_uint40(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint40_to_uint40(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn cleanup_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn convert_int256_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_int256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_userDefinedValueType_SD59x18_to_int256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, convert_int256_to_int256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_userDefinedValueType_SD59x18<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_userDefinedValueType_SD59x18_to_int256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_userDefinedValueType_SD59x18_userDefinedValueType_SD59x18<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_userDefinedValueType_SD59x18_to_int256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_userDefinedValueType_SD59x18_to_int256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_userDefinedValueType_UD60x18_userDefinedValueType_UD60x18<CI>(headStart: U256, value0: U256, value1: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_userDefinedValueType_UD60x18(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_userDefinedValueType_UD60x18(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn revert_error_1e55d03107e9c4f1b5e21c76a16fba166a461117ab153bcce65e6a4ea8e5fc8a<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_356d538aaf70fba12156cc466564b792649f8f3befb07b071c91142253e175ad<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_977805620ff29572292dee35f70b0f3f3f73d3fdd0e9f4d7a901c2e43ab18a2e<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn access_calldata_tail_bytes_calldata<CI>(base_ref: U256, ptr_to_tail: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            let mut length = U256::ZERO;
            let rel_offset_of_tail = calldataload(ptr_to_tail, context)?;
            if iszero(slt(rel_offset_of_tail, sub(sub(calldatasize(context)?, base_ref, context)?, sub(U256::from(0x20u128), U256::from(0x1u128), context)?, context)?, context)?, context)? != U256::ZERO {
                revert_error_356d538aaf70fba12156cc466564b792649f8f3befb07b071c91142253e175ad(context)?;
            }
            addr = add(base_ref, rel_offset_of_tail, context)?;
            length = calldataload(addr, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_1e55d03107e9c4f1b5e21c76a16fba166a461117ab153bcce65e6a4ea8e5fc8a(context)?;
            }
            addr = add(addr, U256::from(0x20u128), context)?;
            if sgt(addr, sub(calldatasize(context)?, mul(length, U256::from(0x1u128), context)?, context)?, context)? != U256::ZERO {
                revert_error_977805620ff29572292dee35f70b0f3f3f73d3fdd0e9f4d7a901c2e43ab18a2e(context)?;
            }
            Ok((addr, length))
        }

        pub fn access_calldata_tail_string_calldata<CI>(base_ref: U256, ptr_to_tail: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            let mut length = U256::ZERO;
            let rel_offset_of_tail = calldataload(ptr_to_tail, context)?;
            if iszero(slt(rel_offset_of_tail, sub(sub(calldatasize(context)?, base_ref, context)?, sub(U256::from(0x20u128), U256::from(0x1u128), context)?, context)?, context)?, context)? != U256::ZERO {
                revert_error_356d538aaf70fba12156cc466564b792649f8f3befb07b071c91142253e175ad(context)?;
            }
            addr = add(base_ref, rel_offset_of_tail, context)?;
            length = calldataload(addr, context)?;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_1e55d03107e9c4f1b5e21c76a16fba166a461117ab153bcce65e6a4ea8e5fc8a(context)?;
            }
            addr = add(addr, U256::from(0x20u128), context)?;
            if sgt(addr, sub(calldatasize(context)?, mul(length, U256::from(0x1u128), context)?, context)?, context)? != U256::ZERO {
                revert_error_977805620ff29572292dee35f70b0f3f3f73d3fdd0e9f4d7a901c2e43ab18a2e(context)?;
            }
            Ok((addr, length))
        }

        pub fn array_allocation_size_array_bytes_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn allocate_memory_array_array_bytes_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_array_bytes_dyn(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_bytes<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn zero_complex_memory_array_array_bytes_dyn<CI>(dataStart: U256, dataSizeInBytes: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, dataSizeInBytes, context)? != U256::ZERO {
                // body
                {
                    mstore(add(dataStart, i, context)?, zero_value_for_bytes(context)?, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x20u128), context)?;
                }
            }
            Ok(())
        }

        pub fn allocate_and_zero_memory_array_array_bytes_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_array_bytes_dyn(length, context)?;
            let mut dataStart = memPtr;
            let mut dataSize = array_allocation_size_array_bytes_dyn(length, context)?;
            dataStart = add(memPtr, U256::from(0x20u128), context)?;
            dataSize = sub(dataSize, U256::from(0x20u128), context)?;
            zero_complex_memory_array_array_bytes_dyn(dataStart, dataSize, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_array_array_struct_Segment_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_array_struct_Segment_dyn(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Segment<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x60u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_uint128<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_uint40<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_userDefinedValueType_UD2x18<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn allocate_and_zero_memory_struct_struct_Segment<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_Segment(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint128(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_userDefinedValueType_UD2x18(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint40(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_struct_Segment<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_Segment(context)?;
            Ok(ret)
        }

        pub fn zero_complex_memory_array_array_struct_Segment_dyn<CI>(dataStart: U256, dataSizeInBytes: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, dataSizeInBytes, context)? != U256::ZERO {
                // body
                {
                    mstore(add(dataStart, i, context)?, zero_value_for_struct_Segment(context)?, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x20u128), context)?;
                }
            }
            Ok(())
        }

        pub fn allocate_and_zero_memory_array_array_struct_Segment_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_array_struct_Segment_dyn(length, context)?;
            let mut dataStart = memPtr;
            let mut dataSize = array_allocation_size_array_struct_Segment_dyn(length, context)?;
            dataStart = add(memPtr, U256::from(0x20u128), context)?;
            dataSize = sub(dataSize, U256::from(0x20u128), context)?;
            zero_complex_memory_array_array_struct_Segment_dyn(dataStart, dataSize, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_array_array_struct_Tranche_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_array_struct_Tranche_dyn(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Tranche<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_and_zero_memory_struct_struct_Tranche<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_Tranche(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint128(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint40(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_struct_Tranche<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_Tranche(context)?;
            Ok(ret)
        }

        pub fn zero_complex_memory_array_array_struct_Tranche_dyn<CI>(dataStart: U256, dataSizeInBytes: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, dataSizeInBytes, context)? != U256::ZERO {
                // body
                {
                    mstore(add(dataStart, i, context)?, zero_value_for_struct_Tranche(context)?, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x20u128), context)?;
                }
            }
            Ok(())
        }

        pub fn allocate_and_zero_memory_array_array_struct_Tranche_dyn<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_array_struct_Tranche_dyn(length, context)?;
            let mut dataStart = memPtr;
            let mut dataSize = array_allocation_size_array_struct_Tranche_dyn(length, context)?;
            dataStart = add(memPtr, U256::from(0x20u128), context)?;
            dataSize = sub(dataSize, U256::from(0x20u128), context)?;
            zero_complex_memory_array_array_struct_Tranche_dyn(dataStart, dataSize, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_CreateAmounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_and_zero_memory_struct_struct_CreateAmounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_CreateAmounts(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint128(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint128(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_CreateEventCommon<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x140u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_address<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_bool<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_contract_IERC20<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn zero_value_for_struct_CreateAmounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_CreateAmounts(context)?;
            Ok(ret)
        }

        pub fn allocate_memory_struct_struct_Timestamps<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_and_zero_memory_struct_struct_Timestamps<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_Timestamps(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint40(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint40(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_struct_Timestamps<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_Timestamps(context)?;
            Ok(ret)
        }

        pub fn allocate_and_zero_memory_struct_struct_CreateEventCommon<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_CreateEventCommon(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_address(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_address(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_address(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_struct_CreateAmounts(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_contract_IERC20(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_bool(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_bool(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_struct_Timestamps(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_string(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_address(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_UnlockAmounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_and_zero_memory_struct_struct_UnlockAmounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_UnlockAmounts(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint128(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint128(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_array_bytes<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_bytes(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_array_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_string(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Amounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x60u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Amounts_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x60u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_CreateAmounts_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_CreateEventCommon_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x140u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_CreateWithTimestamps_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x120u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Segment_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x60u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Stream_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x160u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Timestamps_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Tranche_storage_ptr<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn array_dataslot_array_struct_Segment_storage_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            mstore(U256::from(0x0u128), ptr, context)?;
            data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_dataslot_array_struct_Segment_storage_dyn_ptr<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            mstore(U256::from(0x0u128), ptr, context)?;
            data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_dataslot_array_struct_Tranche_storage_dyn<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            mstore(U256::from(0x0u128), ptr, context)?;
            data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_dataslot_array_struct_Tranche_storage_dyn_ptr<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            mstore(U256::from(0x0u128), ptr, context)?;
            data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_bytes_calldata_dyn_calldata<CI>(value: U256, len: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = len;
            Ok(length)
        }

        pub fn array_length_array_struct_SegmentWithDuration_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_struct_Segment_storage_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = sload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_struct_Segment_storage_dyn_ptr<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = sload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_struct_TrancheWithDuration_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_struct_Tranche_storage_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = sload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_struct_Tranche_storage_dyn_ptr<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = sload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_uint128_dyn_calldata<CI>(value: U256, len: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = len;
            Ok(length)
        }

        pub fn array_length_array_uint256_dyn_calldata<CI>(value: U256, len: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = len;
            Ok(length)
        }

        pub fn panic_error_0x32<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x32u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn storage_array_index_access_struct_Segment__dyn_ptr<CI>(array: U256, index: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut slot = U256::ZERO;
            let mut offset = U256::ZERO;
            let arrayLength = array_length_array_struct_Segment_storage_dyn_ptr(array, context)?;
            if iszero(lt(index, arrayLength, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let dataArea = array_dataslot_array_struct_Segment_storage_dyn_ptr(array, context)?;
            slot = add(dataArea, mul(index, U256::from(0x1u128), context)?, context)?;
            offset = U256::from(0x0u128);
            Ok((slot, offset))
        }

        pub fn read_from_memoryt_uint128<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint128(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_uint40<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint40(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_userDefinedValueType_UD2x18<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint64(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn convert_uint40_to_uint40<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint40(identity(cleanup_uint40(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn prepare_store_uint40<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left_192<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xc0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_24<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xc0u128), U256::from(0xffffffffffu128), context)?;
            toInsert = shift_left_192(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_24t_uint40_to_uint40<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint40_to_uint40(value, context)?;
            sstore(slot, update_byte_slice_shift_24(sload(slot, context)?, prepare_store_uint40(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn convert_uint128_to_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_uint128(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn prepare_store_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = U256::from(0xffffffffffffffffffffffffffffffffu128);
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint128_to_uint128<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint128_to_uint128(value, context)?;
            sstore(slot, update_byte_slice_shift(sload(slot, context)?, prepare_store_uint128(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_userDefinedValueType_UD2x18<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left_128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0x80u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_16<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0x80u128), U256::from(0xffffffffffffffffu128), context)?;
            toInsert = shift_left_128(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_userDefinedValueType_UD2x18_to_userDefinedValueType_UD2x18<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint64_to_uint64(value, context)?;
            sstore(slot, update_byte_slice_shift_16(sload(slot, context)?, prepare_store_userDefinedValueType_UD2x18(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn copy_struct_to_storage_from_struct_Segment_to_struct_Segment<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberSlot = add(slot, U256::from(0x0u128), context)?;
            let memberValue = read_from_memoryt_uint128(add(value, U256::from(0x0u128), context)?, context)?;
            update_storage_value_offsett_uint128_to_uint128(memberSlot, memberValue, context)?;
            let memberValue_1 = read_from_memoryt_userDefinedValueType_UD2x18(add(value, U256::from(0x20u128), context)?, context)?;
            update_storage_value_offsett_userDefinedValueType_UD2x18_to_userDefinedValueType_UD2x18(memberSlot, memberValue_1, context)?;
            let memberValue_2 = read_from_memoryt_uint40(add(value, U256::from(0x40u128), context)?, context)?;
            update_storage_value_offset_24t_uint40_to_uint40(memberSlot, memberValue_2, context)?;
            Ok(())
        }

        pub fn panic_error_0x00<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x0u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn update_storage_value_struct_Segment_to_struct_Segment<CI>(slot: U256, offset: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if offset != U256::ZERO {
                panic_error_0x00(context)?;
            }
            copy_struct_to_storage_from_struct_Segment_to_struct_Segment(slot, value, context)?;
            Ok(())
        }

        pub fn array_push_from_struct_Segment_to_array_struct_Segment_storage_dyn_ptr<CI>(array: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let oldLen = sload(array, context)?;
            if iszero(lt(oldLen, U256::from(0x10000000000000000u128), context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            sstore(array, add(oldLen, U256::from(0x1u128), context)?, context)?;
            let (slot, offset) = storage_array_index_access_struct_Segment__dyn_ptr(array, oldLen, context)?;
            update_storage_value_struct_Segment_to_struct_Segment(slot, offset, value0, context)?;
            Ok(())
        }

        pub fn storage_array_index_access_struct_Tranche__dyn_ptr<CI>(array: U256, index: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut slot = U256::ZERO;
            let mut offset = U256::ZERO;
            let arrayLength = array_length_array_struct_Tranche_storage_dyn_ptr(array, context)?;
            if iszero(lt(index, arrayLength, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let dataArea = array_dataslot_array_struct_Tranche_storage_dyn_ptr(array, context)?;
            slot = add(dataArea, mul(index, U256::from(0x1u128), context)?, context)?;
            offset = U256::from(0x0u128);
            Ok((slot, offset))
        }

        pub fn update_byte_slice_5_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0x80u128), U256::from(0xffffffffffu128), context)?;
            toInsert = shift_left_128(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_16t_uint40_to_uint40<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint40_to_uint40(value, context)?;
            sstore(slot, update_byte_slice_5_shift(sload(slot, context)?, prepare_store_uint40(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn copy_struct_to_storage_from_struct_Tranche_to_struct_Tranche<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberSlot = add(slot, U256::from(0x0u128), context)?;
            let memberValue = read_from_memoryt_uint128(add(value, U256::from(0x0u128), context)?, context)?;
            update_storage_value_offsett_uint128_to_uint128(memberSlot, memberValue, context)?;
            let memberValue_1 = read_from_memoryt_uint40(add(value, U256::from(0x20u128), context)?, context)?;
            update_storage_value_offset_16t_uint40_to_uint40(memberSlot, memberValue_1, context)?;
            Ok(())
        }

        pub fn update_storage_value_struct_Tranche_to_struct_Tranche<CI>(slot: U256, offset: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if offset != U256::ZERO {
                panic_error_0x00(context)?;
            }
            copy_struct_to_storage_from_struct_Tranche_to_struct_Tranche(slot, value, context)?;
            Ok(())
        }

        pub fn array_push_from_struct_Tranche_to_array_struct_Tranche_storage_dyn_ptr<CI>(array: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let oldLen = sload(array, context)?;
            if iszero(lt(oldLen, U256::from(0x10000000000000000u128), context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            sstore(array, add(oldLen, U256::from(0x1u128), context)?, context)?;
            let (slot, offset) = storage_array_index_access_struct_Tranche__dyn_ptr(array, oldLen, context)?;
            update_storage_value_struct_Tranche_to_struct_Tranche(slot, offset, value0, context)?;
            Ok(())
        }

        pub fn panic_error_0x01<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x1u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn assert_helper<CI>(condition: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(condition, context)? != U256::ZERO {
                panic_error_0x01(context)?;
            }
            Ok(())
        }

        pub fn calldata_array_index_access_bytes_calldata_dyn_calldata<CI>(base_ref: U256, length: U256, index: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            let mut len = U256::ZERO;
            if iszero(lt(index, length, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            addr = add(base_ref, mul(index, U256::from(0x20u128), context)?, context)?;
            (addr, len) = access_calldata_tail_bytes_calldata(base_ref, addr, context)?;
            Ok((addr, len))
        }

        pub fn calldata_array_index_access_uint128_dyn_calldata<CI>(base_ref: U256, length: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, length, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            addr = add(base_ref, mul(index, U256::from(0x20u128), context)?, context)?;
            Ok(addr)
        }

        pub fn calldata_array_index_access_uint256_dyn_calldata<CI>(base_ref: U256, length: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, length, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            addr = add(base_ref, mul(index, U256::from(0x20u128), context)?, context)?;
            Ok(addr)
        }

        pub fn panic_error_0x11<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_add_uint128<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            x = cleanup_uint128(x, context)?;
            y = cleanup_uint128(y, context)?;
            sum = add(x, y, context)?;
            if gt(sum, U256::from(0xffffffffffffffffffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn checked_add_uint40<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            x = cleanup_uint40(x, context)?;
            y = cleanup_uint40(y, context)?;
            sum = add(x, y, context)?;
            if gt(sum, U256::from(0xffffffffffu128), context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn checked_sub_uint128<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            x = cleanup_uint128(x, context)?;
            y = cleanup_uint128(y, context)?;
            diff = sub(x, y, context)?;
            if gt(diff, U256::from(0xffffffffffffffffffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(diff)
        }

        pub fn checked_sub_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            diff = sub(x, y, context)?;
            if gt(diff, x, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(diff)
        }

        pub fn cleanup_from_storage_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffu128), context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_enum_Model<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffu128), context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_uint40<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn cleanup_from_storage_userDefinedValueType_UD2x18<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn cleanup_rational_0_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1000000000000000000000000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1000000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_100000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1024_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1048576_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1073741824_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1095216660480_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1099511627776_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1125899906842624_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1152921504606846976_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_1225148678_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_128_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_131072_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_134217728_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_137438953472_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_140737488355328_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_144115188075855872_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16384_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16711680_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16777216_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_16_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_17179869184_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_17592186044416_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18014398509481984_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18374686479671623680_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551617_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551619_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551622_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551627_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551638_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551660_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551705_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551793_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709551971_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709552326_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709553036_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709554455_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709557294_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709562973_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709574329_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709597042_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709642468_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709733320_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073709915025_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073710278433_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073711005251_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073712458886_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073715366156_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073721180696_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073732809776_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073756067936_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073802584256_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744073895616895_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744074081682175_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744074453812734_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744075198073852_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744076686596088_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744079663640561_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744085617729507_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744097525907406_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744121342263227_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744168974974960_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744264240398796_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744454771247945_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446744835832952145_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446745597956384162_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446747122203342655_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446750170697637486_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446756267687738522_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446768461673986097_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446792849670663277_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446841625760745902_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18446939178327825412_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18447134285009651015_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18447524504564044946_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18448304968436414829_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18449865995240371898_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18452988445124272033_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18459234930309000272_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18471734244850835106_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18496758270674070881_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18546908069882975960_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18647615946650685159_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_18850675170876015534_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_191999999999999999999_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_191_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_19263451207323153962_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2000000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_20116317054877281742_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2048_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2097152_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2147483648_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_21936999301089678047_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2199023255552_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2251799813685248_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2305843009213693952_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_255_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_256_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_26087635650665564425_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_262144_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_268435456_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_274877906944_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_280375465082880_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_281474976710656_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_288230376151711744_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_2_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_3138550867693340381917894711603833208051177722232017256448_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_32768_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_32_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_33554432_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_34359738368_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_35184372088832_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_36028797018963968_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_3_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4194304_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4294967296_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4398046511104_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4503599627370496_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_4611686018427387904_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_500000000000000000_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_512_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_524288_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_536870912_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_549755813888_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_562949953421312_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_576460752303423488_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_64_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_65280_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_65536_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_67108864_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_68719476736_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_70368744177664_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_72057594037927936_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8192_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8388608_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8589934592_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8796093022208_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_8_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_9007199254740992_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_9223372036854775808_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_minus_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_minus_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by_1<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_minus_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_uint32<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn cleanup_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffu128), context)?;
            Ok(cleaned)
        }

        pub fn convert_rational_100000000000000000_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_100000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_MAX_BROKER_FEE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let expr = convert_rational_100000000000000000_by_1_to_uint256(U256::from(0x16345785d8a0000u128), context)?;
            ret = expr;
            Ok(ret)
        }

        pub fn constant_MAX_UINT128<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let expr = U256::from(0xffffffffffffffffffffffffffffffffu128);
            ret = expr;
            Ok(ret)
        }

        pub fn convert_rational_1000000000000000000_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_UNIT<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000000000000000_by_1_to_uint256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_1000000000000000000_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_1000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_UNIT_12224<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let expr = convert_rational_1000000000000000000_by_1_to_int256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = expr;
            Ok(ret)
        }

        pub fn convert_rational_0_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_ZERO<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let expr = convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?;
            ret = expr;
            Ok(ret)
        }

        pub fn convert_rational_191999999999999999999_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_191999999999999999999_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uEXP2_MAX_INPUT<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_191999999999999999999_by_1_to_int256(U256::from(0xa688906bd8affffffu128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_minus_59794705707972522261_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_minus_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uEXP2_MIN_THRESHOLD<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_minus_59794705707972522261_by_1_to_int256(not(U256::from(0x33dd1780914b97114u128), context)?, context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_500000000000000000_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_500000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uHALF_UNIT<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_500000000000000000_by_1_to_int256(U256::from(0x6f05b59d3b20000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uMAX_SD59x18<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_57896044618658097711785492504343953926634992332820282019728792003956564819967_by_1_to_int256(sub(shl(U256::from(0xffu128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_t_rational_minus_by_to_t_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_minus_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uMIN_SD59x18<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_t_rational_minus_by_to_t_int256(shl(U256::from(0xffu128), U256::from(0x1u128), context)?, context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn constant_uUNIT<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000000000000000_by_1_to_uint256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn constant_uUNIT_12217<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_1000000000000000000_by_1_to_int256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_by_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_1000000000000000000000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_uUNIT_SQUARED<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_by_to_int256(U256::from(0xc097ce7bc90715b34b9f1000000000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IERC721Receiver<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_IERC721Receiver<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IERC721Receiver(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_ISablierLockupRecipient<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_contract_ISablierLockupRecipient<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_ISablierLockupRecipient(value, context)?;
            Ok(converted)
        }

        pub fn convert_array_array_struct_SegmentWithDuration_calldata_dyn_calldata_to_array_struct_SegmentWithDuration_dyn<CI>(value: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_available_length_array_struct_SegmentWithDuration_dyn(value, length, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn convert_array_array_struct_Segment_calldata_dyn_calldata_to_array_struct_Segment_dyn<CI>(value: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_available_length_array_struct_Segment_dyn(value, length, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn convert_array_array_struct_Segment_storage_dyn_storage_to_array_struct_Segment__dyn_ptr<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = value;
            Ok(converted)
        }

        pub fn shift_right_0_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offsett_uint128<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint128(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_t_uint128<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_uint128(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn shift_right_192_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xc0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_24t_uint40<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint40(shift_right_192_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_t_uint40<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_24t_uint40(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn shift_right_128_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0x80u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offsett_userDefinedValueType_UD2x18<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_userDefinedValueType_UD2x18(shift_right_128_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_userDefinedValueType_UD2x18<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_userDefinedValueType_UD2x18(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn write_to_memory_uint128<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_uint40<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, cleanup_uint40(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_userDefinedValueType_UD2x18<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, cleanup_uint64(value, context)?, context)?;
            Ok(())
        }

        pub fn read_from_storage_reference_type_struct_Segment<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = allocate_memory_struct_struct_Segment(context)?;
            let memberValue = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint128(add(value, U256::from(0x0u128), context)?, memberValue, context)?;
            let memberValue_1 = read_from_storage_split_offset_userDefinedValueType_UD2x18(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_userDefinedValueType_UD2x18(add(value, U256::from(0x20u128), context)?, memberValue_1, context)?;
            let memberValue_2 = read_from_storage_split_offset_t_uint40(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint40(add(value, U256::from(0x40u128), context)?, memberValue_2, context)?;
            Ok(value)
        }

        pub fn convert_struct_Segment_storage_to_struct_Segment<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = read_from_storage_reference_type_struct_Segment(value, context)?;
            Ok(converted)
        }

        pub fn copy_array_from_storage_to_memory_array_struct_Segment__dyn<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let length = array_length_array_struct_Segment_storage_dyn(slot, context)?;
            memPtr = allocate_memory_array_array_struct_Segment_dyn(length, context)?;
            let mut mpos = memPtr;
            mpos = add(memPtr, U256::from(0x20u128), context)?;
            let mut spos = array_dataslot_array_struct_Segment_storage_dyn(slot, context)?;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    mstore(mpos, convert_struct_Segment_storage_to_struct_Segment(spos, context)?, context)?;
                    mpos = add(mpos, U256::from(0x20u128), context)?;
                    spos = add(spos, U256::from(0x1u128), context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            Ok(memPtr)
        }

        pub fn convert_array_array_struct_Segment_storage_dyn_to_array_struct_Segment_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_array_from_storage_to_memory_array_struct_Segment__dyn(value, context)?;
            Ok(converted)
        }

        pub fn convert_array_array_struct_TrancheWithDuration_calldata_dyn_calldata_to_array_struct_TrancheWithDuration_dyn<CI>(value: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_available_length_array_struct_TrancheWithDuration_dyn(value, length, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn convert_array_array_struct_Tranche_calldata_dyn_calldata_to_array_struct_Tranche_dyn<CI>(value: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_available_length_array_struct_Tranche_dyn(value, length, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn convert_array_array_struct_Tranche_storage_dyn_storage_to_array_struct_Tranche__dyn_ptr<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = value;
            Ok(converted)
        }

        pub fn extract_from_storage_value_offset_16t_uint40<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint40(shift_right_128_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_16_uint40<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_16t_uint40(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_reference_type_struct_Tranche<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = allocate_memory_struct_struct_Tranche(context)?;
            let memberValue = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint128(add(value, U256::from(0x0u128), context)?, memberValue, context)?;
            let memberValue_1 = read_from_storage_split_offset_16_uint40(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint40(add(value, U256::from(0x20u128), context)?, memberValue_1, context)?;
            Ok(value)
        }

        pub fn convert_struct_Tranche_storage_to_struct_Tranche<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = read_from_storage_reference_type_struct_Tranche(value, context)?;
            Ok(converted)
        }

        pub fn copy_array_from_storage_to_memory_array_struct_Tranche__dyn<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            let length = array_length_array_struct_Tranche_storage_dyn(slot, context)?;
            memPtr = allocate_memory_array_array_struct_Tranche_dyn(length, context)?;
            let mut mpos = memPtr;
            mpos = add(memPtr, U256::from(0x20u128), context)?;
            let mut spos = array_dataslot_array_struct_Tranche_storage_dyn(slot, context)?;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    mstore(mpos, convert_struct_Tranche_storage_to_struct_Tranche(spos, context)?, context)?;
                    mpos = add(mpos, U256::from(0x20u128), context)?;
                    spos = add(spos, U256::from(0x1u128), context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            Ok(memPtr)
        }

        pub fn convert_array_array_struct_Tranche_storage_dyn_to_array_struct_Tranche_dyn<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_array_from_storage_to_memory_array_struct_Tranche__dyn(value, context)?;
            Ok(converted)
        }

        pub fn convert_array_string_calldata_to_string<CI>(value: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_available_length_string(value, length, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn copy_array_from_storage_to_memory_string<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            let end_ = abi_encodeUpdatedPos_string_storage(slot, memPtr, context)?;
            finalize_allocation(memPtr, sub(end_, memPtr, context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_array_string_storage_to_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_array_from_storage_to_memory_string(value, context)?;
            Ok(converted)
        }

        pub fn convert_array_string_to_bytes<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = value;
            Ok(converted)
        }

        pub fn convert_bool_to_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_bool(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_Address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_Batch_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IERC20_to_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_IERC20(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_IERC721Receiver_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_contract_ILockupNFTDescriptor(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_ISablierLockupRecipient_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_NoDelegateCall_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_contract_SablierLockup_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn convert_enum_Model_to_enum_Model<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_enum_Model(value, context)?;
            Ok(converted)
        }

        pub fn convert_int256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_int256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_0_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1024_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1024_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1048576_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1048576_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1073741824_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1073741824_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1095216660480_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1095216660480_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1099511627776_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1099511627776_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1125899906842624_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1125899906842624_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1152921504606846976_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_1152921504606846976_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_128_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_128_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_131072_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_131072_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_134217728_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_134217728_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_137438953472_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_137438953472_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_140737488355328_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_140737488355328_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_144115188075855872_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_144115188075855872_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16384_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16384_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16711680_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16711680_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16777216_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16777216_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_16_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_16_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_17179869184_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_17179869184_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_17592186044416_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_17592186044416_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18014398509481984_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18014398509481984_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18374686479671623680_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18374686479671623680_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551617_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551617_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551619_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551619_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551622_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551622_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551627_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551627_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551638_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551638_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551660_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551660_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551705_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551705_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551793_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551793_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709551971_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709551971_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709552326_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709552326_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709553036_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709553036_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709554455_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709554455_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709557294_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709557294_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709562973_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709562973_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709574329_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709574329_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709597042_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709597042_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709642468_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709642468_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709733320_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709733320_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073709915025_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073709915025_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073710278433_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073710278433_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073711005251_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073711005251_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073712458886_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073712458886_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073715366156_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073715366156_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073721180696_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073721180696_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073732809776_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073732809776_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073756067936_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073756067936_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073802584256_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073802584256_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744073895616895_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744073895616895_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744074081682175_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744074081682175_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744074453812734_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744074453812734_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744075198073852_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744075198073852_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744076686596088_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744076686596088_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744079663640561_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744079663640561_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744085617729507_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744085617729507_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744097525907406_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744097525907406_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744121342263227_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744121342263227_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744168974974960_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744168974974960_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744264240398796_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744264240398796_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744454771247945_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744454771247945_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446744835832952145_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446744835832952145_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446745597956384162_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446745597956384162_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446747122203342655_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446747122203342655_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446750170697637486_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446750170697637486_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446756267687738522_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446756267687738522_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446768461673986097_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446768461673986097_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446792849670663277_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446792849670663277_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446841625760745902_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446841625760745902_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18446939178327825412_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18446939178327825412_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18447134285009651015_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18447134285009651015_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18447524504564044946_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18447524504564044946_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18448304968436414829_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18448304968436414829_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18449865995240371898_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18449865995240371898_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18452988445124272033_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18452988445124272033_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18459234930309000272_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18459234930309000272_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18471734244850835106_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18471734244850835106_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18496758270674070881_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18496758270674070881_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18546908069882975960_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18546908069882975960_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18647615946650685159_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18647615946650685159_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_18850675170876015534_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_18850675170876015534_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_191_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_191_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1_by_1_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_20116317054877281742_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_20116317054877281742_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2048_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2048_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2097152_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2097152_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2147483648_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2147483648_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_21936999301089678047_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_21936999301089678047_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2199023255552_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2199023255552_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2251799813685248_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2251799813685248_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2305843009213693952_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2305843009213693952_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_255_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_255_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_256_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_256_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_26087635650665564425_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_26087635650665564425_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_262144_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_262144_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_268435456_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_268435456_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_274877906944_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_274877906944_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_280375465082880_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_280375465082880_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_281474976710656_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_281474976710656_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_288230376151711744_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_288230376151711744_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_2_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_2_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_3138550867693340381917894711603833208051177722232017256448_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_3138550867693340381917894711603833208051177722232017256448_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_32768_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_32768_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_32_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_32_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_33554432_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_33554432_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_34359738368_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_34359738368_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_35184372088832_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_35184372088832_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_36028797018963968_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_36028797018963968_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_3_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_3_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4194304_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4194304_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4278190080_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4294967296_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4294967296_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4398046511104_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4398046511104_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4503599627370496_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4503599627370496_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4611686018427387904_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_4611686018427387904_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_4_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_512_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_512_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_524288_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_524288_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_536870912_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_536870912_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_549755813888_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_549755813888_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_562949953421312_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_562949953421312_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_576460752303423488_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_576460752303423488_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_64_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_64_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_65280_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_65280_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_65536_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_65536_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_67108864_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_67108864_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_68719476736_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_68719476736_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_70368744177664_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_70368744177664_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_71776119061217280_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_72057594037927936_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_72057594037927936_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8192_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8192_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8388608_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8388608_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8589934592_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8589934592_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8796093022208_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8796093022208_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_8_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_8_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_9007199254740992_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_9007199254740992_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_9223372036854775808_by_1_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_9223372036854775808_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_rational_by_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn shift_left_224<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn convert_rational_by_to_bytes4<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_bytes4(shift_left_224(cleanup_rational_1225148678_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_19263451207323153962_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint40<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint40(identity(cleanup_rational_0_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint8(identity(cleanup_rational_1_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_minus_by_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_t_rational_minus_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn copy_literal_to_memory_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_string(U256::from(0x0u128), context)?;
            Ok(memPtr)
        }

        pub fn convert_stringliteral_c5d2_to_bytes<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_literal_to_memory_c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470(context)?;
            Ok(converted)
        }

        pub fn extract_from_storage_value_offset_16t_uint128<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint128(shift_right_128_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_uint128<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_16t_uint128(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_reference_type_struct_Amounts<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = allocate_memory_struct_struct_Amounts(context)?;
            let memberValue = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint128(add(value, U256::from(0x0u128), context)?, memberValue, context)?;
            let memberValue_1 = read_from_storage_split_offset_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint128(add(value, U256::from(0x20u128), context)?, memberValue_1, context)?;
            let memberValue_2 = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x1u128), context)?, context)?;
            write_to_memory_uint128(add(value, U256::from(0x40u128), context)?, memberValue_2, context)?;
            Ok(value)
        }

        pub fn convert_struct_Amounts_storage_to_struct_Amounts<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = read_from_storage_reference_type_struct_Amounts(value, context)?;
            Ok(converted)
        }

        pub fn convert_struct_Broker_calldata_to_struct_Broker<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_struct_Broker(value, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn convert_struct_CreateWithTimestamps_calldata_to_struct_CreateWithTimestamps<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_struct_CreateWithTimestamps(value, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn convert_struct_UnlockAmounts_calldata_to_struct_UnlockAmounts<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = abi_decode_struct_UnlockAmounts(value, calldatasize(context)?, context)?;
            Ok(converted)
        }

        pub fn read_from_storage_reference_type_struct_UnlockAmounts<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = allocate_memory_struct_struct_UnlockAmounts(context)?;
            let memberValue = read_from_storage_split_offset_t_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint128(add(value, U256::from(0x0u128), context)?, memberValue, context)?;
            let memberValue_1 = read_from_storage_split_offset_uint128(add(slot, U256::from(0x0u128), context)?, context)?;
            write_to_memory_uint128(add(value, U256::from(0x20u128), context)?, memberValue_1, context)?;
            Ok(value)
        }

        pub fn convert_struct_UnlockAmounts_storage_to_struct_UnlockAmounts<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = read_from_storage_reference_type_struct_UnlockAmounts(value, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_rational_2000000000000000000_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint8(identity(cleanup_rational_64_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint128_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint128(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_int256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint128<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint40<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint40(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint32_to_bytes4<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_bytes4(shift_left_224(cleanup_uint32(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint40_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint40(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint64_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint64(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn update_byte_slice_16_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = not(U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            toInsert = shift_left_128(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint128_to_t_uint128<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint128_to_uint128(value, context)?;
            sstore(slot, update_byte_slice_16_shift(sload(slot, context)?, prepare_store_uint128(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn copy_struct_to_storage_from_struct_Amounts_to_struct_Amounts<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberSlot = add(slot, U256::from(0x0u128), context)?;
            let memberValue = read_from_memoryt_uint128(add(value, U256::from(0x0u128), context)?, context)?;
            update_storage_value_offsett_uint128_to_uint128(memberSlot, memberValue, context)?;
            let memberValue_1 = read_from_memoryt_uint128(add(value, U256::from(0x20u128), context)?, context)?;
            update_storage_value_offsett_uint128_to_t_uint128(memberSlot, memberValue_1, context)?;
            let memberValue_2 = read_from_memoryt_uint128(add(value, U256::from(0x40u128), context)?, context)?;
            update_storage_value_offsett_uint128_to_uint128(add(slot, U256::from(0x1u128), context)?, memberValue_2, context)?;
            Ok(())
        }

        pub fn read_from_memoryt_address<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_address(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_bool<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_bool(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_contract_IERC20<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_contract_IERC20(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_enum_Model<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_enum_Model(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_struct_Amounts<CI>(memPtr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = mload(memPtr, context)?;
            Ok(value)
        }

        pub fn shift_left_160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xa0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_20<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xa0u128), U256::from(0xffffffffffu128), context)?;
            toInsert = shift_left_160(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_20t_uint40_to_uint40<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint40_to_uint40(value, context)?;
            sstore(slot, update_byte_slice_shift_20(sload(slot, context)?, prepare_store_uint40(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left_168<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xa8u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_21<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xa8u128), U256::from(0xffu128), context)?;
            toInsert = shift_left_168(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_21t_bool_to_bool<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_bool_to_bool(value, context)?;
            sstore(slot, update_byte_slice_shift_21(sload(slot, context)?, prepare_store_bool(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn shift_left_176<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xb0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_22<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xb0u128), U256::from(0xffu128), context)?;
            toInsert = shift_left_176(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_22t_bool_to_bool<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_bool_to_bool(value, context)?;
            sstore(slot, update_byte_slice_shift_22(sload(slot, context)?, prepare_store_bool(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn shift_left_240<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xf0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_30<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xf0u128), U256::from(0xffu128), context)?;
            toInsert = shift_left_240(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_30t_bool_to_bool<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_bool_to_bool(value, context)?;
            sstore(slot, update_byte_slice_shift_30(sload(slot, context)?, prepare_store_bool(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn update_byte_slice_20_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_address_to_address<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_address_to_address(value, context)?;
            sstore(slot, update_byte_slice_20_shift(sload(slot, context)?, prepare_store_address(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn update_byte_slice_1_shift_20<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xa0u128), U256::from(0xffu128), context)?;
            toInsert = shift_left_160(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_bool_to_bool<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_bool_to_bool(value, context)?;
            sstore(slot, update_byte_slice_1_shift_20(sload(slot, context)?, prepare_store_bool(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn shift_left_248<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xf8u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_31<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xf8u128), U256::from(0xffu128), context)?;
            toInsert = shift_left_248(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_bool_to_t_bool<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_bool_to_bool(value, context)?;
            sstore(slot, update_byte_slice_shift_31(sload(slot, context)?, prepare_store_bool(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_contract_IERC20<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn update_storage_value_offsett_contract_IERC20_to_contract_IERC20<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_contract_IERC20_to_contract_IERC20(value, context)?;
            sstore(slot, update_byte_slice_20_shift(sload(slot, context)?, prepare_store_contract_IERC20(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_enum_Model<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left_184<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xb8u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_23<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xb8u128), U256::from(0xffu128), context)?;
            toInsert = shift_left_184(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_enum_Model_to_enum_Model<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_enum_Model_to_enum_Model(value, context)?;
            sstore(slot, update_byte_slice_shift_23(sload(slot, context)?, prepare_store_enum_Model(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn update_storage_value_offsett_struct_Amounts_to_struct_Amounts<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            copy_struct_to_storage_from_struct_Amounts_to_struct_Amounts(slot, value, context)?;
            Ok(())
        }

        pub fn shift_left_200<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0xc8u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift_25<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = shl(U256::from(0xc8u128), U256::from(0xffffffffffu128), context)?;
            toInsert = shift_left_200(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint40_to_t_uint40<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint40_to_uint40(value, context)?;
            sstore(slot, update_byte_slice_shift_25(sload(slot, context)?, prepare_store_uint40(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn copy_struct_to_storage_from_struct_Stream_to_struct_Stream<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let memberSlot = add(slot, U256::from(0x0u128), context)?;
            let memberValue = read_from_memoryt_address(add(value, U256::from(0x0u128), context)?, context)?;
            update_storage_value_offsett_address_to_address(memberSlot, memberValue, context)?;
            let memberValue_1 = read_from_memoryt_uint40(add(value, U256::from(0x20u128), context)?, context)?;
            update_storage_value_offset_20t_uint40_to_uint40(memberSlot, memberValue_1, context)?;
            let memberValue_2 = read_from_memoryt_uint40(add(value, U256::from(0x40u128), context)?, context)?;
            update_storage_value_offsett_uint40_to_t_uint40(memberSlot, memberValue_2, context)?;
            let memberValue_3 = read_from_memoryt_bool(add(value, U256::from(0x60u128), context)?, context)?;
            update_storage_value_offset_30t_bool_to_bool(memberSlot, memberValue_3, context)?;
            let memberValue_4 = read_from_memoryt_bool(add(value, U256::from(0x80u128), context)?, context)?;
            update_storage_value_offsett_bool_to_t_bool(memberSlot, memberValue_4, context)?;
            let memberSlot_1 = add(slot, U256::from(0x1u128), context)?;
            let memberValue_5 = read_from_memoryt_contract_IERC20(add(value, U256::from(0xa0u128), context)?, context)?;
            update_storage_value_offsett_contract_IERC20_to_contract_IERC20(memberSlot_1, memberValue_5, context)?;
            let memberValue_6 = read_from_memoryt_bool(add(value, U256::from(0xc0u128), context)?, context)?;
            update_storage_value_offsett_bool_to_bool(memberSlot_1, memberValue_6, context)?;
            let memberValue_7 = read_from_memoryt_bool(add(value, U256::from(0xe0u128), context)?, context)?;
            update_storage_value_offset_21t_bool_to_bool(memberSlot_1, memberValue_7, context)?;
            let memberValue_8 = read_from_memoryt_bool(add(value, U256::from(0x100u128), context)?, context)?;
            update_storage_value_offset_22t_bool_to_bool(memberSlot_1, memberValue_8, context)?;
            let memberValue_9 = read_from_memoryt_enum_Model(add(value, U256::from(0x120u128), context)?, context)?;
            update_storage_value_offsett_enum_Model_to_enum_Model(memberSlot_1, memberValue_9, context)?;
            let memberValue_10 = read_from_memoryt_struct_Amounts(add(value, U256::from(0x140u128), context)?, context)?;
            update_storage_value_offsett_struct_Amounts_to_struct_Amounts(add(slot, U256::from(0x2u128), context)?, memberValue_10, context)?;
            Ok(())
        }

        pub fn getter_fun_MAX_BROKER_FEE<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = constant_MAX_BROKER_FEE(context)?;
            Ok(ret)
        }

        pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn external_fun_MAX_BROKER_FEE<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_MAX_BROKER_FEE(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_userDefinedValueType_UD60x18(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn getter_fun_MAX_COUNT<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut rval = U256::ZERO;
            rval = loadimmutable(from_hex("3433000000000000000000000000000000000000000000000000000000000000"), context)?;
            Ok(rval)
        }

        pub fn external_fun_MAX_COUNT<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_MAX_COUNT(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn shift_right_unsigned_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(bits, value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_dynamict_address<CI>(slot_value: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_address(shift_right_unsigned_dynamic(mul(offset, U256::from(0x8u128), context)?, slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_dynamic_address<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_dynamict_address(sload(slot, context)?, offset, context)?;
            Ok(value)
        }

        pub fn getter_fun_admin<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = read_from_storage_split_dynamic_address(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_admin<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_admin(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_address(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn mapping_index_access_mapping_address_bool_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn revert_forward<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let pos = allocate_unbounded(context)?;
            returndatacopy(pos, U256::from(0x0u128), returndatasize(context)?, context)?;
            revert(pos, returndatasize(context)?, context)?;
            Ok(())
        }

        pub fn update_byte_slice_1_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(U256::from(0xffu128), context)?, context)?;
            result = or(value, and(toInsert, U256::from(0xffu128), context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_0t_bool_to_bool<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_bool_to_bool(value, context)?;
            sstore(slot, update_byte_slice_1_shift(sload(slot, context)?, prepare_store_bool(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn fun_allowToHook_inner<CI>(var_recipient: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = extcodesize(var_recipient, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x65453b0du128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_recipient, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = shl(U256::from(0xe0u128), U256::from(0xf8ee98d3u128), context)?;
            let expr_3153_address = convert_address_to_contract_ISablierLockupRecipient(var_recipient, context)?;
            let expr_3154_address = convert_contract_ISablierLockupRecipient_to_address(expr_3153_address, context)?;
            let _2 = allocate_unbounded(context)?;
            mstore(_2, shift_left_224(U256::from(0x1ffc9a7u128), context)?, context)?;
            let _3 = abi_encode_tuple_bytes4(add(_2, U256::from(0x4u128), context)?, expr_2, context)?;
            let _4 = staticcall(gas(context)?, expr_3154_address, _2, sub(_3, _2, context)?, _2, U256::from(0x20u128), context)?;
            if iszero(_4, context)? != U256::ZERO {
                revert_forward(context)?;
            }
            let mut expr_3 = U256::ZERO;
            if _4 != U256::ZERO {
                let mut _5 = U256::from(0x20u128);
                if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                    _5 = returndatasize(context)?;
                }
                finalize_allocation(_2, _5, context)?;
                expr_3 = abi_decode_bool_fromMemory(_2, add(_2, _5, context)?, context)?;
            }
            let expr_4 = cleanup_bool(iszero(expr_3, context)?, context)?;
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x25db0359u128), context)?, context)?;
                let _6 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_recipient, context)?;
                revert(U256::from(0x0u128), sub(_6, U256::from(0x0u128), context)?, context)?;
            }
            let _7 = mapping_index_access_mapping_address_bool_of_address(U256::from(0x9u128), var_recipient, context)?;
            update_storage_value_offset_0t_bool_to_bool(_7, U256::from(0x1u128), context)?;
            let _8 = convert_address_to_address(caller(context)?, context)?;
            let _9 = allocate_unbounded(context)?;
            let _10 = abi_encode_tuple_address(_9, var_recipient, context)?;
            log2(_9, sub(_10, _9, context)?, U256::from_be_slice(&[0xb4, 0x37, 0x8d, 0x4e, 0x28, 0x9c, 0xb3, 0xf4, 0x0f, 0x4f, 0x75, 0xa9, 0x9c, 0x9c, 0xaf, 0xa7, 0x6e, 0x3d, 0xf1, 0xc4, 0xdc, 0x31, 0x30, 0x9b, 0xab, 0xc2, 0x3d, 0xc9, 0x1b, 0xd7, 0x28, 0x01]), _8, context)?;
            Ok(())
        }

        pub fn extract_from_storage_value_offsett_address<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_address(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_address<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_address(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn modifier_onlyAdmin_3129<CI>(var_recipient: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = iszero(eq(cleanup_address(_1, context)?, cleanup_address(caller(context)?, context)?, context)?, context)?;
            if expr != U256::ZERO {
                let _2 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x31b339a9u128), context)?, context)?;
                let _3 = abi_encode_address_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _2, caller(context)?, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            fun_allowToHook_inner(var_recipient, context)?;
            Ok(())
        }

        pub fn fun_allowToHook<CI>(var_recipient: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyAdmin_3129(var_recipient, context)?;
            Ok(())
        }

        pub fn external_fun_allowToHook<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_allowToHook(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn mapping_index_access_mapping_address_mapping_address_bool_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn extract_from_storage_value_offset_0t_bool<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_0_bool<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_0t_bool(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn zero_value_for_split_bool<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_isApprovedForAll<CI>(var_owner: U256, var_operator: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let _1 = mapping_index_access_mapping_address_mapping_address_bool_of_address(U256::from(0x6u128), var_owner, context)?;
            let _2 = mapping_index_access_mapping_address_bool_of_address(_1, var_operator, context)?;
            let _3 = read_from_storage_split_offset_0_bool(_2, context)?;
            var = _3;
            Ok(var)
        }

        pub fn mapping_index_access_mapping_uint256_address_of_uint256<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_uint256_to_uint256(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn zero_value_for_split_address<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun__ownerOf<CI>(var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_address = zero_value_for_split_address(context)?;
            var = zero_t_address;
            let _1 = mapping_index_access_mapping_uint256_address_of_uint256(U256::from(0x3u128), var_tokenId, context)?;
            let _2 = read_from_storage_split_offset_address(_1, context)?;
            var = _2;
            Ok(var)
        }

        pub fn fun_requireOwned<CI>(var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            let expr = fun__ownerOf(var_tokenId, context)?;
            let expr_1 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_2 = eq(cleanup_address(expr, context)?, cleanup_address(expr_1, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7e273289u128), context)?, context)?;
                let _1 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_tokenId, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            var = expr;
            Ok(var)
        }

        pub fn fun_approve_2360<CI>(var_to: U256, var_tokenId: U256, var_auth: U256, var_emitEvent: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let mut expr = var_emitEvent;
            if iszero(var_emitEvent, context)? != U256::ZERO {
                let expr_1 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
                let expr_2 = iszero(eq(cleanup_address(var_auth, context)?, cleanup_address(expr_1, context)?, context)?, context)?;
                expr = expr_2;
            }
            if expr != U256::ZERO {
                let expr_3 = fun_requireOwned(var_tokenId, context)?;
                let expr_4 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
                let expr_5 = iszero(eq(cleanup_address(var_auth, context)?, cleanup_address(expr_4, context)?, context)?, context)?;
                let mut expr_6 = expr_5;
                if expr_5 != U256::ZERO {
                    let expr_7 = iszero(eq(cleanup_address(expr_3, context)?, cleanup_address(var_auth, context)?, context)?, context)?;
                    expr_6 = expr_7;
                }
                let mut expr_8 = expr_6;
                if expr_6 != U256::ZERO {
                    let expr_9 = fun_isApprovedForAll(expr_3, var_auth, context)?;
                    let expr_10 = cleanup_bool(iszero(expr_9, context)?, context)?;
                    expr_8 = expr_10;
                }
                if expr_8 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xa9fbf51fu128), context)?, context)?;
                    let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_auth, context)?;
                    revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
                }
                if var_emitEvent != U256::ZERO {
                    let _2 = convert_address_to_address(expr_3, context)?;
                    let _3 = convert_address_to_address(var_to, context)?;
                    let _4 = convert_uint256_to_uint256(var_tokenId, context)?;
                    let _5 = allocate_unbounded(context)?;
                    let _6 = abi_encode_tuple(_5, context)?;
                    log4(_5, sub(_6, _5, context)?, U256::from_be_slice(&[0x8c, 0x5b, 0xe1, 0xe5, 0xeb, 0xec, 0x7d, 0x5b, 0xd1, 0x4f, 0x71, 0x42, 0x7d, 0x1e, 0x84, 0xf3, 0xdd, 0x03, 0x14, 0xc0, 0xf7, 0xb2, 0x29, 0x1e, 0x5b, 0x20, 0x0a, 0xc8, 0xc7, 0xc3, 0xb9, 0x25]), _2, _3, _4, context)?;
                }
            }
            let _7 = mapping_index_access_mapping_uint256_address_of_uint256(U256::from(0x5u128), var_tokenId, context)?;
            update_storage_value_offsett_address_to_address(_7, var_to, context)?;
            Ok(())
        }

        pub fn fun__approve<CI>(var_to: U256, var_tokenId: U256, var_auth: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_approve_2360(var_to, var_tokenId, var_auth, U256::from(0x1u128), context)?;
            Ok(())
        }

        pub fn fun_msgSender<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            var = caller(context)?;
            Ok(var)
        }

        pub fn fun_approve<CI>(var_to: U256, var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_msgSender(context)?;
            fun__approve(var_to, var_tokenId, expr, context)?;
            Ok(())
        }

        pub fn external_fun_approve<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_approve(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn mapping_index_access_mapping_address_uint256_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn extract_from_storage_value_offsett_uint256<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint256(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_uint256<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_uint256(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_balanceOf<CI>(var_owner: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_owner, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x22718ad9u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let _2 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x4u128), var_owner, context)?;
            let _3 = read_from_storage_split_offset_uint256(_2, context)?;
            var = _3;
            Ok(var)
        }

        pub fn external_fun_balanceOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_balanceOf(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_bytes<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn extract_returndata<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            // switch
            let δ = returndatasize(context)?;
            if δ == U256::from(0x0u128) {
                data = zero_value_for_split_bytes(context)?;
            }
            Ok(data)
        }

        pub fn increment_wrapping_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = cleanup_uint256(add(value, U256::from(0x1u128), context)?, context)?;
            Ok(ret)
        }

        pub fn memory_array_index_access_bytes_dyn<CI>(baseRef: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_bytes_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn zero_value_for_split_array_bytes_dyn<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_batch<CI>(var_calls_offset: U256, var_calls_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_results_mpos = U256::ZERO;
            let zero_array_bytes_dyn_mpos = zero_value_for_split_array_bytes_dyn(context)?;
            var_results_mpos = zero_array_bytes_dyn_mpos;
            let expr = array_length_array_bytes_calldata_dyn_calldata(var_calls_offset, var_calls_length, context)?;
            let expr_7511_mpos = allocate_and_zero_memory_array_array_bytes_dyn(expr, context)?;
            var_results_mpos = expr_7511_mpos;
            let mut var_i = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_1 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_1, context)? != U256::ZERO {
                        break;
                    }
                    let expr_2 = convert_contract_Batch_to_address(address(context)?, context)?;
                    let (expr_offset, expr_7535_length) = calldata_array_index_access_bytes_calldata_dyn_calldata(var_calls_offset, var_calls_length, var_i, context)?;
                    let _2 = allocate_unbounded(context)?;
                    let _3 = sub(abi_encode_packed_bytes_calldata(_2, expr_offset, expr_7535_length, context)?, _2, context)?;
                    let expr_component = delegatecall(gas(context)?, expr_2, _2, _3, U256::from(0x0u128), U256::from(0x0u128), context)?;
                    let expr_7536_component_2_mpos = extract_returndata(context)?;
                    let expr_3 = cleanup_bool(iszero(expr_component, context)?, context)?;
                    if expr_3 != U256::ZERO {
                        let ᵤresultSize = mload(expr_7536_component_2_mpos, context)?;
                        revert(add(U256::from(0x20u128), expr_7536_component_2_mpos, context)?, ᵤresultSize, context)?;
                    }
                    mstore(memory_array_index_access_bytes_dyn(expr_7511_mpos, var_i, context)?, expr_7536_component_2_mpos, context)?;
                    pop(mload(memory_array_index_access_bytes_dyn(expr_7511_mpos, var_i, context)?, context)?, context)?;
                }
                // post
                {
                    let _1 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _1;
                }
            }
            Ok(var_results_mpos)
        }

        pub fn external_fun_batch<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1) = abi_decode_array_bytes_calldata_dyn_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_batch(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_array_bytes_memory_ptr_dyn_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_preventDelegateCall<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_contract_NoDelegateCall_to_address(address(context)?, context)?;
            let _1 = loadimmutable(from_hex("3735363100000000000000000000000000000000000000000000000000000000"), context)?;
            let expr_1 = iszero(eq(cleanup_address(expr, context)?, cleanup_address(_1, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xa1c0d6e5u128), context)?, context)?;
                let _2 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun__getApproved<CI>(var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            let _1 = mapping_index_access_mapping_uint256_address_of_uint256(U256::from(0x5u128), var_tokenId, context)?;
            let _2 = read_from_storage_split_offset_address(_1, context)?;
            var = _2;
            Ok(var)
        }

        pub fn fun_isAuthorized<CI>(var_owner: U256, var_spender: U256, var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = iszero(eq(cleanup_address(var_spender, context)?, cleanup_address(expr, context)?, context)?, context)?;
            let mut expr_2 = expr_1;
            if expr_1 != U256::ZERO {
                let expr_3 = eq(cleanup_address(var_owner, context)?, cleanup_address(var_spender, context)?, context)?;
                let mut expr_4 = expr_3;
                if iszero(expr_3, context)? != U256::ZERO {
                    let expr_5 = fun_isApprovedForAll(var_owner, var_spender, context)?;
                    expr_4 = expr_5;
                }
                let mut expr_6 = expr_4;
                if iszero(expr_4, context)? != U256::ZERO {
                    let expr_7 = fun__getApproved(var_tokenId, context)?;
                    let expr_8 = eq(cleanup_address(expr_7, context)?, cleanup_address(var_spender, context)?, context)?;
                    expr_6 = expr_8;
                }
                expr_2 = expr_6;
            }
            var = expr_2;
            Ok(var)
        }

        pub fn fun_checkAuthorized<CI>(var_owner: U256, var_spender: U256, var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_isAuthorized(var_owner, var_spender, var_tokenId, context)?;
            let expr_1 = cleanup_bool(iszero(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                let expr_2 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
                let expr_3 = eq(cleanup_address(var_owner, context)?, cleanup_address(expr_2, context)?, context)?;
                // switch
                let δ = expr_3;
                if δ == U256::from(0x0u128) {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x177e802fu128), context)?, context)?;
                    let _1 = abi_encode_address_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_spender, var_tokenId, context)?;
                    revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
                }
            }
            Ok(())
        }

        pub fn prepare_store_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn update_byte_slice_shift_0<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = not(U256::from(0x0u128), context)?;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint256_to_uint256<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint256_to_uint256(value, context)?;
            sstore(slot, update_byte_slice_shift_0(sload(slot, context)?, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn wrapping_add_uint256<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            sum = cleanup_uint256(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn wrapping_sub_uint256<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            diff = cleanup_uint256(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn fun__update<CI>(var_to: U256, var_tokenId: U256, var_auth: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            let expr = fun__ownerOf(var_tokenId, context)?;
            let expr_1 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_2 = iszero(eq(cleanup_address(var_auth, context)?, cleanup_address(expr_1, context)?, context)?, context)?;
            if expr_2 != U256::ZERO {
                fun_checkAuthorized(expr, var_auth, var_tokenId, context)?;
            }
            let expr_3 = iszero(eq(cleanup_address(expr, context)?, cleanup_address(expr_1, context)?, context)?, context)?;
            if expr_3 != U256::ZERO {
                fun_approve_2360(expr_1, var_tokenId, expr_1, U256::from(0x0u128), context)?;
                let _1 = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
                let _2 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x4u128), expr, context)?;
                let _3 = read_from_storage_split_offset_uint256(_2, context)?;
                let expr_4 = wrapping_sub_uint256(_3, _1, context)?;
                update_storage_value_offsett_uint256_to_uint256(_2, expr_4, context)?;
            }
            let expr_5 = iszero(eq(cleanup_address(var_to, context)?, cleanup_address(expr_1, context)?, context)?, context)?;
            if expr_5 != U256::ZERO {
                let _4 = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
                let _5 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x4u128), var_to, context)?;
                let _6 = read_from_storage_split_offset_uint256(_5, context)?;
                let expr_6 = wrapping_add_uint256(_6, _4, context)?;
                update_storage_value_offsett_uint256_to_uint256(_5, expr_6, context)?;
            }
            let _7 = mapping_index_access_mapping_uint256_address_of_uint256(U256::from(0x3u128), var_tokenId, context)?;
            update_storage_value_offsett_address_to_address(_7, var_to, context)?;
            let _8 = convert_address_to_address(expr, context)?;
            let _9 = convert_address_to_address(var_to, context)?;
            let _10 = convert_uint256_to_uint256(var_tokenId, context)?;
            let _11 = allocate_unbounded(context)?;
            let _12 = abi_encode_tuple(_11, context)?;
            log4(_11, sub(_12, _11, context)?, U256::from_be_slice(&[0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b, 0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa, 0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16, 0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef]), _8, _9, _10, context)?;
            var = expr;
            Ok(var)
        }

        pub fn mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_uint256_to_uint256(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn shift_right_176_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xb0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_22t_bool<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_176_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_22_bool<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_22t_bool(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn fun_update<CI>(var_to: U256, var_streamId: U256, var_auth: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            let expr = fun__ownerOf(var_streamId, context)?;
            let expr_1 = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_2 = iszero(eq(cleanup_address(expr, context)?, cleanup_address(expr_1, context)?, context)?, context)?;
            let mut expr_3 = expr_2;
            if expr_2 != U256::ZERO {
                let expr_4 = iszero(eq(cleanup_address(var_to, context)?, cleanup_address(expr_1, context)?, context)?, context)?;
                expr_3 = expr_4;
            }
            let mut expr_5 = expr_3;
            if expr_3 != U256::ZERO {
                let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
                let _2 = read_from_storage_split_offset_22_bool(add(_1, U256::from(0x1u128), context)?, context)?;
                let expr_6 = cleanup_bool(iszero(_2, context)?, context)?;
                expr_5 = expr_6;
            }
            if expr_5 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x49d74b11u128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let _4 = allocate_unbounded(context)?;
            let _5 = abi_encode_uint256(_4, var_streamId, context)?;
            log1(_4, sub(_5, _4, context)?, U256::from_be_slice(&[0xf8, 0xe1, 0xa1, 0x5a, 0xba, 0x93, 0x98, 0xe0, 0x19, 0xf0, 0xb4, 0x9d, 0xf1, 0xa4, 0xfd, 0xe9, 0x8e, 0xe1, 0x7a, 0xe3, 0x45, 0xcb, 0x5f, 0x6b, 0x5e, 0x2c, 0x27, 0xf5, 0x03, 0x3e, 0x8c, 0xe7]), context)?;
            let expr_7 = fun__update(var_to, var_streamId, var_auth, context)?;
            var = expr_7;
            Ok(var)
        }

        pub fn fun__burn<CI>(var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = fun_update(expr, var_tokenId, expr, context)?;
            let expr_2 = eq(cleanup_address(expr_1, context)?, cleanup_address(expr, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7e273289u128), context)?, context)?;
                let _1 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_tokenId, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_getApproved<CI>(var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            pop(fun_requireOwned(var_tokenId, context)?, context)?;
            let expr = fun__getApproved(var_tokenId, context)?;
            var = expr;
            Ok(var)
        }

        pub fn fun_isCallerStreamRecipientOrApproved<CI>(var_streamId: U256, var_recipient: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_bool = zero_value_for_split_bool(context)?;
            var = zero_t_bool;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(var_recipient, context)?, context)?;
            let mut expr_1 = expr;
            if iszero(expr, context)? != U256::ZERO {
                let expr_2 = fun_isApprovedForAll(var_recipient, caller(context)?, context)?;
                expr_1 = expr_2;
            }
            let mut expr_3 = expr_1;
            if iszero(expr_1, context)? != U256::ZERO {
                let expr_4 = fun_getApproved(var_streamId, context)?;
                let expr_5 = eq(cleanup_address(expr_4, context)?, cleanup_address(caller(context)?, context)?, context)?;
                expr_3 = expr_5;
            }
            var = expr_3;
            Ok(var)
        }

        pub fn shift_right_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xa0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_20t_bool<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_t_bool<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_20t_bool(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn fun_burn_inner<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_t_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x535d196du128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let expr_1 = fun__ownerOf(var_streamId, context)?;
            let expr_2 = fun_isCallerStreamRecipientOrApproved(var_streamId, expr_1, context)?;
            let expr_3 = cleanup_bool(iszero(expr_2, context)?, context)?;
            if expr_3 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4dda2c39u128), context)?, context)?;
                let _4 = abi_encode_uint256_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, caller(context)?, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            fun__burn(var_streamId, context)?;
            Ok(())
        }

        pub fn shift_right_168_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xa8u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_21t_bool<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_168_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_bool<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_21t_bool(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn modifier_notNull_3191<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            fun_burn_inner(var_streamId, context)?;
            Ok(())
        }

        pub fn modifier_noDelegateCall_3188<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_preventDelegateCall(context)?;
            modifier_notNull_3191(var_streamId, context)?;
            Ok(())
        }

        pub fn fun_burn<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_noDelegateCall_3188(var_streamId, context)?;
            Ok(())
        }

        pub fn external_fun_burn<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_burn(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn panic_error_0x12<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x12u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn wrapping_div_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut r = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            if iszero(y, context)? != U256::ZERO {
                panic_error_0x12(context)?;
            }
            r = div(x, y, context)?;
            Ok(r)
        }

        pub fn wrapping_mul_uint256<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut product = U256::ZERO;
            product = cleanup_uint256(mul(x, y, context)?, context)?;
            Ok(product)
        }

        pub fn fun_mulDiv<CI>(var_x: U256, var_y: U256, mut var_denominator: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let mut var_prod0 = U256::ZERO;
            var_prod0 = zero_uint256;
            let mut var_prod1 = U256::ZERO;
            var_prod1 = zero_uint256;
            let ᵤmm = mulmod(var_x, var_y, not(U256::from(0x0u128), context)?, context)?;
            var_prod0 = mul(var_x, var_y, context)?;
            var_prod1 = sub(sub(ᵤmm, var_prod0, context)?, lt(ᵤmm, var_prod0, context)?, context)?;
            let expr = eq(cleanup_uint256(var_prod1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                let expr_1 = wrapping_div_uint256(var_prod0, var_denominator, context)?;
                var_result = expr_1;
                return Ok(var_result);
            }
            let expr_2 = iszero(lt(cleanup_uint256(var_prod1, context)?, cleanup_uint256(var_denominator, context)?, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0xc740aefu128), context)?, context)?;
                let _1 = abi_encode_uint256_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, var_denominator, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_remainder = U256::ZERO;
            var_remainder = zero_uint256;
            var_remainder = mulmod(var_x, var_y, var_denominator, context)?;
            var_prod1 = sub(var_prod1, gt(var_remainder, var_prod0, context)?, context)?;
            var_prod0 = sub(var_prod0, var_remainder, context)?;
            let expr_3 = cleanup_uint256(not(var_denominator, context)?, context)?;
            let expr_4 = wrapping_add_uint256(expr_3, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let expr_5 = and(var_denominator, expr_4, context)?;
            let mut var_flippedLpotdod = U256::ZERO;
            var_flippedLpotdod = zero_uint256;
            var_denominator = div(var_denominator, expr_5, context)?;
            var_prod0 = div(var_prod0, expr_5, context)?;
            var_flippedLpotdod = add(div(sub(U256::from(0x0u128), expr_5, context)?, expr_5, context)?, U256::from(0x1u128), context)?;
            let expr_6 = wrapping_mul_uint256(var_prod1, var_flippedLpotdod, context)?;
            let expr_7 = or(var_prod0, expr_6, context)?;
            var_prod0 = expr_7;
            let expr_8 = wrapping_mul_uint256(convert_rational_3_by_1_to_uint256(U256::from(0x3u128), context)?, var_denominator, context)?;
            let expr_9 = U256::from(0x2u128);
            let expr_10 = xor(expr_8, convert_rational_2_by_1_to_uint256(expr_9, context)?, context)?;
            let mut var_inverse = expr_10;
            let expr_11 = wrapping_mul_uint256(var_denominator, expr_10, context)?;
            let expr_12 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_11, context)?;
            let expr_13 = wrapping_mul_uint256(expr_10, expr_12, context)?;
            var_inverse = expr_13;
            let expr_14 = wrapping_mul_uint256(var_denominator, expr_13, context)?;
            let expr_15 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_14, context)?;
            let expr_16 = wrapping_mul_uint256(expr_13, expr_15, context)?;
            var_inverse = expr_16;
            let expr_17 = wrapping_mul_uint256(var_denominator, expr_16, context)?;
            let expr_18 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_17, context)?;
            let expr_19 = wrapping_mul_uint256(expr_16, expr_18, context)?;
            var_inverse = expr_19;
            let expr_20 = wrapping_mul_uint256(var_denominator, expr_19, context)?;
            let expr_21 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_20, context)?;
            let expr_22 = wrapping_mul_uint256(expr_19, expr_21, context)?;
            var_inverse = expr_22;
            let expr_23 = wrapping_mul_uint256(var_denominator, expr_22, context)?;
            let expr_24 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_23, context)?;
            let expr_25 = wrapping_mul_uint256(expr_22, expr_24, context)?;
            var_inverse = expr_25;
            let expr_26 = wrapping_mul_uint256(var_denominator, expr_25, context)?;
            let expr_27 = wrapping_sub_uint256(convert_rational_2_by_1_to_uint256(expr_9, context)?, expr_26, context)?;
            let expr_28 = wrapping_mul_uint256(expr_25, expr_27, context)?;
            var_inverse = expr_28;
            let expr_29 = wrapping_mul_uint256(expr_7, expr_28, context)?;
            var_result = expr_29;
            Ok(var_result)
        }

        pub fn zero_value_for_split_int256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_unwrap_12049<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_t_int256 = zero_value_for_split_int256(context)?;
            var_result = zero_t_int256;
            let expr = convert_int256_to_int256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn zero_value_for_split_userDefinedValueType_SD59x18<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_wrap<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_int256_to_int256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn negate_wrapping_int256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = cleanup_int256(sub(U256::from(0x0u128), value, context)?, context)?;
            Ok(ret)
        }

        pub fn fun_div_13325<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12049(var_x, context)?;
            let expr_1 = fun_unwrap_12049(var_y, context)?;
            let expr_2 = constant_uMIN_SD59x18(context)?;
            let expr_3 = eq(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?;
            let mut expr_4 = expr_3;
            if iszero(expr_3, context)? != U256::ZERO {
                let expr_5 = eq(cleanup_int256(expr_1, context)?, cleanup_int256(expr_2, context)?, context)?;
                expr_4 = expr_5;
            }
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe4u128), U256::from(0x9fe2b45u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_xAbs = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_xAbs = zero_uint256;
            let mut var_yAbs = U256::ZERO;
            var_yAbs = zero_uint256;
            let expr_6 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_7 = U256::ZERO;
            // switch
            let δ = expr_6;
            if δ == U256::from(0x0u128) {
                let expr_8 = convert_int256_to_uint256(expr, context)?;
                expr_7 = expr_8;
            }
            var_xAbs = expr_7;
            let expr_11 = slt(cleanup_int256(expr_1, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_12 = U256::ZERO;
            // switch
            let δ = expr_11;
            if δ == U256::from(0x0u128) {
                let expr_13 = convert_int256_to_uint256(expr_1, context)?;
                expr_12 = expr_13;
            }
            var_yAbs = expr_12;
            let expr_16 = constant_uUNIT_12217(context)?;
            let expr_17 = convert_int256_to_uint256(expr_16, context)?;
            let expr_18 = fun_mulDiv(expr_7, expr_17, expr_12, context)?;
            let expr_19 = constant_uMAX_SD59x18(context)?;
            let expr_20 = convert_int256_to_uint256(expr_19, context)?;
            let expr_21 = gt(cleanup_uint256(expr_18, context)?, cleanup_uint256(expr_20, context)?, context)?;
            if expr_21 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xd49c26b3u128), context)?, context)?;
                let _2 = abi_encode_userDefinedValueType_SD59x18_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let expr_22 = xor(expr, expr_1, context)?;
            let expr_23 = sgt(cleanup_int256(expr_22, context)?, convert_rational_minus_by_to_int256(not(U256::from(0x0u128), context)?, context)?, context)?;
            let mut expr_24 = U256::ZERO;
            // switch
            let δ = expr_23;
            if δ == U256::from(0x0u128) {
                let expr_25 = convert_uint256_to_int256(expr_18, context)?;
                let expr_26 = negate_wrapping_int256(expr_25, context)?;
                expr_24 = expr_26;
            }
            let expr_28 = fun_wrap(expr_24, context)?;
            var_result = expr_28;
            Ok(var_result)
        }

        pub fn fun_gt<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            let expr = fun_unwrap_12049(var_x, context)?;
            let expr_1 = fun_unwrap_12049(var_y, context)?;
            let expr_2 = sgt(cleanup_int256(expr, context)?, cleanup_int256(expr_1, context)?, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_intoSD59x18<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_uint128_to_uint256(var_x, context)?;
            let expr_1 = convert_uint256_to_int256(expr, context)?;
            let expr_2 = convert_int256_to_int256(expr_1, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_intoSD59x18_14589<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_uint64_to_uint64(var_x, context)?;
            let expr_1 = convert_uint64_to_uint256(expr, context)?;
            let expr_2 = convert_uint256_to_int256(expr_1, context)?;
            let expr_3 = convert_int256_to_int256(expr_2, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_intoSD59x18_8301<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = convert_uint40_to_uint256(var_x, context)?;
            let expr_1 = convert_uint256_to_int256(expr, context)?;
            let expr_2 = convert_int256_to_int256(expr_1, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_intoUint256<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let expr = convert_int256_to_int256(var_x, context)?;
            let expr_1 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x2463f3d5u128), context)?, context)?;
                let _1 = abi_encode_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = convert_int256_to_uint256(expr, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_mulDiv18<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let mut var_prod0 = U256::ZERO;
            var_prod0 = zero_uint256;
            let mut var_prod1 = U256::ZERO;
            var_prod1 = zero_uint256;
            let ᵤmm = mulmod(var_x, var_y, not(U256::from(0x0u128), context)?, context)?;
            var_prod0 = mul(var_x, var_y, context)?;
            var_prod1 = sub(sub(ᵤmm, var_prod0, context)?, lt(ᵤmm, var_prod0, context)?, context)?;
            let expr = eq(cleanup_uint256(var_prod1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                let expr_1 = constant_UNIT(context)?;
                let expr_2 = wrapping_div_uint256(var_prod0, expr_1, context)?;
                var_result = expr_2;
                return Ok(var_result);
            }
            let expr_3 = constant_UNIT(context)?;
            let expr_4 = iszero(lt(cleanup_uint256(var_prod1, context)?, cleanup_uint256(expr_3, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5173648du128), context)?, context)?;
                let _1 = abi_encode_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_remainder = U256::ZERO;
            var_remainder = zero_uint256;
            var_remainder = mulmod(var_x, var_y, U256::from(0xde0b6b3a7640000u128), context)?;
            var_result = mul(or(div(sub(var_prod0, var_remainder, context)?, U256::from(0x40000u128), context)?, mul(sub(var_prod1, gt(var_remainder, var_prod0, context)?, context)?, add(div(sub(U256::from(0x0u128), U256::from(0x40000u128), context)?, U256::from(0x40000u128), context)?, U256::from(0x1u128), context)?, context)?, context)?, U256::from_be_slice(&[0xac, 0xcb, 0x18, 0x16, 0x5b, 0xd6, 0xfe, 0x31, 0xae, 0x1c, 0xf3, 0x18, 0xdc, 0x5b, 0x51, 0xee, 0xe0, 0xe1, 0xba, 0x56, 0x9b, 0x88, 0xcd, 0x74, 0xc1, 0x77, 0x3b, 0x91, 0xfa, 0xc1, 0x06, 0x69]), context)?;
            Ok(var_result)
        }

        pub fn fun_mul<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_t_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_t_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12049(var_x, context)?;
            let expr_1 = fun_unwrap_12049(var_y, context)?;
            let expr_2 = constant_uMIN_SD59x18(context)?;
            let expr_3 = eq(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?;
            let mut expr_4 = expr_3;
            if iszero(expr_3, context)? != U256::ZERO {
                let expr_5 = eq(cleanup_int256(expr_1, context)?, cleanup_int256(expr_2, context)?, context)?;
                expr_4 = expr_5;
            }
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xa6070c25u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_xAbs = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_xAbs = zero_uint256;
            let mut var_yAbs = U256::ZERO;
            var_yAbs = zero_uint256;
            let expr_6 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_7 = U256::ZERO;
            // switch
            let δ = expr_6;
            if δ == U256::from(0x0u128) {
                let expr_8 = convert_int256_to_uint256(expr, context)?;
                expr_7 = expr_8;
            }
            var_xAbs = expr_7;
            let expr_11 = slt(cleanup_int256(expr_1, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            let mut expr_12 = U256::ZERO;
            // switch
            let δ = expr_11;
            if δ == U256::from(0x0u128) {
                let expr_13 = convert_int256_to_uint256(expr_1, context)?;
                expr_12 = expr_13;
            }
            var_yAbs = expr_12;
            let expr_16 = fun_mulDiv18(expr_7, expr_12, context)?;
            let expr_17 = constant_uMAX_SD59x18(context)?;
            let expr_18 = convert_int256_to_uint256(expr_17, context)?;
            let expr_19 = gt(cleanup_uint256(expr_16, context)?, cleanup_uint256(expr_18, context)?, context)?;
            if expr_19 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x120b5b43u128), context)?, context)?;
                let _2 = abi_encode_userDefinedValueType_SD59x18_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let expr_20 = xor(expr, expr_1, context)?;
            let expr_21 = sgt(cleanup_int256(expr_20, context)?, convert_rational_minus_by_to_int256(not(U256::from(0x0u128), context)?, context)?, context)?;
            let mut expr_22 = U256::ZERO;
            // switch
            let δ = expr_21;
            if δ == U256::from(0x0u128) {
                let expr_23 = convert_uint256_to_int256(expr_16, context)?;
                let expr_24 = negate_wrapping_int256(expr_23, context)?;
                expr_22 = expr_24;
            }
            let expr_26 = fun_wrap(expr_22, context)?;
            var_result = expr_26;
            Ok(var_result)
        }

        pub fn shift_right_uint256_uint256<CI>(value: U256, mut bits: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            bits = cleanup_uint256(bits, context)?;
            result = cleanup_uint256(shift_right_unsigned_dynamic(bits, cleanup_uint256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn shift_right_uint256_uint8<CI>(value: U256, mut bits: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            bits = cleanup_uint8(bits, context)?;
            result = cleanup_uint256(shift_right_unsigned_dynamic(bits, cleanup_uint256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn fun_exp2_15922<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let _1 = convert_rational_3138550867693340381917894711603833208051177722232017256448_by_1_to_uint256(shl(U256::from(0xbfu128), U256::from(0x1u128), context)?, context)?;
            var_result = _1;
            let expr = and(var_x, convert_rational_18374686479671623680_by_1_to_uint256(U256::from(0xff00000000000000u128), context)?, context)?;
            let expr_1 = gt(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                let expr_2 = and(var_x, convert_rational_9223372036854775808_by_1_to_uint256(U256::from(0x8000000000000000u128), context)?, context)?;
                let expr_3 = gt(cleanup_uint256(expr_2, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_3 != U256::ZERO {
                    let expr_4 = wrapping_mul_uint256(_1, convert_rational_26087635650665564425_by_1_to_uint256(U256::from(0x16a09e667f3bcc909u128), context)?, context)?;
                    let _2 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_5 = shift_right_uint256_uint8(expr_4, _2, context)?;
                    var_result = expr_5;
                }
                let expr_6 = and(var_x, convert_rational_4611686018427387904_by_1_to_uint256(U256::from(0x4000000000000000u128), context)?, context)?;
                let expr_7 = gt(cleanup_uint256(expr_6, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_7 != U256::ZERO {
                    let expr_8 = wrapping_mul_uint256(var_result, convert_rational_21936999301089678047_by_1_to_uint256(U256::from(0x1306fe0a31b7152dfu128), context)?, context)?;
                    let _3 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_9 = shift_right_uint256_uint8(expr_8, _3, context)?;
                    var_result = expr_9;
                }
                let expr_10 = and(var_x, convert_rational_2305843009213693952_by_1_to_uint256(U256::from(0x2000000000000000u128), context)?, context)?;
                let expr_11 = gt(cleanup_uint256(expr_10, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_11 != U256::ZERO {
                    let expr_12 = wrapping_mul_uint256(var_result, convert_rational_20116317054877281742_by_1_to_uint256(U256::from(0x1172b83c7d517adceu128), context)?, context)?;
                    let _4 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_13 = shift_right_uint256_uint8(expr_12, _4, context)?;
                    var_result = expr_13;
                }
                let expr_14 = and(var_x, convert_rational_1152921504606846976_by_1_to_uint256(U256::from(0x1000000000000000u128), context)?, context)?;
                let expr_15 = gt(cleanup_uint256(expr_14, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_15 != U256::ZERO {
                    let expr_16 = wrapping_mul_uint256(var_result, convert_rational_by_to_uint256(U256::from(0x10b5586cf9890f62au128), context)?, context)?;
                    let _5 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_17 = shift_right_uint256_uint8(expr_16, _5, context)?;
                    var_result = expr_17;
                }
                let expr_18 = and(var_x, convert_rational_576460752303423488_by_1_to_uint256(U256::from(0x800000000000000u128), context)?, context)?;
                let expr_19 = gt(cleanup_uint256(expr_18, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_19 != U256::ZERO {
                    let expr_20 = wrapping_mul_uint256(var_result, convert_rational_18850675170876015534_by_1_to_uint256(U256::from(0x1059b0d31585743aeu128), context)?, context)?;
                    let _6 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_21 = shift_right_uint256_uint8(expr_20, _6, context)?;
                    var_result = expr_21;
                }
                let expr_22 = and(var_x, convert_rational_288230376151711744_by_1_to_uint256(U256::from(0x400000000000000u128), context)?, context)?;
                let expr_23 = gt(cleanup_uint256(expr_22, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_23 != U256::ZERO {
                    let expr_24 = wrapping_mul_uint256(var_result, convert_rational_18647615946650685159_by_1_to_uint256(U256::from(0x102c9a3e778060ee7u128), context)?, context)?;
                    let _7 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_25 = shift_right_uint256_uint8(expr_24, _7, context)?;
                    var_result = expr_25;
                }
                let expr_26 = and(var_x, convert_rational_144115188075855872_by_1_to_uint256(U256::from(0x200000000000000u128), context)?, context)?;
                let expr_27 = gt(cleanup_uint256(expr_26, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_27 != U256::ZERO {
                    let expr_28 = wrapping_mul_uint256(var_result, convert_rational_18546908069882975960_by_1_to_uint256(U256::from(0x10163da9fb33356d8u128), context)?, context)?;
                    let _8 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_29 = shift_right_uint256_uint8(expr_28, _8, context)?;
                    var_result = expr_29;
                }
                let expr_30 = and(var_x, convert_rational_72057594037927936_by_1_to_uint256(U256::from(0x100000000000000u128), context)?, context)?;
                let expr_31 = gt(cleanup_uint256(expr_30, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_31 != U256::ZERO {
                    let expr_32 = wrapping_mul_uint256(var_result, convert_rational_18496758270674070881_by_1_to_uint256(U256::from(0x100b1afa5abcbed61u128), context)?, context)?;
                    let _9 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_33 = shift_right_uint256_uint8(expr_32, _9, context)?;
                    var_result = expr_33;
                }
            }
            let expr_34 = and(var_x, convert_rational_71776119061217280_by_1_to_uint256(U256::from(0xff000000000000u128), context)?, context)?;
            let expr_35 = gt(cleanup_uint256(expr_34, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_35 != U256::ZERO {
                let expr_36 = and(var_x, convert_rational_36028797018963968_by_1_to_uint256(U256::from(0x80000000000000u128), context)?, context)?;
                let expr_37 = gt(cleanup_uint256(expr_36, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_37 != U256::ZERO {
                    let expr_38 = wrapping_mul_uint256(var_result, convert_rational_18471734244850835106_by_1_to_uint256(U256::from(0x10058c86da1c09ea2u128), context)?, context)?;
                    let _10 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_39 = shift_right_uint256_uint8(expr_38, _10, context)?;
                    var_result = expr_39;
                }
                let expr_40 = and(var_x, convert_rational_18014398509481984_by_1_to_uint256(U256::from(0x40000000000000u128), context)?, context)?;
                let expr_41 = gt(cleanup_uint256(expr_40, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_41 != U256::ZERO {
                    let expr_42 = wrapping_mul_uint256(var_result, convert_rational_18459234930309000272_by_1_to_uint256(U256::from(0x1002c605e2e8cec50u128), context)?, context)?;
                    let _11 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_43 = shift_right_uint256_uint8(expr_42, _11, context)?;
                    var_result = expr_43;
                }
                let expr_44 = and(var_x, convert_rational_9007199254740992_by_1_to_uint256(U256::from(0x20000000000000u128), context)?, context)?;
                let expr_45 = gt(cleanup_uint256(expr_44, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_45 != U256::ZERO {
                    let expr_46 = wrapping_mul_uint256(var_result, convert_rational_18452988445124272033_by_1_to_uint256(U256::from(0x100162f3904051fa1u128), context)?, context)?;
                    let _12 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_47 = shift_right_uint256_uint8(expr_46, _12, context)?;
                    var_result = expr_47;
                }
                let expr_48 = and(var_x, convert_rational_4503599627370496_by_1_to_uint256(U256::from(0x10000000000000u128), context)?, context)?;
                let expr_49 = gt(cleanup_uint256(expr_48, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_49 != U256::ZERO {
                    let expr_50 = wrapping_mul_uint256(var_result, convert_rational_18449865995240371898_by_1_to_uint256(U256::from(0x1000b175effdc76bau128), context)?, context)?;
                    let _13 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_51 = shift_right_uint256_uint8(expr_50, _13, context)?;
                    var_result = expr_51;
                }
                let expr_52 = and(var_x, convert_rational_2251799813685248_by_1_to_uint256(U256::from(0x8000000000000u128), context)?, context)?;
                let expr_53 = gt(cleanup_uint256(expr_52, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_53 != U256::ZERO {
                    let expr_54 = wrapping_mul_uint256(var_result, convert_rational_18448304968436414829_by_1_to_uint256(U256::from(0x100058ba01fb9f96du128), context)?, context)?;
                    let _14 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_55 = shift_right_uint256_uint8(expr_54, _14, context)?;
                    var_result = expr_55;
                }
                let expr_56 = and(var_x, convert_rational_1125899906842624_by_1_to_uint256(U256::from(0x4000000000000u128), context)?, context)?;
                let expr_57 = gt(cleanup_uint256(expr_56, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_57 != U256::ZERO {
                    let expr_58 = wrapping_mul_uint256(var_result, convert_rational_18447524504564044946_by_1_to_uint256(U256::from(0x10002c5cc37da9492u128), context)?, context)?;
                    let _15 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_59 = shift_right_uint256_uint8(expr_58, _15, context)?;
                    var_result = expr_59;
                }
                let expr_60 = and(var_x, convert_rational_562949953421312_by_1_to_uint256(U256::from(0x2000000000000u128), context)?, context)?;
                let expr_61 = gt(cleanup_uint256(expr_60, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_61 != U256::ZERO {
                    let expr_62 = wrapping_mul_uint256(var_result, convert_rational_18447134285009651015_by_1_to_uint256(U256::from(0x1000162e525ee0547u128), context)?, context)?;
                    let _16 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_63 = shift_right_uint256_uint8(expr_62, _16, context)?;
                    var_result = expr_63;
                }
                let expr_64 = and(var_x, convert_rational_281474976710656_by_1_to_uint256(U256::from(0x1000000000000u128), context)?, context)?;
                let expr_65 = gt(cleanup_uint256(expr_64, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_65 != U256::ZERO {
                    let expr_66 = wrapping_mul_uint256(var_result, convert_rational_18446939178327825412_by_1_to_uint256(U256::from(0x10000b17255775c04u128), context)?, context)?;
                    let _17 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_67 = shift_right_uint256_uint8(expr_66, _17, context)?;
                    var_result = expr_67;
                }
            }
            let expr_68 = and(var_x, convert_rational_280375465082880_by_1_to_uint256(U256::from(0xff0000000000u128), context)?, context)?;
            let expr_69 = gt(cleanup_uint256(expr_68, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_69 != U256::ZERO {
                let expr_70 = and(var_x, convert_rational_140737488355328_by_1_to_uint256(U256::from(0x800000000000u128), context)?, context)?;
                let expr_71 = gt(cleanup_uint256(expr_70, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_71 != U256::ZERO {
                    let expr_72 = wrapping_mul_uint256(var_result, convert_rational_18446841625760745902_by_1_to_uint256(U256::from(0x1000058b91b5bc9aeu128), context)?, context)?;
                    let _18 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_73 = shift_right_uint256_uint8(expr_72, _18, context)?;
                    var_result = expr_73;
                }
                let expr_74 = and(var_x, convert_rational_70368744177664_by_1_to_uint256(U256::from(0x400000000000u128), context)?, context)?;
                let expr_75 = gt(cleanup_uint256(expr_74, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_75 != U256::ZERO {
                    let expr_76 = wrapping_mul_uint256(var_result, convert_rational_18446792849670663277_by_1_to_uint256(U256::from(0x100002c5c89d5ec6du128), context)?, context)?;
                    let _19 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_77 = shift_right_uint256_uint8(expr_76, _19, context)?;
                    var_result = expr_77;
                }
                let expr_78 = and(var_x, convert_rational_35184372088832_by_1_to_uint256(U256::from(0x200000000000u128), context)?, context)?;
                let expr_79 = gt(cleanup_uint256(expr_78, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_79 != U256::ZERO {
                    let expr_80 = wrapping_mul_uint256(var_result, convert_rational_18446768461673986097_by_1_to_uint256(U256::from(0x10000162e43f4f831u128), context)?, context)?;
                    let _20 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_81 = shift_right_uint256_uint8(expr_80, _20, context)?;
                    var_result = expr_81;
                }
                let expr_82 = and(var_x, convert_rational_17592186044416_by_1_to_uint256(U256::from(0x100000000000u128), context)?, context)?;
                let expr_83 = gt(cleanup_uint256(expr_82, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_83 != U256::ZERO {
                    let expr_84 = wrapping_mul_uint256(var_result, convert_rational_18446756267687738522_by_1_to_uint256(U256::from(0x100000b1721bcfc9au128), context)?, context)?;
                    let _21 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_85 = shift_right_uint256_uint8(expr_84, _21, context)?;
                    var_result = expr_85;
                }
                let expr_86 = and(var_x, convert_rational_8796093022208_by_1_to_uint256(U256::from(0x80000000000u128), context)?, context)?;
                let expr_87 = gt(cleanup_uint256(expr_86, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_87 != U256::ZERO {
                    let expr_88 = wrapping_mul_uint256(var_result, convert_rational_18446750170697637486_by_1_to_uint256(U256::from(0x10000058b90cf1e6eu128), context)?, context)?;
                    let _22 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_89 = shift_right_uint256_uint8(expr_88, _22, context)?;
                    var_result = expr_89;
                }
                let expr_90 = and(var_x, convert_rational_4398046511104_by_1_to_uint256(U256::from(0x40000000000u128), context)?, context)?;
                let expr_91 = gt(cleanup_uint256(expr_90, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_91 != U256::ZERO {
                    let expr_92 = wrapping_mul_uint256(var_result, convert_rational_18446747122203342655_by_1_to_uint256(U256::from(0x1000002c5c863b73fu128), context)?, context)?;
                    let _23 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_93 = shift_right_uint256_uint8(expr_92, _23, context)?;
                    var_result = expr_93;
                }
                let expr_94 = and(var_x, convert_rational_2199023255552_by_1_to_uint256(U256::from(0x20000000000u128), context)?, context)?;
                let expr_95 = gt(cleanup_uint256(expr_94, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_95 != U256::ZERO {
                    let expr_96 = wrapping_mul_uint256(var_result, convert_rational_18446745597956384162_by_1_to_uint256(U256::from(0x100000162e430e5a2u128), context)?, context)?;
                    let _24 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_97 = shift_right_uint256_uint8(expr_96, _24, context)?;
                    var_result = expr_97;
                }
                let expr_98 = and(var_x, convert_rational_1099511627776_by_1_to_uint256(U256::from(0x10000000000u128), context)?, context)?;
                let expr_99 = gt(cleanup_uint256(expr_98, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_99 != U256::ZERO {
                    let expr_100 = wrapping_mul_uint256(var_result, convert_rational_18446744835832952145_by_1_to_uint256(U256::from(0x1000000b172183551u128), context)?, context)?;
                    let _25 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_101 = shift_right_uint256_uint8(expr_100, _25, context)?;
                    var_result = expr_101;
                }
            }
            let expr_102 = and(var_x, convert_rational_1095216660480_by_1_to_uint256(U256::from(0xff00000000u128), context)?, context)?;
            let expr_103 = gt(cleanup_uint256(expr_102, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_103 != U256::ZERO {
                let expr_104 = and(var_x, convert_rational_549755813888_by_1_to_uint256(U256::from(0x8000000000u128), context)?, context)?;
                let expr_105 = gt(cleanup_uint256(expr_104, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_105 != U256::ZERO {
                    let expr_106 = wrapping_mul_uint256(var_result, convert_rational_18446744454771247945_by_1_to_uint256(U256::from(0x100000058b90c0b49u128), context)?, context)?;
                    let _26 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_107 = shift_right_uint256_uint8(expr_106, _26, context)?;
                    var_result = expr_107;
                }
                let expr_108 = and(var_x, convert_rational_274877906944_by_1_to_uint256(U256::from(0x4000000000u128), context)?, context)?;
                let expr_109 = gt(cleanup_uint256(expr_108, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_109 != U256::ZERO {
                    let expr_110 = wrapping_mul_uint256(var_result, convert_rational_18446744264240398796_by_1_to_uint256(U256::from(0x10000002c5c8601ccu128), context)?, context)?;
                    let _27 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_111 = shift_right_uint256_uint8(expr_110, _27, context)?;
                    var_result = expr_111;
                }
                let expr_112 = and(var_x, convert_rational_137438953472_by_1_to_uint256(U256::from(0x2000000000u128), context)?, context)?;
                let expr_113 = gt(cleanup_uint256(expr_112, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_113 != U256::ZERO {
                    let expr_114 = wrapping_mul_uint256(var_result, convert_rational_18446744168974974960_by_1_to_uint256(U256::from(0x1000000162e42fff0u128), context)?, context)?;
                    let _28 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_115 = shift_right_uint256_uint8(expr_114, _28, context)?;
                    var_result = expr_115;
                }
                let expr_116 = and(var_x, convert_rational_68719476736_by_1_to_uint256(U256::from(0x1000000000u128), context)?, context)?;
                let expr_117 = gt(cleanup_uint256(expr_116, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_117 != U256::ZERO {
                    let expr_118 = wrapping_mul_uint256(var_result, convert_rational_18446744121342263227_by_1_to_uint256(U256::from(0x10000000b17217fbbu128), context)?, context)?;
                    let _29 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_119 = shift_right_uint256_uint8(expr_118, _29, context)?;
                    var_result = expr_119;
                }
                let expr_120 = and(var_x, convert_rational_34359738368_by_1_to_uint256(U256::from(0x800000000u128), context)?, context)?;
                let expr_121 = gt(cleanup_uint256(expr_120, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_121 != U256::ZERO {
                    let expr_122 = wrapping_mul_uint256(var_result, convert_rational_18446744097525907406_by_1_to_uint256(U256::from(0x1000000058b90bfceu128), context)?, context)?;
                    let _30 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_123 = shift_right_uint256_uint8(expr_122, _30, context)?;
                    var_result = expr_123;
                }
                let expr_124 = and(var_x, convert_rational_17179869184_by_1_to_uint256(U256::from(0x400000000u128), context)?, context)?;
                let expr_125 = gt(cleanup_uint256(expr_124, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_125 != U256::ZERO {
                    let expr_126 = wrapping_mul_uint256(var_result, convert_rational_18446744085617729507_by_1_to_uint256(U256::from(0x100000002c5c85fe3u128), context)?, context)?;
                    let _31 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_127 = shift_right_uint256_uint8(expr_126, _31, context)?;
                    var_result = expr_127;
                }
                let expr_128 = and(var_x, convert_rational_8589934592_by_1_to_uint256(U256::from(0x200000000u128), context)?, context)?;
                let expr_129 = gt(cleanup_uint256(expr_128, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_129 != U256::ZERO {
                    let expr_130 = wrapping_mul_uint256(var_result, convert_rational_18446744079663640561_by_1_to_uint256(U256::from(0x10000000162e42ff1u128), context)?, context)?;
                    let _32 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_131 = shift_right_uint256_uint8(expr_130, _32, context)?;
                    var_result = expr_131;
                }
                let expr_132 = and(var_x, convert_rational_4294967296_by_1_to_uint256(U256::from(0x100000000u128), context)?, context)?;
                let expr_133 = gt(cleanup_uint256(expr_132, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_133 != U256::ZERO {
                    let expr_134 = wrapping_mul_uint256(var_result, convert_rational_18446744076686596088_by_1_to_uint256(U256::from(0x100000000b17217f8u128), context)?, context)?;
                    let _33 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_135 = shift_right_uint256_uint8(expr_134, _33, context)?;
                    var_result = expr_135;
                }
            }
            let expr_136 = and(var_x, convert_rational_4278190080_by_1_to_uint256(U256::from(0xff000000u128), context)?, context)?;
            let expr_137 = gt(cleanup_uint256(expr_136, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_137 != U256::ZERO {
                let expr_138 = and(var_x, convert_rational_2147483648_by_1_to_uint256(U256::from(0x80000000u128), context)?, context)?;
                let expr_139 = gt(cleanup_uint256(expr_138, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_139 != U256::ZERO {
                    let expr_140 = wrapping_mul_uint256(var_result, convert_rational_18446744075198073852_by_1_to_uint256(U256::from(0x10000000058b90bfcu128), context)?, context)?;
                    let _34 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_141 = shift_right_uint256_uint8(expr_140, _34, context)?;
                    var_result = expr_141;
                }
                let expr_142 = and(var_x, convert_rational_1073741824_by_1_to_uint256(U256::from(0x40000000u128), context)?, context)?;
                let expr_143 = gt(cleanup_uint256(expr_142, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_143 != U256::ZERO {
                    let expr_144 = wrapping_mul_uint256(var_result, convert_rational_18446744074453812734_by_1_to_uint256(U256::from(0x1000000002c5c85feu128), context)?, context)?;
                    let _35 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_145 = shift_right_uint256_uint8(expr_144, _35, context)?;
                    var_result = expr_145;
                }
                let expr_146 = and(var_x, convert_rational_536870912_by_1_to_uint256(U256::from(0x20000000u128), context)?, context)?;
                let expr_147 = gt(cleanup_uint256(expr_146, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_147 != U256::ZERO {
                    let expr_148 = wrapping_mul_uint256(var_result, convert_rational_18446744074081682175_by_1_to_uint256(U256::from(0x100000000162e42ffu128), context)?, context)?;
                    let _36 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_149 = shift_right_uint256_uint8(expr_148, _36, context)?;
                    var_result = expr_149;
                }
                let expr_150 = and(var_x, convert_rational_268435456_by_1_to_uint256(U256::from(0x10000000u128), context)?, context)?;
                let expr_151 = gt(cleanup_uint256(expr_150, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_151 != U256::ZERO {
                    let expr_152 = wrapping_mul_uint256(var_result, convert_rational_18446744073895616895_by_1_to_uint256(U256::from(0x1000000000b17217fu128), context)?, context)?;
                    let _37 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_153 = shift_right_uint256_uint8(expr_152, _37, context)?;
                    var_result = expr_153;
                }
                let expr_154 = and(var_x, convert_rational_134217728_by_1_to_uint256(U256::from(0x8000000u128), context)?, context)?;
                let expr_155 = gt(cleanup_uint256(expr_154, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_155 != U256::ZERO {
                    let expr_156 = wrapping_mul_uint256(var_result, convert_rational_18446744073802584256_by_1_to_uint256(U256::from(0x100000000058b90c0u128), context)?, context)?;
                    let _38 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_157 = shift_right_uint256_uint8(expr_156, _38, context)?;
                    var_result = expr_157;
                }
                let expr_158 = and(var_x, convert_rational_67108864_by_1_to_uint256(U256::from(0x4000000u128), context)?, context)?;
                let expr_159 = gt(cleanup_uint256(expr_158, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_159 != U256::ZERO {
                    let expr_160 = wrapping_mul_uint256(var_result, convert_rational_18446744073756067936_by_1_to_uint256(U256::from(0x10000000002c5c860u128), context)?, context)?;
                    let _39 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_161 = shift_right_uint256_uint8(expr_160, _39, context)?;
                    var_result = expr_161;
                }
                let expr_162 = and(var_x, convert_rational_33554432_by_1_to_uint256(U256::from(0x2000000u128), context)?, context)?;
                let expr_163 = gt(cleanup_uint256(expr_162, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_163 != U256::ZERO {
                    let expr_164 = wrapping_mul_uint256(var_result, convert_rational_18446744073732809776_by_1_to_uint256(U256::from(0x1000000000162e430u128), context)?, context)?;
                    let _40 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_165 = shift_right_uint256_uint8(expr_164, _40, context)?;
                    var_result = expr_165;
                }
                let expr_166 = and(var_x, convert_rational_16777216_by_1_to_uint256(U256::from(0x1000000u128), context)?, context)?;
                let expr_167 = gt(cleanup_uint256(expr_166, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_167 != U256::ZERO {
                    let expr_168 = wrapping_mul_uint256(var_result, convert_rational_18446744073721180696_by_1_to_uint256(U256::from(0x10000000000b17218u128), context)?, context)?;
                    let _41 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_169 = shift_right_uint256_uint8(expr_168, _41, context)?;
                    var_result = expr_169;
                }
            }
            let expr_170 = and(var_x, convert_rational_16711680_by_1_to_uint256(U256::from(0xff0000u128), context)?, context)?;
            let expr_171 = gt(cleanup_uint256(expr_170, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_171 != U256::ZERO {
                let expr_172 = and(var_x, convert_rational_8388608_by_1_to_uint256(U256::from(0x800000u128), context)?, context)?;
                let expr_173 = gt(cleanup_uint256(expr_172, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_173 != U256::ZERO {
                    let expr_174 = wrapping_mul_uint256(var_result, convert_rational_18446744073715366156_by_1_to_uint256(U256::from(0x1000000000058b90cu128), context)?, context)?;
                    let _42 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_175 = shift_right_uint256_uint8(expr_174, _42, context)?;
                    var_result = expr_175;
                }
                let expr_176 = and(var_x, convert_rational_4194304_by_1_to_uint256(U256::from(0x400000u128), context)?, context)?;
                let expr_177 = gt(cleanup_uint256(expr_176, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_177 != U256::ZERO {
                    let expr_178 = wrapping_mul_uint256(var_result, convert_rational_18446744073712458886_by_1_to_uint256(U256::from(0x100000000002c5c86u128), context)?, context)?;
                    let _43 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_179 = shift_right_uint256_uint8(expr_178, _43, context)?;
                    var_result = expr_179;
                }
                let expr_180 = and(var_x, convert_rational_2097152_by_1_to_uint256(U256::from(0x200000u128), context)?, context)?;
                let expr_181 = gt(cleanup_uint256(expr_180, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_181 != U256::ZERO {
                    let expr_182 = wrapping_mul_uint256(var_result, convert_rational_18446744073711005251_by_1_to_uint256(U256::from(0x10000000000162e43u128), context)?, context)?;
                    let _44 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_183 = shift_right_uint256_uint8(expr_182, _44, context)?;
                    var_result = expr_183;
                }
                let expr_184 = and(var_x, convert_rational_1048576_by_1_to_uint256(U256::from(0x100000u128), context)?, context)?;
                let expr_185 = gt(cleanup_uint256(expr_184, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_185 != U256::ZERO {
                    let expr_186 = wrapping_mul_uint256(var_result, convert_rational_18446744073710278433_by_1_to_uint256(U256::from(0x100000000000b1721u128), context)?, context)?;
                    let _45 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_187 = shift_right_uint256_uint8(expr_186, _45, context)?;
                    var_result = expr_187;
                }
                let expr_188 = and(var_x, convert_rational_524288_by_1_to_uint256(U256::from(0x80000u128), context)?, context)?;
                let expr_189 = gt(cleanup_uint256(expr_188, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_189 != U256::ZERO {
                    let expr_190 = wrapping_mul_uint256(var_result, convert_rational_18446744073709915025_by_1_to_uint256(U256::from(0x10000000000058b91u128), context)?, context)?;
                    let _46 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_191 = shift_right_uint256_uint8(expr_190, _46, context)?;
                    var_result = expr_191;
                }
                let expr_192 = and(var_x, convert_rational_262144_by_1_to_uint256(U256::from(0x40000u128), context)?, context)?;
                let expr_193 = gt(cleanup_uint256(expr_192, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_193 != U256::ZERO {
                    let expr_194 = wrapping_mul_uint256(var_result, convert_rational_18446744073709733320_by_1_to_uint256(U256::from(0x1000000000002c5c8u128), context)?, context)?;
                    let _47 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_195 = shift_right_uint256_uint8(expr_194, _47, context)?;
                    var_result = expr_195;
                }
                let expr_196 = and(var_x, convert_rational_131072_by_1_to_uint256(U256::from(0x20000u128), context)?, context)?;
                let expr_197 = gt(cleanup_uint256(expr_196, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_197 != U256::ZERO {
                    let expr_198 = wrapping_mul_uint256(var_result, convert_rational_18446744073709642468_by_1_to_uint256(U256::from(0x100000000000162e4u128), context)?, context)?;
                    let _48 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_199 = shift_right_uint256_uint8(expr_198, _48, context)?;
                    var_result = expr_199;
                }
                let expr_200 = and(var_x, convert_rational_65536_by_1_to_uint256(U256::from(0x10000u128), context)?, context)?;
                let expr_201 = gt(cleanup_uint256(expr_200, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_201 != U256::ZERO {
                    let expr_202 = wrapping_mul_uint256(var_result, convert_rational_18446744073709597042_by_1_to_uint256(U256::from(0x1000000000000b172u128), context)?, context)?;
                    let _49 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_203 = shift_right_uint256_uint8(expr_202, _49, context)?;
                    var_result = expr_203;
                }
            }
            let expr_204 = and(var_x, convert_rational_65280_by_1_to_uint256(U256::from(0xff00u128), context)?, context)?;
            let expr_205 = gt(cleanup_uint256(expr_204, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_205 != U256::ZERO {
                let expr_206 = and(var_x, convert_rational_32768_by_1_to_uint256(U256::from(0x8000u128), context)?, context)?;
                let expr_207 = gt(cleanup_uint256(expr_206, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_207 != U256::ZERO {
                    let expr_208 = wrapping_mul_uint256(var_result, convert_rational_18446744073709574329_by_1_to_uint256(U256::from(0x100000000000058b9u128), context)?, context)?;
                    let _50 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_209 = shift_right_uint256_uint8(expr_208, _50, context)?;
                    var_result = expr_209;
                }
                let expr_210 = and(var_x, convert_rational_16384_by_1_to_uint256(U256::from(0x4000u128), context)?, context)?;
                let expr_211 = gt(cleanup_uint256(expr_210, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_211 != U256::ZERO {
                    let expr_212 = wrapping_mul_uint256(var_result, convert_rational_18446744073709562973_by_1_to_uint256(U256::from(0x10000000000002c5du128), context)?, context)?;
                    let _51 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_213 = shift_right_uint256_uint8(expr_212, _51, context)?;
                    var_result = expr_213;
                }
                let expr_214 = and(var_x, convert_rational_8192_by_1_to_uint256(U256::from(0x2000u128), context)?, context)?;
                let expr_215 = gt(cleanup_uint256(expr_214, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_215 != U256::ZERO {
                    let expr_216 = wrapping_mul_uint256(var_result, convert_rational_18446744073709557294_by_1_to_uint256(U256::from(0x1000000000000162eu128), context)?, context)?;
                    let _52 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_217 = shift_right_uint256_uint8(expr_216, _52, context)?;
                    var_result = expr_217;
                }
                let expr_218 = and(var_x, convert_t_rational_by_to_t_uint256(U256::from(0x1000u128), context)?, context)?;
                let expr_219 = gt(cleanup_uint256(expr_218, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_219 != U256::ZERO {
                    let expr_220 = wrapping_mul_uint256(var_result, convert_rational_18446744073709554455_by_1_to_uint256(U256::from(0x10000000000000b17u128), context)?, context)?;
                    let _53 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_221 = shift_right_uint256_uint8(expr_220, _53, context)?;
                    var_result = expr_221;
                }
                let expr_222 = and(var_x, convert_rational_2048_by_1_to_uint256(U256::from(0x800u128), context)?, context)?;
                let expr_223 = gt(cleanup_uint256(expr_222, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_223 != U256::ZERO {
                    let expr_224 = wrapping_mul_uint256(var_result, convert_rational_18446744073709553036_by_1_to_uint256(U256::from(0x1000000000000058cu128), context)?, context)?;
                    let _54 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_225 = shift_right_uint256_uint8(expr_224, _54, context)?;
                    var_result = expr_225;
                }
                let expr_226 = and(var_x, convert_rational_1024_by_1_to_uint256(U256::from(0x400u128), context)?, context)?;
                let expr_227 = gt(cleanup_uint256(expr_226, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_227 != U256::ZERO {
                    let expr_228 = wrapping_mul_uint256(var_result, convert_rational_18446744073709552326_by_1_to_uint256(U256::from(0x100000000000002c6u128), context)?, context)?;
                    let _55 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_229 = shift_right_uint256_uint8(expr_228, _55, context)?;
                    var_result = expr_229;
                }
                let expr_230 = and(var_x, convert_rational_512_by_1_to_uint256(U256::from(0x200u128), context)?, context)?;
                let expr_231 = gt(cleanup_uint256(expr_230, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_231 != U256::ZERO {
                    let expr_232 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551971_by_1_to_uint256(U256::from(0x10000000000000163u128), context)?, context)?;
                    let _56 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_233 = shift_right_uint256_uint8(expr_232, _56, context)?;
                    var_result = expr_233;
                }
                let expr_234 = and(var_x, convert_rational_256_by_1_to_uint256(U256::from(0x100u128), context)?, context)?;
                let expr_235 = gt(cleanup_uint256(expr_234, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_235 != U256::ZERO {
                    let expr_236 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551793_by_1_to_uint256(U256::from(0x100000000000000b1u128), context)?, context)?;
                    let _57 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_237 = shift_right_uint256_uint8(expr_236, _57, context)?;
                    var_result = expr_237;
                }
            }
            let expr_238 = and(var_x, convert_rational_255_by_1_to_uint256(U256::from(0xffu128), context)?, context)?;
            let expr_239 = gt(cleanup_uint256(expr_238, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_239 != U256::ZERO {
                let expr_240 = and(var_x, convert_rational_128_by_1_to_uint256(U256::from(0x80u128), context)?, context)?;
                let expr_241 = gt(cleanup_uint256(expr_240, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_241 != U256::ZERO {
                    let expr_242 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551705_by_1_to_uint256(U256::from(0x10000000000000059u128), context)?, context)?;
                    let _58 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                    let expr_243 = shift_right_uint256_uint8(expr_242, _58, context)?;
                    var_result = expr_243;
                }
                let expr_244 = U256::from(0x40u128);
                let expr_245 = and(var_x, convert_rational_64_by_1_to_uint256(expr_244, context)?, context)?;
                let expr_246 = gt(cleanup_uint256(expr_245, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_246 != U256::ZERO {
                    let expr_247 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551660_by_1_to_uint256(U256::from(0x1000000000000002cu128), context)?, context)?;
                    let _59 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_248 = shift_right_uint256_uint8(expr_247, _59, context)?;
                    var_result = expr_248;
                }
                let expr_249 = and(var_x, convert_rational_32_by_1_to_uint256(U256::from(0x20u128), context)?, context)?;
                let expr_250 = gt(cleanup_uint256(expr_249, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_250 != U256::ZERO {
                    let expr_251 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551638_by_1_to_uint256(U256::from(0x10000000000000016u128), context)?, context)?;
                    let _60 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_252 = shift_right_uint256_uint8(expr_251, _60, context)?;
                    var_result = expr_252;
                }
                let expr_253 = and(var_x, convert_rational_16_by_1_to_uint256(U256::from(0x10u128), context)?, context)?;
                let expr_254 = gt(cleanup_uint256(expr_253, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_254 != U256::ZERO {
                    let expr_255 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551627_by_1_to_uint256(U256::from(0x1000000000000000bu128), context)?, context)?;
                    let _61 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_256 = shift_right_uint256_uint8(expr_255, _61, context)?;
                    var_result = expr_256;
                }
                let expr_257 = and(var_x, convert_rational_8_by_1_to_uint256(U256::from(0x8u128), context)?, context)?;
                let expr_258 = gt(cleanup_uint256(expr_257, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_258 != U256::ZERO {
                    let expr_259 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551622_by_1_to_uint256(U256::from(0x10000000000000006u128), context)?, context)?;
                    let _62 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_260 = shift_right_uint256_uint8(expr_259, _62, context)?;
                    var_result = expr_260;
                }
                let expr_261 = and(var_x, convert_rational_4_by_1_to_uint256(U256::from(0x4u128), context)?, context)?;
                let expr_262 = gt(cleanup_uint256(expr_261, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_262 != U256::ZERO {
                    let expr_263 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551619_by_1_to_uint256(U256::from(0x10000000000000003u128), context)?, context)?;
                    let _63 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_264 = shift_right_uint256_uint8(expr_263, _63, context)?;
                    var_result = expr_264;
                }
                let expr_265 = and(var_x, convert_rational_2_by_1_to_uint256(U256::from(0x2u128), context)?, context)?;
                let expr_266 = gt(cleanup_uint256(expr_265, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_266 != U256::ZERO {
                    let expr_267 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551617_by_1_to_uint256(U256::from(0x10000000000000001u128), context)?, context)?;
                    let _64 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_268 = shift_right_uint256_uint8(expr_267, _64, context)?;
                    var_result = expr_268;
                }
                let expr_269 = and(var_x, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let expr_270 = gt(cleanup_uint256(expr_269, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                if expr_270 != U256::ZERO {
                    let expr_271 = wrapping_mul_uint256(var_result, convert_rational_18446744073709551617_by_1_to_uint256(U256::from(0x10000000000000001u128), context)?, context)?;
                    let _65 = convert_t_rational_by_to_t_uint8(expr_244, context)?;
                    let expr_272 = shift_right_uint256_uint8(expr_271, _65, context)?;
                    var_result = expr_272;
                }
            }
            let expr_273 = constant_UNIT(context)?;
            let expr_274 = wrapping_mul_uint256(var_result, expr_273, context)?;
            var_result = expr_274;
            let _66 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
            let expr_275 = shift_right_uint256_uint8(var_x, _66, context)?;
            let expr_276 = wrapping_sub_uint256(convert_rational_191_by_1_to_uint256(U256::from(0xbfu128), context)?, expr_275, context)?;
            let expr_277 = shift_right_uint256_uint256(expr_274, expr_276, context)?;
            var_result = expr_277;
            Ok(var_result)
        }

        pub fn shift_left_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(bits, value, context)?;
            Ok(newValue)
        }

        pub fn shift_left_int256_uint8<CI>(value: U256, mut bits: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            bits = cleanup_uint8(bits, context)?;
            result = cleanup_int256(shift_left_dynamic(bits, cleanup_int256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn wrapping_div_int256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut r = U256::ZERO;
            x = cleanup_int256(x, context)?;
            y = cleanup_int256(y, context)?;
            if iszero(y, context)? != U256::ZERO {
                panic_error_0x12(context)?;
            }
            r = sdiv(x, y, context)?;
            Ok(r)
        }

        pub fn fun_exp2<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12049(var_x, context)?;
            let expr_1 = slt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            // switch
            let δ = expr_1;
            if δ == U256::from(0x0u128) {
                let expr_2 = constant_uEXP2_MAX_INPUT(context)?;
                let expr_3 = sgt(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?;
                if expr_3 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0x6c1a05u128), context)?, context)?;
                    let _1 = abi_encode_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                    revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
                }
                let _2 = convert_t_rational_by_to_t_uint8(U256::from(0x40u128), context)?;
                let expr_4 = shift_left_int256_uint8(expr, _2, context)?;
                let expr_5 = constant_uUNIT_12217(context)?;
                let expr_6 = wrapping_div_int256(expr_4, expr_5, context)?;
                let expr_7 = convert_int256_to_uint256(expr_6, context)?;
                let expr_8 = fun_exp2_15922(expr_7, context)?;
                let expr_9 = convert_uint256_to_int256(expr_8, context)?;
                let expr_10 = fun_wrap(expr_9, context)?;
                var_result = expr_10;
            }
            Ok(var_result)
        }

        pub fn fun_msb<CI>(mut var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let ᵤfactor = shl(U256::from(0x7u128), gt(var_x, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?, context)?;
            var_x = shr(ᵤfactor, var_x, context)?;
            var_result = or(zero_uint256, ᵤfactor, context)?;
            let ᵤfactor_1 = shl(U256::from(0x6u128), gt(var_x, U256::from(0xffffffffffffffffu128), context)?, context)?;
            var_x = shr(ᵤfactor_1, var_x, context)?;
            var_result = or(var_result, ᵤfactor_1, context)?;
            let ᵤfactor_2 = shl(U256::from(0x5u128), gt(var_x, U256::from(0xffffffffu128), context)?, context)?;
            var_x = shr(ᵤfactor_2, var_x, context)?;
            var_result = or(var_result, ᵤfactor_2, context)?;
            let ᵤfactor_3 = shl(U256::from(0x4u128), gt(var_x, U256::from(0xffffu128), context)?, context)?;
            var_x = shr(ᵤfactor_3, var_x, context)?;
            var_result = or(var_result, ᵤfactor_3, context)?;
            let ᵤfactor_4 = shl(U256::from(0x3u128), gt(var_x, U256::from(0xffu128), context)?, context)?;
            var_x = shr(ᵤfactor_4, var_x, context)?;
            var_result = or(var_result, ᵤfactor_4, context)?;
            let ᵤfactor_5 = shl(U256::from(0x2u128), gt(var_x, U256::from(0xfu128), context)?, context)?;
            var_x = shr(ᵤfactor_5, var_x, context)?;
            var_result = or(var_result, ᵤfactor_5, context)?;
            let ᵤfactor_6 = shl(U256::from(0x1u128), gt(var_x, U256::from(0x3u128), context)?, context)?;
            var_x = shr(ᵤfactor_6, var_x, context)?;
            var_result = or(var_result, ᵤfactor_6, context)?;
            var_result = or(var_result, gt(var_x, U256::from(0x1u128), context)?, context)?;
            Ok(var_result)
        }

        pub fn shift_right_signed_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            result = sar(bits, value, context)?;
            Ok(result)
        }

        pub fn shift_right_int256_uint256<CI>(value: U256, mut bits: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            bits = cleanup_uint256(bits, context)?;
            result = cleanup_int256(shift_right_signed_dynamic(bits, cleanup_int256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn shift_right_int256_uint8<CI>(value: U256, mut bits: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            bits = cleanup_uint8(bits, context)?;
            result = cleanup_int256(shift_right_signed_dynamic(bits, cleanup_int256(value, context)?, context)?, context)?;
            Ok(result)
        }

        pub fn wrapping_add_int256<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            sum = cleanup_int256(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn wrapping_mul_int256<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut product = U256::ZERO;
            product = cleanup_int256(mul(x, y, context)?, context)?;
            Ok(product)
        }

        pub fn fun_log2<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12049(var_x, context)?;
            let mut var_xInt = expr;
            let expr_1 = iszero(sgt(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x59b101bu128), context)?, context)?;
                let _1 = abi_encode_userDefinedValueType_SD59x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_sign = U256::ZERO;
            let zero_int256 = zero_value_for_split_int256(context)?;
            var_sign = zero_int256;
            let expr_2 = constant_uUNIT_12217(context)?;
            let expr_3 = iszero(slt(cleanup_int256(expr, context)?, cleanup_int256(expr_2, context)?, context)?, context)?;
            // switch
            let δ = expr_3;
            if δ == U256::from(0x0u128) {
                let _2 = convert_rational_minus_by_to_int256(not(U256::from(0x0u128), context)?, context)?;
                var_sign = _2;
                let expr_4 = constant_uUNIT_SQUARED(context)?;
                let expr_5 = wrapping_div_int256(expr_4, expr, context)?;
                var_xInt = expr_5;
            }
            let expr_6 = wrapping_div_int256(var_xInt, expr_2, context)?;
            let expr_7 = convert_int256_to_uint256(expr_6, context)?;
            let expr_8 = fun_msb(expr_7, context)?;
            let expr_9 = convert_uint256_to_int256(expr_8, context)?;
            let expr_10 = wrapping_mul_int256(expr_9, expr_2, context)?;
            let mut var_resultInt = expr_10;
            let expr_11 = shift_right_int256_uint256(var_xInt, expr_8, context)?;
            let mut var_y = expr_11;
            let expr_12 = eq(cleanup_int256(expr_11, context)?, cleanup_int256(expr_2, context)?, context)?;
            if expr_12 != U256::ZERO {
                let expr_13 = wrapping_mul_int256(expr_10, var_sign, context)?;
                let expr_14 = fun_wrap(expr_13, context)?;
                var_result = expr_14;
                return Ok(var_result);
            }
            let var_DOUBLE_UNIT = convert_t_rational_by_to_t_int256(U256::from(0x1bc16d674ec80000u128), context)?;
            let expr_15 = constant_uHALF_UNIT(context)?;
            let mut var_delta = expr_15;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_17 = sgt(cleanup_int256(var_delta, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
                    if iszero(expr_17, context)? != U256::ZERO {
                        break;
                    }
                    let expr_18 = wrapping_mul_int256(var_y, var_y, context)?;
                    let expr_19 = wrapping_div_int256(expr_18, expr_2, context)?;
                    var_y = expr_19;
                    let expr_20 = iszero(slt(cleanup_int256(expr_19, context)?, cleanup_int256(var_DOUBLE_UNIT, context)?, context)?, context)?;
                    if expr_20 != U256::ZERO {
                        let expr_21 = wrapping_add_int256(var_resultInt, var_delta, context)?;
                        var_resultInt = expr_21;
                        let _5 = convert_rational_by_to_uint8(U256::from(0x1u128), context)?;
                        let expr_22 = shift_right_int256_uint8(expr_19, _5, context)?;
                        var_y = expr_22;
                    }
                }
                // post
                {
                    let _4 = convert_rational_by_to_uint8(U256::from(0x1u128), context)?;
                    let expr_16 = shift_right_int256_uint8(var_delta, _4, context)?;
                    var_delta = expr_16;
                }
            }
            let expr_23 = wrapping_mul_int256(var_resultInt, var_sign, context)?;
            var_resultInt = expr_23;
            let expr_24 = fun_wrap(expr_23, context)?;
            var_result = expr_24;
            Ok(var_result)
        }

        pub fn fun_pow<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_SD59x18 = zero_value_for_split_userDefinedValueType_SD59x18(context)?;
            var_result = zero_userDefinedValueType_SD59x18;
            let expr = fun_unwrap_12049(var_x, context)?;
            let expr_1 = fun_unwrap_12049(var_y, context)?;
            let expr_2 = eq(cleanup_int256(expr, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            // switch
            let δ = expr_2;
            if δ == U256::from(0x0u128) {
                let expr_3 = constant_uUNIT_12217(context)?;
                let expr_4 = eq(cleanup_int256(expr, context)?, cleanup_int256(expr_3, context)?, context)?;
                if expr_4 != U256::ZERO {
                    let expr_5 = constant_UNIT_12224(context)?;
                    var_result = expr_5;
                    return Ok(var_result);
                }
            }
            let expr_10 = eq(cleanup_int256(expr_1, context)?, convert_rational_0_by_1_to_int256(U256::from(0x0u128), context)?, context)?;
            // switch
            let δ = expr_10;
            if δ == U256::from(0x0u128) {
                let expr_11 = constant_uUNIT_12217(context)?;
                let expr_12 = eq(cleanup_int256(expr_1, context)?, cleanup_int256(expr_11, context)?, context)?;
                if expr_12 != U256::ZERO {
                    var_result = var_x;
                    return Ok(var_result);
                }
            }
            let expr_14 = fun_log2(var_x, context)?;
            let expr_15 = fun_mul(expr_14, var_y, context)?;
            let expr_16 = fun_exp2(expr_15, context)?;
            var_result = expr_16;
            Ok(var_result)
        }

        pub fn memory_array_index_access_struct_Segment_dyn<CI>(baseRef: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_Segment_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn wrapping_add_uint128<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            sum = cleanup_uint128(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn wrapping_sub_uint40<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            diff = cleanup_uint40(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn zero_value_for_split_uint128<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_split_uint40<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_VestingMath_calculateLockupDynamicStreamedAmount<CI>(var_depositedAmount: U256, var_segments_5741_mpos: U256, var_blockTimestamp: U256, var_timestamps_5746_mpos: U256, var_withdrawnAmount: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let _1 = read_from_memoryt_uint40(add(var_timestamps_5746_mpos, U256::from(0x0u128), context)?, context)?;
            let expr = gt(cleanup_uint40(_1, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr != U256::ZERO {
                var = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var);
            }
            let _2 = read_from_memoryt_uint40(add(var_timestamps_5746_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1 = iszero(gt(cleanup_uint40(_2, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                var = var_depositedAmount;
                return Ok(var);
            }
            let mut var_previousSegmentAmounts = U256::ZERO;
            var_previousSegmentAmounts = zero_uint128;
            let _1955_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5741_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _3 = read_from_memoryt_uint40(add(_1955_mpos, U256::from(0x40u128), context)?, context)?;
            let mut var_currentSegmentTimestamp = _3;
            let mut var_index = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_2 = lt(cleanup_uint40(var_currentSegmentTimestamp, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
                    if iszero(expr_2, context)? != U256::ZERO {
                        break;
                    }
                    let _1962_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5741_mpos, var_index, context)?, context)?;
                    let _4 = read_from_memoryt_uint128(add(_1962_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_3 = wrapping_add_uint128(var_previousSegmentAmounts, _4, context)?;
                    var_previousSegmentAmounts = expr_3;
                    let _5 = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
                    let expr_4 = wrapping_add_uint256(var_index, _5, context)?;
                    var_index = expr_4;
                    let _1970_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5741_mpos, expr_4, context)?, context)?;
                    let _6 = read_from_memoryt_uint40(add(_1970_mpos, U256::from(0x40u128), context)?, context)?;
                    var_currentSegmentTimestamp = _6;
                }
                // post
                {

                }
            }
            let _1975_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5741_mpos, var_index, context)?, context)?;
            let _7 = read_from_memoryt_uint128(add(_1975_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_5 = fun_intoSD59x18(_7, context)?;
            let _1980_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5741_mpos, var_index, context)?, context)?;
            let _8 = read_from_memoryt_userDefinedValueType_UD2x18(add(_1980_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_6 = fun_intoSD59x18_14589(_8, context)?;
            let _1985_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5741_mpos, var_index, context)?, context)?;
            let _9 = read_from_memoryt_uint40(add(_1985_mpos, U256::from(0x40u128), context)?, context)?;
            var_currentSegmentTimestamp = _9;
            let mut var_previousTimestamp = U256::ZERO;
            let zero_t_uint40 = zero_value_for_split_uint40(context)?;
            var_previousTimestamp = zero_t_uint40;
            let expr_7 = eq(cleanup_uint256(var_index, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let δ = expr_7;
            if δ == U256::from(0x0u128) {
                let expr_8 = wrapping_sub_uint256(var_index, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let _1992_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5741_mpos, expr_8, context)?, context)?;
                let _10 = read_from_memoryt_uint40(add(_1992_mpos, U256::from(0x40u128), context)?, context)?;
                var_previousTimestamp = _10;
            }
            let expr_9 = wrapping_sub_uint40(var_blockTimestamp, var_previousTimestamp, context)?;
            let expr_10 = fun_intoSD59x18_8301(expr_9, context)?;
            let expr_11 = wrapping_sub_uint40(_9, var_previousTimestamp, context)?;
            let expr_12 = fun_intoSD59x18_8301(expr_11, context)?;
            let expr_13 = fun_div_13325(expr_10, expr_12, context)?;
            let expr_14 = fun_pow(expr_13, expr_6, context)?;
            let expr_15 = fun_mul(expr_14, expr_5, context)?;
            let expr_16 = fun_gt(expr_15, expr_5, context)?;
            if expr_16 != U256::ZERO {
                let expr_17 = gt(cleanup_uint128(var_previousSegmentAmounts, context)?, cleanup_uint128(var_withdrawnAmount, context)?, context)?;
                let mut expr_18 = U256::ZERO;
                // switch
                let δ = expr_17;
                if δ == U256::from(0x0u128) {
                    expr_18 = var_withdrawnAmount;
                }
                var = expr_18;
                return Ok(var);
            }
            let expr_19 = fun_intoUint256(expr_15, context)?;
            let expr_20 = convert_uint256_to_uint128(expr_19, context)?;
            let expr_21 = wrapping_add_uint128(var_previousSegmentAmounts, expr_20, context)?;
            var = expr_21;
            Ok(var)
        }

        pub fn fun_unwrap<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn zero_value_for_split_userDefinedValueType_UD60x18<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_wrap_9918<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn fun_div<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_t_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_t_userDefinedValueType_UD60x18;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = constant_uUNIT(context)?;
            let expr_2 = fun_unwrap(var_y, context)?;
            let expr_3 = fun_mulDiv(expr, expr_1, expr_2, context)?;
            let expr_4 = fun_wrap_9918(expr_3, context)?;
            var_result = expr_4;
            Ok(var_result)
        }

        pub fn fun_intoUint128<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_result = zero_uint128;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            let expr_1 = constant_MAX_UINT128(context)?;
            let expr_2 = gt(cleanup_uint256(expr, context)?, convert_uint128_to_uint256(expr_1, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x248b56e7u128), context)?, context)?;
                let _1 = abi_encode_tuple_userDefinedValueType_UD60x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_3 = convert_uint256_to_uint128(expr, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_mul_11192<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = fun_unwrap(var_y, context)?;
            let expr_2 = fun_mulDiv18(expr, expr_1, context)?;
            let expr_3 = fun_wrap_9918(expr_2, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_ud<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn wrapping_sub_uint128<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            diff = cleanup_uint128(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn fun_VestingMath_calculateLockupLinearStreamedAmount<CI>(var_depositedAmount: U256, var_blockTimestamp: U256, var_timestamps_5932_mpos: U256, var_cliffTime: U256, var_unlockAmounts_5937_mpos: U256, var_withdrawnAmount: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let _1 = read_from_memoryt_uint40(add(var_timestamps_5932_mpos, U256::from(0x0u128), context)?, context)?;
            let expr = gt(cleanup_uint40(_1, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr != U256::ZERO {
                var = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var);
            }
            let _2 = add(var_timestamps_5932_mpos, U256::from(0x20u128), context)?;
            let _3 = read_from_memoryt_uint40(_2, context)?;
            let expr_1 = iszero(gt(cleanup_uint40(_3, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                var = var_depositedAmount;
                return Ok(var);
            }
            let expr_2 = gt(cleanup_uint40(var_cliffTime, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr_2 != U256::ZERO {
                let _4 = read_from_memoryt_uint128(add(var_unlockAmounts_5937_mpos, U256::from(0x0u128), context)?, context)?;
                var = _4;
                return Ok(var);
            }
            let _5 = read_from_memoryt_uint128(add(var_unlockAmounts_5937_mpos, U256::from(0x0u128), context)?, context)?;
            let _6 = read_from_memoryt_uint128(add(var_unlockAmounts_5937_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_3 = wrapping_add_uint128(_5, _6, context)?;
            let expr_4 = iszero(lt(cleanup_uint128(expr_3, context)?, cleanup_uint128(var_depositedAmount, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                var = var_depositedAmount;
                return Ok(var);
            }
            let mut var_elapsedTime = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_elapsedTime = zero_userDefinedValueType_UD60x18;
            let mut var_streamableRange = U256::ZERO;
            var_streamableRange = zero_userDefinedValueType_UD60x18;
            let expr_5 = eq(cleanup_uint40(var_cliffTime, context)?, convert_rational_by_to_uint40(U256::from(0x0u128), context)?, context)?;
            // switch
            let δ = expr_5;
            if δ == U256::from(0x0u128) {
                let expr_6 = wrapping_sub_uint40(var_blockTimestamp, var_cliffTime, context)?;
                let _7 = convert_uint40_to_uint256(expr_6, context)?;
                let expr_7 = fun_ud(_7, context)?;
                var_elapsedTime = expr_7;
                let _8 = read_from_memoryt_uint40(_2, context)?;
                let expr_8 = wrapping_sub_uint40(_8, var_cliffTime, context)?;
                let _9 = convert_uint40_to_uint256(expr_8, context)?;
                let expr_9 = fun_ud(_9, context)?;
                var_streamableRange = expr_9;
            }
            let expr_14 = fun_div(var_elapsedTime, var_streamableRange, context)?;
            let expr_15 = wrapping_sub_uint128(var_depositedAmount, expr_3, context)?;
            let _16 = convert_uint128_to_uint256(expr_15, context)?;
            let expr_16 = fun_ud(_16, context)?;
            let expr_17 = fun_mul_11192(expr_14, expr_16, context)?;
            let expr_18 = fun_intoUint128(expr_17, context)?;
            let expr_19 = wrapping_add_uint128(expr_3, expr_18, context)?;
            let expr_20 = gt(cleanup_uint128(expr_19, context)?, cleanup_uint128(var_depositedAmount, context)?, context)?;
            if expr_20 != U256::ZERO {
                var = var_withdrawnAmount;
                return Ok(var);
            }
            var = expr_19;
            Ok(var)
        }

        pub fn memory_array_index_access_struct_Tranche_dyn<CI>(baseRef: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_Tranche_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn fun_VestingMath_calculateLockupTranchedStreamedAmount<CI>(var_depositedAmount: U256, var_blockTimestamp: U256, var_timestamps_6081_mpos: U256, var_tranches_6085_mpos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let _1 = read_from_memoryt_uint40(add(var_timestamps_6081_mpos, U256::from(0x0u128), context)?, context)?;
            let expr = gt(cleanup_uint40(_1, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr != U256::ZERO {
                var = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var);
            }
            let _2 = read_from_memoryt_uint40(add(var_timestamps_6081_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1 = iszero(gt(cleanup_uint40(_2, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                var = var_depositedAmount;
                return Ok(var);
            }
            let _1858_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_6085_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _3 = read_from_memoryt_uint40(add(_1858_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_2 = gt(cleanup_uint40(_3, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
            if expr_2 != U256::ZERO {
                var = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                return Ok(var);
            }
            let _1863_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_6085_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _4 = read_from_memoryt_uint128(add(_1863_mpos, U256::from(0x0u128), context)?, context)?;
            let mut var_streamedAmount = _4;
            let expr_3 = array_length_array_struct_Tranche_dyn(var_tranches_6085_mpos, context)?;
            let expr_4 = U256::from(0x1u128);
            let mut var_i = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
            // for loop
            while expr_4 != U256::ZERO {
                // body
                {
                    let expr_5 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr_3, context)?, context)?;
                    if iszero(expr_5, context)? != U256::ZERO {
                        break;
                    }
                    let _1873_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_6085_mpos, var_i, context)?, context)?;
                    let _6 = read_from_memoryt_uint40(add(_1873_mpos, U256::from(0x20u128), context)?, context)?;
                    let expr_6 = gt(cleanup_uint40(_6, context)?, cleanup_uint40(var_blockTimestamp, context)?, context)?;
                    if expr_6 != U256::ZERO {
                        break;
                    }
                    let _1879_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_6085_mpos, var_i, context)?, context)?;
                    let _7 = read_from_memoryt_uint128(add(_1879_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_7 = wrapping_add_uint128(var_streamedAmount, _7, context)?;
                    var_streamedAmount = expr_7;
                }
                // post
                {
                    let _5 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _5;
                }
            }
            var = var_streamedAmount;
            Ok(var)
        }

        pub fn mapping_index_access_mapping_uint256_array_struct_Segment_storage_dyn_of_uint256<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_uint256_to_uint256(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_uint256_array_struct_Tranche_storage_dyn_of_uint256<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_uint256_to_uint256(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_uint256_struct_UnlockAmounts_storage_of_uint256<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_uint256_to_uint256(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_uint256_uint40_of_uint256<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_uint256_to_uint256(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn extract_from_storage_value_offset_0t_uint40<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint40(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_0_uint40<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_0t_uint40(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn shift_right_200_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xc8u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offsett_uint40<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint40(shift_right_200_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_25_uint40<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_uint40(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn shift_right_184_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xb8u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offsett_enum_Model<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_enum_Model(shift_right_184_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_enum_Model<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_enum_Model(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn extract_from_storage_value_offset_20t_uint40<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint40(shift_right_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_uint40<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_20t_uint40(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn fun_calculateStreamedAmount<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let expr = convert_uint256_to_uint40(timestamp(context)?, context)?;
            let _1199_slot = U256::from(0xau128);
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1199_slot, var_streamId, context)?;
            let _2 = add(_1, U256::from(0x2u128), context)?;
            let _3 = read_from_storage_split_offset_t_uint128(add(_2, U256::from(0x0u128), context)?, context)?;
            let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1199_slot, var_streamId, context)?;
            let _5 = read_from_storage_split_offset_enum_Model(add(_4, U256::from(0x1u128), context)?, context)?;
            let mut var_streamedAmount = U256::ZERO;
            var_streamedAmount = zero_uint128;
            let _6 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1199_slot, var_streamId, context)?;
            let _7 = read_from_storage_split_offset_uint40(add(_6, U256::from(0x0u128), context)?, context)?;
            let _8 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1199_slot, var_streamId, context)?;
            let _9 = read_from_storage_split_offset_25_uint40(add(_8, U256::from(0x0u128), context)?, context)?;
            let expr_638_mpos = allocate_memory_struct_struct_Timestamps_storage_ptr(context)?;
            write_to_memory_uint40(add(expr_638_mpos, U256::from(0x0u128), context)?, _7, context)?;
            write_to_memory_uint40(add(expr_638_mpos, U256::from(0x20u128), context)?, _9, context)?;
            let expr_1 = eq(cleanup_enum_Model(_5, context)?, cleanup_enum_Model(U256::from(0x1u128), context)?, context)?;
            // switch
            let δ = expr_1;
            if δ == U256::from(0x0u128) {
                let expr_2 = eq(cleanup_enum_Model(_5, context)?, cleanup_enum_Model(U256::from(0x0u128), context)?, context)?;
                // switch
                let δ = expr_2;
                if δ == U256::from(0x0u128) {
                    let expr_3 = eq(cleanup_enum_Model(_5, context)?, cleanup_enum_Model(U256::from(0x2u128), context)?, context)?;
                    if expr_3 != U256::ZERO {
                        let _10 = mapping_index_access_mapping_uint256_array_struct_Tranche_storage_dyn_of_uint256(U256::from(0xdu128), var_streamId, context)?;
                        let _1236_mpos = convert_array_array_struct_Tranche_storage_dyn_to_array_struct_Tranche_dyn(_10, context)?;
                        let expr_4 = fun_VestingMath_calculateLockupTranchedStreamedAmount(_3, expr, expr_638_mpos, _1236_mpos, context)?;
                        var_streamedAmount = expr_4;
                    }
                }
            }
            var = var_streamedAmount;
            Ok(var)
        }

        pub fn fun_revert<CI>(var_returndata_6763_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = array_length_bytes(var_returndata_6763_mpos, context)?;
            let expr_1 = gt(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            // switch
            let δ = expr_1;
            if δ == U256::from(0x0u128) {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0xa12f521u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_verifyCallResultFromTarget<CI>(var_target: U256, var_success: U256, var_returndata_mpos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_mpos = U256::ZERO;
            let zero_bytes_mpos = zero_value_for_split_bytes(context)?;
            var_mpos = zero_bytes_mpos;
            let expr = cleanup_bool(iszero(var_success, context)?, context)?;
            // switch
            let δ = expr;
            if δ == U256::from(0x0u128) {
                let expr_1 = array_length_bytes(var_returndata_mpos, context)?;
                let expr_2 = eq(cleanup_uint256(expr_1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                let mut expr_3 = expr_2;
                if expr_2 != U256::ZERO {
                    let expr_4 = extcodesize(var_target, context)?;
                    let expr_5 = eq(cleanup_uint256(expr_4, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
                    expr_3 = expr_5;
                }
                if expr_3 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x9996b315u128), context)?, context)?;
                    let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_target, context)?;
                    revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
                }
                var_mpos = var_returndata_mpos;
                return Ok(var_mpos);
            }
            Ok(var_mpos)
        }

        pub fn fun_functionCallWithValue<CI>(var_target: U256, var_data_mpos: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_6610_mpos = U256::ZERO;
            let zero_t_bytes_mpos = zero_value_for_split_bytes(context)?;
            var_6610_mpos = zero_t_bytes_mpos;
            let expr = convert_contract_Address_to_address(address(context)?, context)?;
            let expr_1 = balance(expr, context)?;
            let expr_2 = lt(cleanup_uint256(expr_1, context)?, cleanup_uint256(var_value, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xcd786059u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let _2 = mload(var_data_mpos, context)?;
            let expr_6637_component = call(gas(context)?, var_target, var_value, add(var_data_mpos, U256::from(0x20u128), context)?, _2, U256::from(0x0u128), U256::from(0x0u128), context)?;
            let expr_component_mpos = extract_returndata(context)?;
            let expr_6643_mpos = fun_verifyCallResultFromTarget(var_target, expr_6637_component, expr_component_mpos, context)?;
            var_6610_mpos = expr_6643_mpos;
            Ok(var_6610_mpos)
        }

        pub fn fun_functionCall<CI>(var_target: U256, var_data_6588_mpos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_6591_mpos = U256::ZERO;
            let zero_bytes_memory_ptr_mpos = zero_value_for_split_bytes(context)?;
            var_6591_mpos = zero_bytes_memory_ptr_mpos;
            let _1 = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            let expr_6597_mpos = fun_functionCallWithValue(var_target, var_data_6588_mpos, _1, context)?;
            var_6591_mpos = expr_6597_mpos;
            Ok(var_6591_mpos)
        }

        pub fn fun_callOptionalReturn<CI>(var_token_address: U256, var_data_1396_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_contract_IERC20_to_address(var_token_address, context)?;
            let expr_1407_mpos = fun_functionCall(expr, var_data_1396_mpos, context)?;
            let expr_1 = array_length_bytes(expr_1407_mpos, context)?;
            let expr_2 = iszero(eq(cleanup_uint256(expr_1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let mut expr_3 = expr_2;
            if expr_2 != U256::ZERO {
                let expr_4 = abi_decode_bool_fromMemory(add(expr_1407_mpos, U256::from(0x20u128), context)?, add(add(expr_1407_mpos, U256::from(0x20u128), context)?, array_length_bytes(expr_1407_mpos, context)?, context)?, context)?;
                let expr_5 = cleanup_bool(iszero(expr_4, context)?, context)?;
                expr_3 = expr_5;
            }
            if expr_3 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5274afe7u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_safeTransfer<CI>(var_token_1222_address: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = convert_uint32_to_bytes4(U256::from(0xa9059cbbu128), context)?;
            let expr_1238_mpos = allocate_unbounded(context)?;
            let mut _2 = add(expr_1238_mpos, U256::from(0x20u128), context)?;
            mstore(_2, _1, context)?;
            _2 = add(_2, U256::from(0x4u128), context)?;
            let _3 = abi_encode_address_uint256(_2, var_to, var_value, context)?;
            mstore(expr_1238_mpos, sub(_3, add(expr_1238_mpos, U256::from(0x20u128), context)?, context)?, context)?;
            finalize_allocation(expr_1238_mpos, sub(_3, expr_1238_mpos, context)?, context)?;
            fun_callOptionalReturn(var_token_1222_address, expr_1238_mpos, context)?;
            Ok(())
        }

        pub fn shift_right_240_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xf0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_30t_bool<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_240_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_30_bool<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_30t_bool(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn extract_from_storage_value_offsett_contract_IERC20<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_contract_IERC20(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_contract_IERC20<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_contract_IERC20(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn fun__cancel<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_calculateStreamedAmount(var_streamId, context)?;
            let _1330_slot = U256::from(0xau128);
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
            let _2 = add(_1, U256::from(0x2u128), context)?;
            let var_amounts_4030_mpos = convert_struct_Amounts_storage_to_struct_Amounts(_2, context)?;
            let _3 = add(var_amounts_4030_mpos, U256::from(0x0u128), context)?;
            let _4 = read_from_memoryt_uint128(_3, context)?;
            let expr_1 = iszero(lt(cleanup_uint128(expr, context)?, cleanup_uint128(_4, context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xfa36c717u128), context)?, context)?;
                let _5 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_5, U256::from(0x0u128), context)?, context)?;
            }
            let _6 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
            let _7 = read_from_storage_split_offset_30_bool(add(_6, U256::from(0x0u128), context)?, context)?;
            let expr_2 = cleanup_bool(iszero(_7, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5c7470b7u128), context)?, context)?;
                let _8 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_8, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_senderAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_senderAmount = zero_uint128;
            let _9 = read_from_memoryt_uint128(_3, context)?;
            let expr_3 = wrapping_sub_uint128(_9, expr, context)?;
            var_senderAmount = expr_3;
            let _10 = read_from_memoryt_uint128(add(var_amounts_4030_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_4 = checked_sub_uint128(expr, _10, context)?;
            let expr_5 = U256::from(0x1u128);
            let _11 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
            update_storage_value_offsett_bool_to_t_bool(add(_11, U256::from(0x0u128), context)?, expr_5, context)?;
            let _12 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
            update_storage_value_offset_30t_bool_to_bool(add(_12, U256::from(0x0u128), context)?, U256::from(0x0u128), context)?;
            let expr_6 = eq(cleanup_uint128(expr_4, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr_6 != U256::ZERO {
                let _13 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
                update_storage_value_offsett_bool_to_bool(add(_13, expr_5, context)?, expr_5, context)?;
            }
            let _14 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
            let _15 = add(_14, U256::from(0x2u128), context)?;
            update_storage_value_offsett_uint128_to_uint128(add(_15, expr_5, context)?, expr_3, context)?;
            let _16 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
            let _17 = read_from_storage_split_offset_address(add(_16, U256::from(0x0u128), context)?, context)?;
            let expr_7 = fun__ownerOf(var_streamId, context)?;
            let _18 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1330_slot, var_streamId, context)?;
            let _1397_address = read_from_storage_split_offset_contract_IERC20(add(_18, expr_5, context)?, context)?;
            let _19 = convert_uint128_to_uint256(expr_3, context)?;
            fun_safeTransfer(_1397_address, _17, _19, context)?;
            let _20 = convert_address_to_address(_17, context)?;
            let _21 = convert_address_to_address(expr_7, context)?;
            let _1411_address = convert_contract_IERC20_to_contract_IERC20(_1397_address, context)?;
            let _22 = allocate_unbounded(context)?;
            let _23 = abi_encode_uint256_uint128_uint128(_22, var_streamId, expr_3, expr_4, context)?;
            log4(_22, sub(_23, _22, context)?, U256::from_be_slice(&[0x5e, 0xdb, 0x27, 0xd6, 0xc1, 0xa3, 0x27, 0x51, 0x3b, 0x90, 0xa7, 0x92, 0x05, 0x0d, 0xeb, 0xf0, 0x74, 0xb7, 0x19, 0x44, 0x44, 0x88, 0x5e, 0x31, 0x44, 0xd4, 0xde, 0xcc, 0x5c, 0xaa, 0xaa, 0x50]), _20, _21, _1411_address, context)?;
            let _24 = allocate_unbounded(context)?;
            let _25 = abi_encode_uint256(_24, var_streamId, context)?;
            log1(_24, sub(_25, _24, context)?, U256::from_be_slice(&[0xf8, 0xe1, 0xa1, 0x5a, 0xba, 0x93, 0x98, 0xe0, 0x19, 0xf0, 0xb4, 0x9d, 0xf1, 0xa4, 0xfd, 0xe9, 0x8e, 0xe1, 0x7a, 0xe3, 0x45, 0xcb, 0x5f, 0x6b, 0x5e, 0x2c, 0x27, 0xf5, 0x03, 0x3e, 0x8c, 0xe7]), context)?;
            let _26 = mapping_index_access_mapping_address_bool_of_address(U256::from(0x9u128), expr_7, context)?;
            let _27 = read_from_storage_split_offset_0_bool(_26, context)?;
            if _27 != U256::ZERO {
                let expr_4163_address = convert_address_to_contract_ISablierLockupRecipient(expr_7, context)?;
                let expr_4164_address = convert_contract_ISablierLockupRecipient_to_address(expr_4163_address, context)?;
                let _28 = allocate_unbounded(context)?;
                mstore(_28, shift_left_224(U256::from(0x6a5788f8u128), context)?, context)?;
                let _29 = abi_encode_uint256_address_uint128_uint128(add(_28, U256::from(0x4u128), context)?, var_streamId, _17, expr_3, expr_4, context)?;
                let _30 = call(gas(context)?, expr_4164_address, U256::from(0x0u128), _28, sub(_29, _28, context)?, _28, U256::from(0x20u128), context)?;
                if iszero(_30, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                let mut expr_8 = U256::ZERO;
                if _30 != U256::ZERO {
                    let mut _31 = U256::from(0x20u128);
                    if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                        _31 = returndatasize(context)?;
                    }
                    finalize_allocation(_28, _31, context)?;
                    expr_8 = abi_decode_tuple_bytes4_fromMemory(_28, add(_28, _31, context)?, context)?;
                }
                let expr_9 = iszero(eq(cleanup_bytes4(expr_8, context)?, cleanup_bytes4(shl(U256::from(0xe3u128), U256::from(0xd4af11fu128), context)?, context)?, context)?, context)?;
                if expr_9 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5f3a039du128), context)?, context)?;
                    let _32 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr_7, context)?;
                    revert(U256::from(0x0u128), sub(_32, U256::from(0x0u128), context)?, context)?;
                }
            }
            Ok(())
        }

        pub fn fun_isCallerStreamSender<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_address(add(_1, U256::from(0x0u128), context)?, context)?;
            let expr = eq(cleanup_address(caller(context)?, context)?, cleanup_address(_2, context)?, context)?;
            var = expr;
            Ok(var)
        }

        pub fn shift_right_248_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xf8u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offsett_bool<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_bool(shift_right_248_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_31_bool<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_bool(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn fun_cancel_inner<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_t_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            // switch
            let δ = _2;
            if δ == U256::from(0x0u128) {
                let _3 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
                let _4 = read_from_storage_split_offset_31_bool(add(_3, U256::from(0x0u128), context)?, context)?;
                if _4 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xe707ae4fu128), context)?, context)?;
                    let _5 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                    revert(U256::from(0x0u128), sub(_5, U256::from(0x0u128), context)?, context)?;
                }
            }
            let expr = fun_isCallerStreamSender(var_streamId, context)?;
            let expr_1 = cleanup_bool(iszero(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4dda2c39u128), context)?, context)?;
                let _7 = abi_encode_uint256_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, caller(context)?, context)?;
                revert(U256::from(0x0u128), sub(_7, U256::from(0x0u128), context)?, context)?;
            }
            fun__cancel(var_streamId, context)?;
            Ok(())
        }

        pub fn modifier_notNull_3242<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            fun_cancel_inner(var_streamId, context)?;
            Ok(())
        }

        pub fn modifier_noDelegateCall_3239<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_preventDelegateCall(context)?;
            modifier_notNull_3242(var_streamId, context)?;
            Ok(())
        }

        pub fn fun_cancel<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_noDelegateCall_3239(var_streamId, context)?;
            Ok(())
        }

        pub fn external_fun_cancel<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_cancel(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn read_from_calldatat_uint256<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_uint256(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn fun_cancelMultiple_inner<CI>(var_streamIds_offset: U256, var_streamIds_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = array_length_array_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, context)?;
            let mut var_i = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_1 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_1, context)? != U256::ZERO {
                        break;
                    }
                    let expr_2 = read_from_calldatat_uint256(calldata_array_index_access_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, var_i, context)?, context)?;
                    fun_cancel(expr_2, context)?;
                }
                // post
                {
                    let _1 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _1;
                }
            }
            Ok(())
        }

        pub fn modifier_noDelegateCall_3295<CI>(var_streamIds_3291_offset: U256, var_streamIds_3291_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_preventDelegateCall(context)?;
            fun_cancelMultiple_inner(var_streamIds_3291_offset, var_streamIds_3291_length, context)?;
            Ok(())
        }

        pub fn fun_cancelMultiple<CI>(var_streamIds_offset: U256, var_streamIds_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_noDelegateCall_3295(var_streamIds_offset, var_streamIds_length, context)?;
            Ok(())
        }

        pub fn external_fun_cancelMultiple<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1) = abi_decode_array_uint256_dyn_calldata_ptr(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_cancelMultiple(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_collectFees<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_contract_SablierLockupBase_to_address(address(context)?, context)?;
            let expr_1 = balance(expr, context)?;
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let _2 = allocate_unbounded(context)?;
            let _3 = sub(abi_encode_packed_stringliteral_c5d2(_2, context)?, _2, context)?;
            let expr_3341_component = call(gas(context)?, _1, expr_1, _2, _3, U256::from(0x0u128), U256::from(0x0u128), context)?;
            pop(extract_returndata(context)?, context)?;
            let expr_2 = cleanup_bool(iszero(expr_3341_component, context)?, context)?;
            if expr_2 != U256::ZERO {
                let _4 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xdf68418du128), context)?, context)?;
                let _5 = abi_encode_address_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _4, expr_1, context)?;
                revert(U256::from(0x0u128), sub(_5, U256::from(0x0u128), context)?, context)?;
            }
            let _6 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let _7 = convert_address_to_address(_6, context)?;
            let _8 = convert_uint256_to_uint256(expr_1, context)?;
            let _9 = allocate_unbounded(context)?;
            let _10 = abi_encode_tuple(_9, context)?;
            log3(_9, sub(_10, _9, context)?, U256::from_be_slice(&[0xc9, 0xa0, 0x21, 0x4d, 0x4c, 0x5f, 0xed, 0x63, 0x41, 0x23, 0x32, 0x60, 0xa7, 0xbc, 0x0c, 0x9a, 0xc1, 0xd7, 0x12, 0xcc, 0x58, 0x82, 0x16, 0x5f, 0xa9, 0x85, 0xbb, 0x71, 0xd4, 0xf2, 0x07, 0xae]), _7, _8, context)?;
            Ok(())
        }

        pub fn external_fun_collectFees<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_collectFees(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn memory_array_index_access_struct_SegmentWithDuration_dyn<CI>(baseRef: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_SegmentWithDuration_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn wrapping_add_uint40<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            sum = cleanup_uint40(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn zero_value_for_split_array_struct_Segment_dyn<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_Helpers_calculateSegmentTimestamps<CI>(var_segmentsWithDuration_mpos: U256, var_startTime: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_segmentsWithTimestamps_mpos = U256::ZERO;
            let zero_array_struct_Segment_dyn_mpos = zero_value_for_split_array_struct_Segment_dyn(context)?;
            var_segmentsWithTimestamps_mpos = zero_array_struct_Segment_dyn_mpos;
            let expr = array_length_array_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, context)?;
            let expr_4861_mpos = allocate_and_zero_memory_array_array_struct_Segment_dyn(expr, context)?;
            var_segmentsWithTimestamps_mpos = expr_4861_mpos;
            let _1114_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _1 = read_from_memoryt_uint128(add(_1114_mpos, U256::from(0x0u128), context)?, context)?;
            let _1118_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _2 = read_from_memoryt_userDefinedValueType_UD2x18(add(_1118_mpos, U256::from(0x20u128), context)?, context)?;
            let _1123_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _3 = read_from_memoryt_uint40(add(_1123_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_1 = wrapping_add_uint40(var_startTime, _3, context)?;
            let expr_4883_mpos = allocate_memory_struct_struct_Segment_storage_ptr(context)?;
            write_to_memory_uint128(add(expr_4883_mpos, U256::from(0x0u128), context)?, _1, context)?;
            write_to_memory_userDefinedValueType_UD2x18(add(expr_4883_mpos, U256::from(0x20u128), context)?, _2, context)?;
            write_to_memory_uint40(add(expr_4883_mpos, U256::from(0x40u128), context)?, expr_1, context)?;
            mstore(memory_array_index_access_struct_Segment_dyn(expr_4861_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, expr_4883_mpos, context)?;
            pop(mload(memory_array_index_access_struct_Segment_dyn(expr_4861_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?, context)?;
            let expr_2 = U256::from(0x1u128);
            let mut var_i = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
            // for loop
            while expr_2 != U256::ZERO {
                // body
                {
                    let expr_3 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_3, context)? != U256::ZERO {
                        break;
                    }
                    let _1134_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, var_i, context)?, context)?;
                    let _5 = read_from_memoryt_uint128(add(_1134_mpos, U256::from(0x0u128), context)?, context)?;
                    let _1139_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, var_i, context)?, context)?;
                    let _6 = read_from_memoryt_userDefinedValueType_UD2x18(add(_1139_mpos, U256::from(0x20u128), context)?, context)?;
                    let expr_4 = wrapping_sub_uint256(var_i, convert_rational_1_by_1_to_uint256(expr_2, context)?, context)?;
                    let _1144_mpos = mload(memory_array_index_access_struct_Segment_dyn(expr_4861_mpos, expr_4, context)?, context)?;
                    let _7 = read_from_memoryt_uint40(add(_1144_mpos, U256::from(0x40u128), context)?, context)?;
                    let _1149_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, var_i, context)?, context)?;
                    let _8 = read_from_memoryt_uint40(add(_1149_mpos, U256::from(0x40u128), context)?, context)?;
                    let expr_5 = wrapping_add_uint40(_7, _8, context)?;
                    let expr_4920_mpos = allocate_memory_struct_struct_Segment_storage_ptr(context)?;
                    write_to_memory_uint128(add(expr_4920_mpos, U256::from(0x0u128), context)?, _5, context)?;
                    write_to_memory_userDefinedValueType_UD2x18(add(expr_4920_mpos, U256::from(0x20u128), context)?, _6, context)?;
                    write_to_memory_uint40(add(expr_4920_mpos, U256::from(0x40u128), context)?, expr_5, context)?;
                    mstore(memory_array_index_access_struct_Segment_dyn(expr_4861_mpos, var_i, context)?, expr_4920_mpos, context)?;
                    pop(mload(memory_array_index_access_struct_Segment_dyn(expr_4861_mpos, var_i, context)?, context)?, context)?;
                }
                // post
                {
                    let _4 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _4;
                }
            }
            Ok(var_segmentsWithTimestamps_mpos)
        }

        pub fn fun_gt_10323<CI>(var_x: U256, var_y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = fun_unwrap(var_y, context)?;
            let expr_2 = gt(cleanup_uint256(expr, context)?, cleanup_uint256(expr_1, context)?, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn fun_isZero<CI>(var_x: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            var_result = expr_1;
            Ok(var_result)
        }

        pub fn zero_value_for_split_struct_CreateAmounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_CreateAmounts(context)?;
            Ok(ret)
        }

        pub fn fun_Helpers_checkAndCalculateBrokerFee<CI>(var_totalAmount: U256, var_brokerFee: U256, var_maxBrokerFee: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_amounts_5184_mpos = U256::ZERO;
            let zero_t_struct_CreateAmounts_memory_ptr_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_amounts_5184_mpos = zero_t_struct_CreateAmounts_memory_ptr_mpos;
            let expr = eq(cleanup_uint128(var_totalAmount, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                let expr_5193_mpos = allocate_memory_struct_struct_CreateAmounts_storage_ptr(context)?;
                let _1 = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                write_to_memory_uint128(add(expr_5193_mpos, U256::from(0x0u128), context)?, _1, context)?;
                write_to_memory_uint128(add(expr_5193_mpos, U256::from(0x20u128), context)?, _1, context)?;
                var_amounts_5184_mpos = expr_5193_mpos;
                return Ok(var_amounts_5184_mpos);
            }
            let expr_1 = fun_isZero(var_brokerFee, context)?;
            if expr_1 != U256::ZERO {
                let expr_5204_mpos = allocate_memory_struct_struct_CreateAmounts_storage_ptr(context)?;
                write_to_memory_uint128(add(expr_5204_mpos, U256::from(0x0u128), context)?, var_totalAmount, context)?;
                let _2 = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                write_to_memory_uint128(add(expr_5204_mpos, U256::from(0x20u128), context)?, _2, context)?;
                var_amounts_5184_mpos = expr_5204_mpos;
                return Ok(var_amounts_5184_mpos);
            }
            let expr_2 = fun_gt_10323(var_brokerFee, var_maxBrokerFee, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4816cae3u128), context)?, context)?;
                let _3 = abi_encode_userDefinedValueType_UD60x18_userDefinedValueType_UD60x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_brokerFee, var_maxBrokerFee, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let _4 = convert_uint128_to_uint256(var_totalAmount, context)?;
            let expr_3 = fun_ud(_4, context)?;
            let expr_4 = fun_mul_11192(expr_3, var_brokerFee, context)?;
            let expr_5 = fun_intoUint128(expr_4, context)?;
            let _5 = add(var_amounts_5184_mpos, U256::from(0x20u128), context)?;
            write_to_memory_uint128(_5, expr_5, context)?;
            let _6 = read_from_memoryt_uint128(_5, context)?;
            let expr_6 = gt(cleanup_uint128(var_totalAmount, context)?, cleanup_uint128(_6, context)?, context)?;
            assert_helper(expr_6, context)?;
            let _7 = read_from_memoryt_uint128(_5, context)?;
            let expr_7 = checked_sub_uint128(var_totalAmount, _7, context)?;
            write_to_memory_uint128(add(var_amounts_5184_mpos, U256::from(0x0u128), context)?, expr_7, context)?;
            Ok(var_amounts_5184_mpos)
        }

        pub fn fun_Helpers_checkCreateStream<CI>(var_sender: U256, var_depositAmount: U256, var_startTime: U256, var_shape_5356_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_sender, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xfeb974b3u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = eq(cleanup_uint128(var_depositAmount, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x59d19765u128), context)?, context)?;
                let _2 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let expr_3 = eq(cleanup_uint40(var_startTime, context)?, convert_rational_by_to_uint40(U256::from(0x0u128), context)?, context)?;
            if expr_3 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe7u128), U256::from(0xfcdef5u128), context)?, context)?;
                let _3 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let expr_5395_mpos = convert_array_string_to_bytes(var_shape_5356_mpos, context)?;
            let expr_4 = array_length_bytes(expr_5395_mpos, context)?;
            let expr_5 = gt(cleanup_uint256(expr_4, context)?, convert_rational_32_by_1_to_uint256(U256::from(0x20u128), context)?, context)?;
            if expr_5 != U256::ZERO {
                let expr_6 = array_length_bytes(expr_5395_mpos, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x1f68a771u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr_6, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_Helpers_checkSegments<CI>(var_segments_5417_mpos: U256, var_depositAmount: U256, var_timestamps_5422_mpos: U256, var_maxSegmentCount: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = array_length_array_struct_Segment_dyn(var_segments_5417_mpos, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0xc8936c1u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = gt(cleanup_uint256(expr, context)?, cleanup_uint256(var_maxSegmentCount, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x1b87f59bu128), context)?, context)?;
                let _2 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let _3 = add(var_timestamps_5422_mpos, U256::from(0x0u128), context)?;
            let _4 = read_from_memoryt_uint40(_3, context)?;
            let _2206_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5417_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _5 = read_from_memoryt_uint40(add(_2206_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_3 = iszero(lt(cleanup_uint40(_4, context)?, cleanup_uint40(_5, context)?, context)?, context)?;
            if expr_3 != U256::ZERO {
                let _6 = read_from_memoryt_uint40(_3, context)?;
                let _2213_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5417_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
                let _7 = read_from_memoryt_uint40(add(_2213_mpos, U256::from(0x40u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe4u128), U256::from(0xf500ccbu128), context)?, context)?;
                let _8 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _6, _7, context)?;
                revert(U256::from(0x0u128), sub(_8, U256::from(0x0u128), context)?, context)?;
            }
            let _9 = add(var_timestamps_5422_mpos, U256::from(0x20u128), context)?;
            let _10 = read_from_memoryt_uint40(_9, context)?;
            let expr_4 = U256::from(0x1u128);
            let expr_5 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let _2223_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5417_mpos, expr_5, context)?, context)?;
            let _11 = read_from_memoryt_uint40(add(_2223_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_6 = iszero(eq(cleanup_uint40(_10, context)?, cleanup_uint40(_11, context)?, context)?, context)?;
            if expr_6 != U256::ZERO {
                let _12 = read_from_memoryt_uint40(_9, context)?;
                let expr_7 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let _2231_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5417_mpos, expr_7, context)?, context)?;
                let _13 = read_from_memoryt_uint40(add(_2231_mpos, U256::from(0x40u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x474537ffu128), context)?, context)?;
                let _14 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _12, _13, context)?;
                revert(U256::from(0x0u128), sub(_14, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_segmentAmountsSum = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_segmentAmountsSum = zero_uint128;
            let mut var_currentSegmentTimestamp = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_currentSegmentTimestamp = zero_uint40;
            let mut var_previousSegmentTimestamp = U256::ZERO;
            var_previousSegmentTimestamp = zero_uint40;
            let mut var_index = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while expr_4 != U256::ZERO {
                // body
                {
                    let expr_8 = lt(cleanup_uint256(var_index, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_8, context)? != U256::ZERO {
                        break;
                    }
                    let _2245_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5417_mpos, var_index, context)?, context)?;
                    let _16 = read_from_memoryt_uint128(add(_2245_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_9 = checked_add_uint128(var_segmentAmountsSum, _16, context)?;
                    var_segmentAmountsSum = expr_9;
                    let _2251_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_5417_mpos, var_index, context)?, context)?;
                    let _17 = read_from_memoryt_uint40(add(_2251_mpos, U256::from(0x40u128), context)?, context)?;
                    var_currentSegmentTimestamp = _17;
                    let expr_10 = iszero(gt(cleanup_uint40(_17, context)?, cleanup_uint40(var_previousSegmentTimestamp, context)?, context)?, context)?;
                    if expr_10 != U256::ZERO {
                        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7d6d1f33u128), context)?, context)?;
                        let _18 = abi_encode_uint256_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_index, var_previousSegmentTimestamp, _17, context)?;
                        revert(U256::from(0x0u128), sub(_18, U256::from(0x0u128), context)?, context)?;
                    }
                    var_previousSegmentTimestamp = _17;
                }
                // post
                {
                    let _15 = increment_wrapping_uint256(var_index, context)?;
                    var_index = _15;
                }
            }
            let expr_11 = iszero(eq(cleanup_uint128(var_depositAmount, context)?, cleanup_uint128(var_segmentAmountsSum, context)?, context)?, context)?;
            if expr_11 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4b52f2ffu128), context)?, context)?;
                let _19 = abi_encode_uint128_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_depositAmount, var_segmentAmountsSum, context)?;
                revert(U256::from(0x0u128), sub(_19, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_Helpers_checkCreateLockupDynamic<CI>(var_sender: U256, var_timestamps_5016_mpos: U256, var_totalAmount: U256, var_segments_mpos: U256, var_maxCount: U256, var_brokerFee: U256, var_shape_5029_mpos: U256, var_maxBrokerFee: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_createAmounts_mpos = U256::ZERO;
            let zero_struct_CreateAmounts_memory_ptr_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_createAmounts_mpos = zero_struct_CreateAmounts_memory_ptr_mpos;
            let expr_5043_mpos = fun_Helpers_checkAndCalculateBrokerFee(var_totalAmount, var_brokerFee, var_maxBrokerFee, context)?;
            var_createAmounts_mpos = expr_5043_mpos;
            let _1 = add(expr_5043_mpos, U256::from(0x0u128), context)?;
            let _2 = read_from_memoryt_uint128(_1, context)?;
            let _3 = read_from_memoryt_uint40(add(var_timestamps_5016_mpos, U256::from(0x0u128), context)?, context)?;
            fun_Helpers_checkCreateStream(var_sender, _2, _3, var_shape_5029_mpos, context)?;
            let _4 = read_from_memoryt_uint128(_1, context)?;
            fun_Helpers_checkSegments(var_segments_mpos, _4, var_timestamps_5016_mpos, var_maxCount, context)?;
            Ok(var_createAmounts_mpos)
        }

        pub fn fun_mint<CI>(var_to: U256, var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_to, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x32505749u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = fun_update(var_to, var_tokenId, expr, context)?;
            let expr_3 = iszero(eq(cleanup_address(expr_2, context)?, cleanup_address(expr, context)?, context)?, context)?;
            if expr_3 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x39e35637u128), context)?, context)?;
                let _2 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_safeTransferFrom_1269<CI>(var_token_1246_address: U256, var_from: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = convert_uint32_to_bytes4(U256::from(0x23b872ddu128), context)?;
            let expr_1265_mpos = allocate_unbounded(context)?;
            let mut _2 = add(expr_1265_mpos, U256::from(0x20u128), context)?;
            mstore(_2, _1, context)?;
            _2 = add(_2, U256::from(0x4u128), context)?;
            let _3 = abi_encode_address_address_uint256(_2, var_from, var_to, var_value, context)?;
            mstore(expr_1265_mpos, sub(_3, add(expr_1265_mpos, U256::from(0x20u128), context)?, context)?, context)?;
            finalize_allocation(expr_1265_mpos, sub(_3, expr_1265_mpos, context)?, context)?;
            fun_callOptionalReturn(var_token_1246_address, expr_1265_mpos, context)?;
            Ok(())
        }

        pub fn update_storage_value_offsett_struct_Stream_to_struct_Stream<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            copy_struct_to_storage_from_struct_Stream_to_struct_Stream(slot, value, context)?;
            Ok(())
        }

        pub fn write_to_memory_address<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, cleanup_address(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_bool<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_contract_IERC20<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, cleanup_contract_IERC20(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_enum_Model<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, cleanup_enum_Model(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_string<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, value, context)?;
            Ok(())
        }

        pub fn write_to_memory_struct_Amounts<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, value, context)?;
            Ok(())
        }

        pub fn write_to_memory_struct_CreateAmounts<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, value, context)?;
            Ok(())
        }

        pub fn write_to_memory_struct_Timestamps<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, value, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_struct_CreateEventCommon<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_CreateEventCommon(context)?;
            Ok(ret)
        }

        pub fn fun_create<CI>(var_streamId: U256, var_params_mpos: U256, var_createAmounts_719_mpos: U256, var_lockupModel: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_726_mpos = U256::ZERO;
            let zero_struct_CreateEventCommon_mpos = zero_value_for_split_struct_CreateEventCommon(context)?;
            var_726_mpos = zero_struct_CreateEventCommon_mpos;
            let _1 = read_from_memoryt_address(add(var_params_mpos, U256::from(0x0u128), context)?, context)?;
            let _2 = add(var_params_mpos, U256::from(0xc0u128), context)?;
            let _1720_mpos = mload(_2, context)?;
            let _3 = read_from_memoryt_uint40(add(_1720_mpos, U256::from(0x0u128), context)?, context)?;
            let _1725_mpos = mload(_2, context)?;
            let _4 = read_from_memoryt_uint40(add(_1725_mpos, U256::from(0x20u128), context)?, context)?;
            let _5 = add(var_params_mpos, U256::from(0x80u128), context)?;
            let _6 = read_from_memoryt_bool(_5, context)?;
            let _7 = add(var_params_mpos, U256::from(0x60u128), context)?;
            let _address = read_from_memoryt_contract_IERC20(_7, context)?;
            let _8 = add(var_params_mpos, U256::from(0xa0u128), context)?;
            let _9 = read_from_memoryt_bool(_8, context)?;
            let _10 = add(var_createAmounts_719_mpos, U256::from(0x0u128), context)?;
            let _11 = read_from_memoryt_uint128(_10, context)?;
            let expr_757_mpos = allocate_memory_struct_struct_Amounts_storage_ptr(context)?;
            write_to_memory_uint128(add(expr_757_mpos, U256::from(0x0u128), context)?, _11, context)?;
            let _12 = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
            write_to_memory_uint128(add(expr_757_mpos, U256::from(0x20u128), context)?, _12, context)?;
            write_to_memory_uint128(add(expr_757_mpos, U256::from(0x40u128), context)?, _12, context)?;
            let expr_758_mpos = allocate_memory_struct_struct_Stream_storage_ptr(context)?;
            write_to_memory_address(add(expr_758_mpos, U256::from(0x0u128), context)?, _1, context)?;
            write_to_memory_uint40(add(expr_758_mpos, U256::from(0x20u128), context)?, _3, context)?;
            write_to_memory_uint40(add(expr_758_mpos, U256::from(0x40u128), context)?, _4, context)?;
            write_to_memory_bool(add(expr_758_mpos, U256::from(0x60u128), context)?, _6, context)?;
            write_to_memory_bool(add(expr_758_mpos, U256::from(0x80u128), context)?, U256::from(0x0u128), context)?;
            write_to_memory_contract_IERC20(add(expr_758_mpos, U256::from(0xa0u128), context)?, _address, context)?;
            write_to_memory_bool(add(expr_758_mpos, U256::from(0xc0u128), context)?, U256::from(0x0u128), context)?;
            write_to_memory_bool(add(expr_758_mpos, U256::from(0xe0u128), context)?, U256::from(0x1u128), context)?;
            write_to_memory_bool(add(expr_758_mpos, U256::from(0x100u128), context)?, _9, context)?;
            write_to_memory_enum_Model(add(expr_758_mpos, U256::from(0x120u128), context)?, var_lockupModel, context)?;
            write_to_memory_struct_Amounts(add(expr_758_mpos, U256::from(0x140u128), context)?, expr_757_mpos, context)?;
            let _13 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            update_storage_value_offsett_struct_Stream_to_struct_Stream(_13, expr_758_mpos, context)?;
            let _14 = add(var_params_mpos, U256::from(0x20u128), context)?;
            let _15 = read_from_memoryt_address(_14, context)?;
            fun_mint(_15, var_streamId, context)?;
            let expr = wrapping_add_uint256(var_streamId, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            update_storage_value_offsett_uint256_to_uint256(U256::from(0x7u128), expr, context)?;
            let _1754_address = read_from_memoryt_contract_IERC20(_7, context)?;
            let expr_1 = convert_contract_SablierLockup_to_address(address(context)?, context)?;
            let _16 = read_from_memoryt_uint128(_10, context)?;
            let _17 = convert_uint128_to_uint256(_16, context)?;
            fun_safeTransferFrom_1269(_1754_address, caller(context)?, expr_1, _17, context)?;
            let _18 = add(var_createAmounts_719_mpos, U256::from(0x20u128), context)?;
            let _19 = read_from_memoryt_uint128(_18, context)?;
            let expr_2 = gt(cleanup_uint128(_19, context)?, _12, context)?;
            if expr_2 != U256::ZERO {
                let _1764_address = read_from_memoryt_contract_IERC20(_7, context)?;
                let _1767_mpos = mload(add(var_params_mpos, U256::from(0x100u128), context)?, context)?;
                let _20 = read_from_memoryt_address(add(_1767_mpos, U256::from(0x0u128), context)?, context)?;
                let _21 = read_from_memoryt_uint128(_18, context)?;
                let _22 = convert_uint128_to_uint256(_21, context)?;
                fun_safeTransferFrom_1269(_1764_address, caller(context)?, _20, _22, context)?;
            }
            let _23 = read_from_memoryt_address(add(var_params_mpos, U256::from(0x0u128), context)?, context)?;
            let _24 = read_from_memoryt_address(_14, context)?;
            let _1783_address = read_from_memoryt_contract_IERC20(_7, context)?;
            let _25 = read_from_memoryt_bool(_5, context)?;
            let _26 = read_from_memoryt_bool(_8, context)?;
            let _1792_mpos = mload(_2, context)?;
            let _1795_mpos = mload(add(var_params_mpos, U256::from(0xe0u128), context)?, context)?;
            let _1798_mpos = mload(add(var_params_mpos, U256::from(0x100u128), context)?, context)?;
            let _27 = read_from_memoryt_address(add(_1798_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_831_mpos = allocate_memory_struct_struct_CreateEventCommon_storage_ptr(context)?;
            write_to_memory_address(add(expr_831_mpos, U256::from(0x0u128), context)?, caller(context)?, context)?;
            write_to_memory_address(add(expr_831_mpos, U256::from(0x20u128), context)?, _23, context)?;
            write_to_memory_address(add(expr_831_mpos, U256::from(0x40u128), context)?, _24, context)?;
            write_to_memory_struct_CreateAmounts(add(expr_831_mpos, U256::from(0x60u128), context)?, var_createAmounts_719_mpos, context)?;
            write_to_memory_contract_IERC20(add(expr_831_mpos, U256::from(0x80u128), context)?, _1783_address, context)?;
            write_to_memory_bool(add(expr_831_mpos, U256::from(0xa0u128), context)?, _25, context)?;
            write_to_memory_bool(add(expr_831_mpos, U256::from(0xc0u128), context)?, _26, context)?;
            write_to_memory_struct_Timestamps(add(expr_831_mpos, U256::from(0xe0u128), context)?, _1792_mpos, context)?;
            write_to_memory_string(add(expr_831_mpos, U256::from(0x100u128), context)?, _1795_mpos, context)?;
            write_to_memory_address(add(expr_831_mpos, U256::from(0x120u128), context)?, _27, context)?;
            var_726_mpos = expr_831_mpos;
            Ok(var_726_mpos)
        }

        pub fn read_from_memoryt_userDefinedValueType_UD60x18<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint256(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn fun_createLD<CI>(var_params_838_mpos: U256, var_segments_842_mpos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            let _1 = read_from_memoryt_address(add(var_params_838_mpos, U256::from(0x0u128), context)?, context)?;
            let _1161_mpos = mload(add(var_params_838_mpos, U256::from(0xc0u128), context)?, context)?;
            let _2 = read_from_memoryt_uint128(add(var_params_838_mpos, U256::from(0x40u128), context)?, context)?;
            let _3 = loadimmutable(from_hex("3433000000000000000000000000000000000000000000000000000000000000"), context)?;
            let _1169_mpos = mload(add(var_params_838_mpos, U256::from(0x100u128), context)?, context)?;
            let _4 = read_from_memoryt_userDefinedValueType_UD60x18(add(_1169_mpos, U256::from(0x20u128), context)?, context)?;
            let _1174_mpos = mload(add(var_params_838_mpos, U256::from(0xe0u128), context)?, context)?;
            let expr = constant_MAX_BROKER_FEE(context)?;
            let expr_867_mpos = fun_Helpers_checkCreateLockupDynamic(_1, _1161_mpos, _2, var_segments_842_mpos, _3, _4, _1174_mpos, expr, context)?;
            let _5 = read_from_storage_split_offset_uint256(U256::from(0x7u128), context)?;
            var_streamId = _5;
            let expr_1 = array_length_array_struct_Segment_dyn(var_segments_842_mpos, context)?;
            let mut var_i = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_2 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr_1, context)?, context)?;
                    if iszero(expr_2, context)? != U256::ZERO {
                        break;
                    }
                    let _1181_slot = U256::from(0xcu128);
                    let _7 = mapping_index_access_mapping_uint256_array_struct_Segment_storage_dyn_of_uint256(_1181_slot, _5, context)?;
                    let expr_891_self_slot = convert_array_array_struct_Segment_storage_dyn_storage_to_array_struct_Segment__dyn_ptr(_7, context)?;
                    let _1187_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_842_mpos, var_i, context)?, context)?;
                    array_push_from_struct_Segment_to_array_struct_Segment_storage_dyn_ptr(expr_891_self_slot, _1187_mpos, context)?;
                }
                // post
                {
                    let _6 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _6;
                }
            }
            let expr_911_mpos = fun_create(_5, var_params_838_mpos, expr_867_mpos, U256::from(0x1u128), context)?;
            let _8 = convert_uint256_to_uint256(_5, context)?;
            let _9 = allocate_unbounded(context)?;
            let _10 = abi_encode_struct_CreateEventCommon_array_struct_Segment_dyn(_9, expr_911_mpos, var_segments_842_mpos, context)?;
            log2(_9, sub(_10, _9, context)?, U256::from_be_slice(&[0x7c, 0xb8, 0x36, 0x40, 0xa3, 0x29, 0xcb, 0x23, 0x8b, 0x53, 0x1d, 0xaa, 0x26, 0xff, 0xca, 0x31, 0xb5, 0x9d, 0xd7, 0xc5, 0x10, 0x20, 0x18, 0x4c, 0xb4, 0x39, 0x4a, 0xc4, 0x3a, 0x11, 0x27, 0x8c]), _8, context)?;
            Ok(var_streamId)
        }

        pub fn read_from_calldatat_address<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_address(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_calldatat_bool<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_bool(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_calldatat_contract_IERC20<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_contract_IERC20(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_calldatat_uint128<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_uint128(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn write_to_memory_struct_Broker<CI>(memPtr: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(memPtr, value, context)?;
            Ok(())
        }

        pub fn fun_createWithDurationsLD_inner<CI>(_1: U256, var_params_offset: U256, var_segmentsWithDuration_offset: U256, var_segmentsWithDuration_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            var_streamId = _1;
            let expr = convert_uint256_to_uint40(timestamp(context)?, context)?;
            let _59_mpos = convert_array_array_struct_SegmentWithDuration_calldata_dyn_calldata_to_array_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_offset, var_segmentsWithDuration_length, context)?;
            let expr_298_mpos = fun_Helpers_calculateSegmentTimestamps(_59_mpos, expr, context)?;
            let expr_1 = array_length_array_struct_Segment_dyn(expr_298_mpos, context)?;
            let expr_2 = checked_sub_uint256(expr_1, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let _63_mpos = mload(memory_array_index_access_struct_Segment_dyn(expr_298_mpos, expr_2, context)?, context)?;
            let _2 = read_from_memoryt_uint40(add(_63_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_315_mpos = allocate_memory_struct_struct_Timestamps_storage_ptr(context)?;
            write_to_memory_uint40(add(expr_315_mpos, U256::from(0x0u128), context)?, expr, context)?;
            write_to_memory_uint40(add(expr_315_mpos, U256::from(0x20u128), context)?, _2, context)?;
            let expr_3 = read_from_calldatat_address(add(var_params_offset, U256::from(0x0u128), context)?, context)?;
            let expr_4 = read_from_calldatat_address(add(var_params_offset, U256::from(0x20u128), context)?, context)?;
            let expr_5 = read_from_calldatat_uint128(add(var_params_offset, U256::from(0x40u128), context)?, context)?;
            let expr_328_address = read_from_calldatat_contract_IERC20(add(var_params_offset, U256::from(0x60u128), context)?, context)?;
            let expr_6 = read_from_calldatat_bool(add(var_params_offset, U256::from(0x80u128), context)?, context)?;
            let expr_7 = read_from_calldatat_bool(add(var_params_offset, U256::from(0xa0u128), context)?, context)?;
            let (expr_335_offset, expr_335_length) = access_calldata_tail_string_calldata(var_params_offset, add(var_params_offset, U256::from(0xc0u128), context)?, context)?;
            let _3 = add(var_params_offset, U256::from(0xe0u128), context)?;
            let expr_338_mpos = allocate_memory_struct_struct_CreateWithTimestamps_storage_ptr(context)?;
            write_to_memory_address(add(expr_338_mpos, U256::from(0x0u128), context)?, expr_3, context)?;
            write_to_memory_address(add(expr_338_mpos, U256::from(0x20u128), context)?, expr_4, context)?;
            write_to_memory_uint128(add(expr_338_mpos, U256::from(0x40u128), context)?, expr_5, context)?;
            write_to_memory_contract_IERC20(add(expr_338_mpos, U256::from(0x60u128), context)?, expr_328_address, context)?;
            write_to_memory_bool(add(expr_338_mpos, U256::from(0x80u128), context)?, expr_6, context)?;
            write_to_memory_bool(add(expr_338_mpos, U256::from(0xa0u128), context)?, expr_7, context)?;
            write_to_memory_struct_Timestamps(add(expr_338_mpos, U256::from(0xc0u128), context)?, expr_315_mpos, context)?;
            let _83_mpos = convert_array_string_calldata_to_string(expr_335_offset, expr_335_length, context)?;
            write_to_memory_string(add(expr_338_mpos, U256::from(0xe0u128), context)?, _83_mpos, context)?;
            let _84_mpos = convert_struct_Broker_calldata_to_struct_Broker(_3, context)?;
            write_to_memory_struct_Broker(add(expr_338_mpos, U256::from(0x100u128), context)?, _84_mpos, context)?;
            let expr_8 = fun_createLD(expr_338_mpos, expr_298_mpos, context)?;
            var_streamId = expr_8;
            Ok(var_streamId)
        }

        pub fn modifier_noDelegateCall<CI>(var_streamId: U256, var_params_269_offset: U256, var_segmentsWithDuration_offset: U256, var_segmentsWithDuration_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_streamId;
            fun_preventDelegateCall(context)?;
            _1 = fun_createWithDurationsLD_inner(var_streamId, var_params_269_offset, var_segmentsWithDuration_offset, var_segmentsWithDuration_length, context)?;
            Ok(_1)
        }

        pub fn fun_createWithDurationsLD<CI>(var_params_offset: U256, var_segmentsWithDuration_offset: U256, var_segmentsWithDuration_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            var_streamId = modifier_noDelegateCall(zero_uint256, var_params_offset, var_segmentsWithDuration_offset, var_segmentsWithDuration_length, context)?;
            Ok(var_streamId)
        }

        pub fn external_fun_createWithDurationsLD<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2) = abi_decode_struct_CreateWithDurations_calldatat_array_struct_SegmentWithDuration_calldata_dyn_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_createWithDurationsLD(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_Helpers_checkTimestampsAndUnlockAmounts<CI>(var_depositAmount: U256, var_timestamps_5257_mpos: U256, var_cliffTime: U256, var_unlockAmounts_5262_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = gt(cleanup_uint40(var_cliffTime, context)?, convert_rational_by_to_uint40(U256::from(0x0u128), context)?, context)?;
            // switch
            let δ = expr;
            if δ == U256::from(0x0u128) {
                let _1 = add(var_unlockAmounts_5262_mpos, U256::from(0x20u128), context)?;
                let _2 = read_from_memoryt_uint128(_1, context)?;
                let expr_1 = gt(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
                if expr_1 != U256::ZERO {
                    let _3 = read_from_memoryt_uint128(_1, context)?;
                    mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x150ee1a5u128), context)?, context)?;
                    let _4 = abi_encode_tuple_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _3, context)?;
                    revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
                }
            }
            let _13 = add(var_timestamps_5257_mpos, U256::from(0x0u128), context)?;
            let _14 = read_from_memoryt_uint40(_13, context)?;
            let _15 = add(var_timestamps_5257_mpos, U256::from(0x20u128), context)?;
            let _16 = read_from_memoryt_uint40(_15, context)?;
            let expr_4 = iszero(lt(cleanup_uint40(_14, context)?, cleanup_uint40(_16, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                let _17 = read_from_memoryt_uint40(_13, context)?;
                let _18 = read_from_memoryt_uint40(_15, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5171143u128), context)?, context)?;
                let _19 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _17, _18, context)?;
                revert(U256::from(0x0u128), sub(_19, U256::from(0x0u128), context)?, context)?;
            }
            let _20 = add(var_unlockAmounts_5262_mpos, U256::from(0x0u128), context)?;
            let _21 = read_from_memoryt_uint128(_20, context)?;
            let _22 = add(var_unlockAmounts_5262_mpos, U256::from(0x20u128), context)?;
            let _23 = read_from_memoryt_uint128(_22, context)?;
            let expr_5 = checked_add_uint128(_21, _23, context)?;
            let expr_6 = gt(cleanup_uint128(expr_5, context)?, cleanup_uint128(var_depositAmount, context)?, context)?;
            if expr_6 != U256::ZERO {
                let _24 = read_from_memoryt_uint128(_20, context)?;
                let _25 = read_from_memoryt_uint128(_22, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xb4ba30du128), context)?, context)?;
                let _26 = abi_encode_uint128_uint128_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_depositAmount, _24, _25, context)?;
                revert(U256::from(0x0u128), sub(_26, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_Helpers_checkCreateLockupLinear<CI>(var_sender: U256, var_timestamps_5070_mpos: U256, var_cliffTime: U256, var_totalAmount: U256, var_unlockAmounts_mpos: U256, var_brokerFee: U256, var_shape_5082_mpos: U256, var_maxBrokerFee: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_createAmounts_5089_mpos = U256::ZERO;
            let zero_t_struct_CreateAmounts_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_createAmounts_5089_mpos = zero_t_struct_CreateAmounts_mpos;
            let expr_5096_mpos = fun_Helpers_checkAndCalculateBrokerFee(var_totalAmount, var_brokerFee, var_maxBrokerFee, context)?;
            var_createAmounts_5089_mpos = expr_5096_mpos;
            let _1 = add(expr_5096_mpos, U256::from(0x0u128), context)?;
            let _2 = read_from_memoryt_uint128(_1, context)?;
            let _3 = read_from_memoryt_uint40(add(var_timestamps_5070_mpos, U256::from(0x0u128), context)?, context)?;
            fun_Helpers_checkCreateStream(var_sender, _2, _3, var_shape_5082_mpos, context)?;
            let _4 = read_from_memoryt_uint128(_1, context)?;
            fun_Helpers_checkTimestampsAndUnlockAmounts(_4, var_timestamps_5070_mpos, var_cliffTime, var_unlockAmounts_mpos, context)?;
            Ok(var_createAmounts_5089_mpos)
        }

        pub fn update_byte_slice_5_shift_0<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = U256::from(0xffffffffffu128);
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offsett_uint40_to_uint40<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint40_to_uint40(value, context)?;
            sstore(slot, update_byte_slice_5_shift_0(sload(slot, context)?, prepare_store_uint40(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn fun_createLL<CI>(var_params_926_mpos: U256, var_unlockAmounts_929_mpos: U256, var_cliffTime: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            let _1 = read_from_memoryt_address(add(var_params_926_mpos, U256::from(0x0u128), context)?, context)?;
            let _mpos = mload(add(var_params_926_mpos, U256::from(0xc0u128), context)?, context)?;
            let _2 = read_from_memoryt_uint128(add(var_params_926_mpos, U256::from(0x40u128), context)?, context)?;
            let _1044_mpos = mload(add(var_params_926_mpos, U256::from(0x100u128), context)?, context)?;
            let _3 = read_from_memoryt_userDefinedValueType_UD60x18(add(_1044_mpos, U256::from(0x20u128), context)?, context)?;
            let _1049_mpos = mload(add(var_params_926_mpos, U256::from(0xe0u128), context)?, context)?;
            let expr = constant_MAX_BROKER_FEE(context)?;
            let expr_956_mpos = fun_Helpers_checkCreateLockupLinear(_1, _mpos, var_cliffTime, _2, var_unlockAmounts_929_mpos, _3, _1049_mpos, expr, context)?;
            let _4 = read_from_storage_split_offset_uint256(U256::from(0x7u128), context)?;
            var_streamId = _4;
            let _5 = read_from_memoryt_uint128(add(var_unlockAmounts_929_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_1 = gt(cleanup_uint128(_5, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                let _6 = read_from_memoryt_uint128(add(var_unlockAmounts_929_mpos, U256::from(0x0u128), context)?, context)?;
                let _7 = mapping_index_access_mapping_uint256_struct_UnlockAmounts_storage_of_uint256(U256::from(0xeu128), _4, context)?;
                update_storage_value_offsett_uint128_to_uint128(add(_7, U256::from(0x0u128), context)?, _6, context)?;
            }
            let expr_2 = gt(cleanup_uint40(var_cliffTime, context)?, convert_rational_by_to_uint40(U256::from(0x0u128), context)?, context)?;
            if expr_2 != U256::ZERO {
                let _8 = mapping_index_access_mapping_uint256_uint40_of_uint256(U256::from(0xbu128), _4, context)?;
                update_storage_value_offsett_uint40_to_uint40(_8, var_cliffTime, context)?;
                let _9 = add(var_unlockAmounts_929_mpos, U256::from(0x20u128), context)?;
                let _10 = read_from_memoryt_uint128(_9, context)?;
                let expr_3 = gt(cleanup_uint128(_10, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
                if expr_3 != U256::ZERO {
                    let _11 = read_from_memoryt_uint128(_9, context)?;
                    let _12 = mapping_index_access_mapping_uint256_struct_UnlockAmounts_storage_of_uint256(U256::from(0xeu128), _4, context)?;
                    update_storage_value_offsett_uint128_to_t_uint128(add(_12, U256::from(0x0u128), context)?, _11, context)?;
                }
            }
            let expr_1013_mpos = fun_create(_4, var_params_926_mpos, expr_956_mpos, U256::from(0x0u128), context)?;
            let _13 = convert_uint256_to_uint256(_4, context)?;
            let _14 = allocate_unbounded(context)?;
            let _15 = abi_encode_struct_CreateEventCommon_uint40_struct_UnlockAmounts(_14, expr_1013_mpos, var_cliffTime, var_unlockAmounts_929_mpos, context)?;
            log2(_14, sub(_15, _14, context)?, U256::from_be_slice(&[0xcf, 0x6d, 0xa1, 0xcd, 0xef, 0xbf, 0x0f, 0x08, 0x70, 0x37, 0x71, 0x28, 0xca, 0xb0, 0x20, 0xf3, 0xb9, 0x89, 0x5c, 0xe9, 0x61, 0x3b, 0x14, 0xb9, 0x33, 0xbb, 0xd1, 0x93, 0xd7, 0x64, 0xa9, 0x2e]), _13, context)?;
            Ok(var_streamId)
        }

        pub fn read_from_calldatat_uint40<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut returnValue = U256::ZERO;
            let value = calldataload(ptr, context)?;
            validator_revert_uint40(value, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn fun_createWithDurationsLL_inner<CI>(_1: U256, var_params_offset: U256, var_unlockAmounts_offset: U256, var_durations_offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            var_streamId = _1;
            let expr = convert_uint256_to_uint40(timestamp(context)?, context)?;
            let expr_375_mpos = allocate_memory_struct_struct_Timestamps_storage_ptr(context)?;
            write_to_memory_uint40(add(expr_375_mpos, U256::from(0x0u128), context)?, expr, context)?;
            let _2 = convert_rational_by_to_uint40(U256::from(0x0u128), context)?;
            write_to_memory_uint40(add(expr_375_mpos, U256::from(0x20u128), context)?, _2, context)?;
            let mut var_cliffTime = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_cliffTime = zero_uint40;
            let _3 = add(var_durations_offset, U256::from(0x0u128), context)?;
            let expr_1 = read_from_calldatat_uint40(_3, context)?;
            let expr_2 = gt(cleanup_uint40(expr_1, context)?, _2, context)?;
            if expr_2 != U256::ZERO {
                let _4 = read_from_memoryt_uint40(add(expr_375_mpos, U256::from(0x0u128), context)?, context)?;
                let expr_3 = read_from_calldatat_uint40(_3, context)?;
                let expr_4 = checked_add_uint40(_4, expr_3, context)?;
                var_cliffTime = expr_4;
            }
            let _5 = read_from_memoryt_uint40(add(expr_375_mpos, U256::from(0x0u128), context)?, context)?;
            let expr_5 = read_from_calldatat_uint40(add(var_durations_offset, U256::from(0x20u128), context)?, context)?;
            let expr_6 = checked_add_uint40(_5, expr_5, context)?;
            write_to_memory_uint40(add(expr_375_mpos, U256::from(0x20u128), context)?, expr_6, context)?;
            let expr_7 = read_from_calldatat_address(add(var_params_offset, U256::from(0x0u128), context)?, context)?;
            let expr_8 = read_from_calldatat_address(add(var_params_offset, U256::from(0x20u128), context)?, context)?;
            let expr_9 = read_from_calldatat_uint128(add(var_params_offset, U256::from(0x40u128), context)?, context)?;
            let expr_415_address = read_from_calldatat_contract_IERC20(add(var_params_offset, U256::from(0x60u128), context)?, context)?;
            let expr_10 = read_from_calldatat_bool(add(var_params_offset, U256::from(0x80u128), context)?, context)?;
            let expr_11 = read_from_calldatat_bool(add(var_params_offset, U256::from(0xa0u128), context)?, context)?;
            let (expr_422_offset, expr_length) = access_calldata_tail_string_calldata(var_params_offset, add(var_params_offset, U256::from(0xc0u128), context)?, context)?;
            let _6 = add(var_params_offset, U256::from(0xe0u128), context)?;
            let expr_425_mpos = allocate_memory_struct_struct_CreateWithTimestamps_storage_ptr(context)?;
            write_to_memory_address(add(expr_425_mpos, U256::from(0x0u128), context)?, expr_7, context)?;
            write_to_memory_address(add(expr_425_mpos, U256::from(0x20u128), context)?, expr_8, context)?;
            write_to_memory_uint128(add(expr_425_mpos, U256::from(0x40u128), context)?, expr_9, context)?;
            write_to_memory_contract_IERC20(add(expr_425_mpos, U256::from(0x60u128), context)?, expr_415_address, context)?;
            write_to_memory_bool(add(expr_425_mpos, U256::from(0x80u128), context)?, expr_10, context)?;
            write_to_memory_bool(add(expr_425_mpos, U256::from(0xa0u128), context)?, expr_11, context)?;
            write_to_memory_struct_Timestamps(add(expr_425_mpos, U256::from(0xc0u128), context)?, expr_375_mpos, context)?;
            let _39_mpos = convert_array_string_calldata_to_string(expr_422_offset, expr_length, context)?;
            write_to_memory_string(add(expr_425_mpos, U256::from(0xe0u128), context)?, _39_mpos, context)?;
            let _40_mpos = convert_struct_Broker_calldata_to_struct_Broker(_6, context)?;
            write_to_memory_struct_Broker(add(expr_425_mpos, U256::from(0x100u128), context)?, _40_mpos, context)?;
            let _43_mpos = convert_struct_UnlockAmounts_calldata_to_struct_UnlockAmounts(var_unlockAmounts_offset, context)?;
            let expr_12 = fun_createLL(expr_425_mpos, _43_mpos, var_cliffTime, context)?;
            var_streamId = expr_12;
            Ok(var_streamId)
        }

        pub fn modifier_noDelegateCall_358<CI>(var_streamId: U256, var_params_348_offset: U256, var_unlockAmounts_351_offset: U256, var_durations_354_offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_streamId;
            fun_preventDelegateCall(context)?;
            _1 = fun_createWithDurationsLL_inner(var_streamId, var_params_348_offset, var_unlockAmounts_351_offset, var_durations_354_offset, context)?;
            Ok(_1)
        }

        pub fn fun_createWithDurationsLL<CI>(var_params_offset: U256, var_unlockAmounts_offset: U256, var_durations_offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_t_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_t_uint256;
            var_streamId = modifier_noDelegateCall_358(zero_t_uint256, var_params_offset, var_unlockAmounts_offset, var_durations_offset, context)?;
            Ok(var_streamId)
        }

        pub fn external_fun_createWithDurationsLL<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2) = abi_decode_struct_CreateWithDurations_calldatat_struct_UnlockAmounts_calldatat_struct_Durations_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_createWithDurationsLL(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn memory_array_index_access_struct_TrancheWithDuration_dyn<CI>(baseRef: U256, index: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_TrancheWithDuration_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn zero_value_for_split_array_struct_Tranche_dyn<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_Helpers_calculateTrancheTimestamps<CI>(var_tranchesWithDuration_mpos: U256, var_startTime: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_tranchesWithTimestamps_mpos = U256::ZERO;
            let zero_array_struct_Tranche_dyn_mpos = zero_value_for_split_array_struct_Tranche_dyn(context)?;
            var_tranchesWithTimestamps_mpos = zero_array_struct_Tranche_dyn_mpos;
            let expr = array_length_array_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, context)?;
            let expr_4952_mpos = allocate_and_zero_memory_array_array_struct_Tranche_dyn(expr, context)?;
            var_tranchesWithTimestamps_mpos = expr_4952_mpos;
            let _1602_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _1 = read_from_memoryt_uint128(add(_1602_mpos, U256::from(0x0u128), context)?, context)?;
            let _1607_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _2 = read_from_memoryt_uint40(add(_1607_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1 = wrapping_add_uint40(var_startTime, _2, context)?;
            let expr_4970_mpos = allocate_memory_struct_struct_Tranche_storage_ptr(context)?;
            write_to_memory_uint128(add(expr_4970_mpos, U256::from(0x0u128), context)?, _1, context)?;
            write_to_memory_uint40(add(expr_4970_mpos, U256::from(0x20u128), context)?, expr_1, context)?;
            mstore(memory_array_index_access_struct_Tranche_dyn(expr_4952_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, expr_4970_mpos, context)?;
            pop(mload(memory_array_index_access_struct_Tranche_dyn(expr_4952_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?, context)?;
            let expr_2 = U256::from(0x1u128);
            let mut var_i = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
            // for loop
            while expr_2 != U256::ZERO {
                // body
                {
                    let expr_3 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_3, context)? != U256::ZERO {
                        break;
                    }
                    let _1618_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, var_i, context)?, context)?;
                    let _4 = read_from_memoryt_uint128(add(_1618_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_4 = wrapping_sub_uint256(var_i, convert_rational_1_by_1_to_uint256(expr_2, context)?, context)?;
                    let _1623_mpos = mload(memory_array_index_access_struct_Tranche_dyn(expr_4952_mpos, expr_4, context)?, context)?;
                    let _5 = read_from_memoryt_uint40(add(_1623_mpos, U256::from(0x20u128), context)?, context)?;
                    let _1628_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, var_i, context)?, context)?;
                    let _6 = read_from_memoryt_uint40(add(_1628_mpos, U256::from(0x20u128), context)?, context)?;
                    let expr_5 = wrapping_add_uint40(_5, _6, context)?;
                    let expr_5003_mpos = allocate_memory_struct_struct_Tranche_storage_ptr(context)?;
                    write_to_memory_uint128(add(expr_5003_mpos, U256::from(0x0u128), context)?, _4, context)?;
                    write_to_memory_uint40(add(expr_5003_mpos, U256::from(0x20u128), context)?, expr_5, context)?;
                    mstore(memory_array_index_access_struct_Tranche_dyn(expr_4952_mpos, var_i, context)?, expr_5003_mpos, context)?;
                    pop(mload(memory_array_index_access_struct_Tranche_dyn(expr_4952_mpos, var_i, context)?, context)?, context)?;
                }
                // post
                {
                    let _3 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _3;
                }
            }
            Ok(var_tranchesWithTimestamps_mpos)
        }

        pub fn fun_Helpers_checkTranches<CI>(var_tranches_5567_mpos: U256, var_depositAmount: U256, var_timestamps_mpos: U256, var_maxTrancheCount: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = array_length_array_struct_Tranche_dyn(var_tranches_5567_mpos, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xff743f91u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = gt(cleanup_uint256(expr, context)?, cleanup_uint256(var_maxTrancheCount, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0xc6a5a61u128), context)?, context)?;
                let _2 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let _3 = add(var_timestamps_mpos, U256::from(0x0u128), context)?;
            let _4 = read_from_memoryt_uint40(_3, context)?;
            let _2402_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5567_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _5 = read_from_memoryt_uint40(add(_2402_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_3 = iszero(lt(cleanup_uint40(_4, context)?, cleanup_uint40(_5, context)?, context)?, context)?;
            if expr_3 != U256::ZERO {
                let _6 = read_from_memoryt_uint40(_3, context)?;
                let _2409_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5567_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
                let _7 = read_from_memoryt_uint40(add(_2409_mpos, U256::from(0x20u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x2719805fu128), context)?, context)?;
                let _8 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _6, _7, context)?;
                revert(U256::from(0x0u128), sub(_8, U256::from(0x0u128), context)?, context)?;
            }
            let _9 = add(var_timestamps_mpos, U256::from(0x20u128), context)?;
            let _10 = read_from_memoryt_uint40(_9, context)?;
            let expr_4 = U256::from(0x1u128);
            let expr_5 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let _2419_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5567_mpos, expr_5, context)?, context)?;
            let _11 = read_from_memoryt_uint40(add(_2419_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_6 = iszero(eq(cleanup_uint40(_10, context)?, cleanup_uint40(_11, context)?, context)?, context)?;
            if expr_6 != U256::ZERO {
                let _12 = read_from_memoryt_uint40(_9, context)?;
                let expr_7 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let _2427_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5567_mpos, expr_7, context)?, context)?;
                let _13 = read_from_memoryt_uint40(add(_2427_mpos, U256::from(0x20u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x2828b1dfu128), context)?, context)?;
                let _14 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _12, _13, context)?;
                revert(U256::from(0x0u128), sub(_14, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_trancheAmountsSum = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_trancheAmountsSum = zero_uint128;
            let mut var_currentTrancheTimestamp = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_currentTrancheTimestamp = zero_uint40;
            let mut var_previousTrancheTimestamp = U256::ZERO;
            var_previousTrancheTimestamp = zero_uint40;
            let mut var_index = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while expr_4 != U256::ZERO {
                // body
                {
                    let expr_8 = lt(cleanup_uint256(var_index, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_8, context)? != U256::ZERO {
                        break;
                    }
                    let _2441_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5567_mpos, var_index, context)?, context)?;
                    let _16 = read_from_memoryt_uint128(add(_2441_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_9 = checked_add_uint128(var_trancheAmountsSum, _16, context)?;
                    var_trancheAmountsSum = expr_9;
                    let _2447_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5567_mpos, var_index, context)?, context)?;
                    let _17 = read_from_memoryt_uint40(add(_2447_mpos, U256::from(0x20u128), context)?, context)?;
                    var_currentTrancheTimestamp = _17;
                    let expr_10 = iszero(gt(cleanup_uint40(_17, context)?, cleanup_uint40(var_previousTrancheTimestamp, context)?, context)?, context)?;
                    if expr_10 != U256::ZERO {
                        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x73a9cd5fu128), context)?, context)?;
                        let _18 = abi_encode_uint256_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_index, var_previousTrancheTimestamp, _17, context)?;
                        revert(U256::from(0x0u128), sub(_18, U256::from(0x0u128), context)?, context)?;
                    }
                    var_previousTrancheTimestamp = _17;
                }
                // post
                {
                    let _15 = increment_wrapping_uint256(var_index, context)?;
                    var_index = _15;
                }
            }
            let expr_11 = iszero(eq(cleanup_uint128(var_depositAmount, context)?, cleanup_uint128(var_trancheAmountsSum, context)?, context)?, context)?;
            if expr_11 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x59b0e8ddu128), context)?, context)?;
                let _19 = abi_encode_uint128_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_depositAmount, var_trancheAmountsSum, context)?;
                revert(U256::from(0x0u128), sub(_19, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_Helpers_checkCreateLockupTranched<CI>(var_sender: U256, var_timestamps_5123_mpos: U256, var_totalAmount: U256, var_tranches_5129_mpos: U256, var_maxCount: U256, var_brokerFee: U256, var_shape_mpos: U256, var_maxBrokerFee: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_createAmounts_5143_mpos = U256::ZERO;
            let zero_struct_CreateAmounts_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_createAmounts_5143_mpos = zero_struct_CreateAmounts_mpos;
            let expr_mpos = fun_Helpers_checkAndCalculateBrokerFee(var_totalAmount, var_brokerFee, var_maxBrokerFee, context)?;
            var_createAmounts_5143_mpos = expr_mpos;
            let _1 = add(expr_mpos, U256::from(0x0u128), context)?;
            let _2 = read_from_memoryt_uint128(_1, context)?;
            let _3 = read_from_memoryt_uint40(add(var_timestamps_5123_mpos, U256::from(0x0u128), context)?, context)?;
            fun_Helpers_checkCreateStream(var_sender, _2, _3, var_shape_mpos, context)?;
            let _4 = read_from_memoryt_uint128(_1, context)?;
            fun_Helpers_checkTranches(var_tranches_5129_mpos, _4, var_timestamps_5123_mpos, var_maxCount, context)?;
            Ok(var_createAmounts_5143_mpos)
        }

        pub fn fun_createLT<CI>(var_params_1029_mpos: U256, var_tranches_1033_mpos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            let _1 = read_from_memoryt_address(add(var_params_1029_mpos, U256::from(0x0u128), context)?, context)?;
            let _1498_mpos = mload(add(var_params_1029_mpos, U256::from(0xc0u128), context)?, context)?;
            let _2 = read_from_memoryt_uint128(add(var_params_1029_mpos, U256::from(0x40u128), context)?, context)?;
            let _3 = loadimmutable(from_hex("3433000000000000000000000000000000000000000000000000000000000000"), context)?;
            let _1506_mpos = mload(add(var_params_1029_mpos, U256::from(0x100u128), context)?, context)?;
            let _4 = read_from_memoryt_userDefinedValueType_UD60x18(add(_1506_mpos, U256::from(0x20u128), context)?, context)?;
            let _1511_mpos = mload(add(var_params_1029_mpos, U256::from(0xe0u128), context)?, context)?;
            let expr = constant_MAX_BROKER_FEE(context)?;
            let expr_1058_mpos = fun_Helpers_checkCreateLockupTranched(_1, _1498_mpos, _2, var_tranches_1033_mpos, _3, _4, _1511_mpos, expr, context)?;
            let _5 = read_from_storage_split_offset_uint256(U256::from(0x7u128), context)?;
            var_streamId = _5;
            let expr_1 = array_length_array_struct_Tranche_dyn(var_tranches_1033_mpos, context)?;
            let mut var_i = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_2 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr_1, context)?, context)?;
                    if iszero(expr_2, context)? != U256::ZERO {
                        break;
                    }
                    let _1518_slot = U256::from(0xdu128);
                    let _7 = mapping_index_access_mapping_uint256_array_struct_Tranche_storage_dyn_of_uint256(_1518_slot, _5, context)?;
                    let expr_self_slot = convert_array_array_struct_Tranche_storage_dyn_storage_to_array_struct_Tranche__dyn_ptr(_7, context)?;
                    let _1524_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_1033_mpos, var_i, context)?, context)?;
                    array_push_from_struct_Tranche_to_array_struct_Tranche_storage_dyn_ptr(expr_self_slot, _1524_mpos, context)?;
                }
                // post
                {
                    let _6 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _6;
                }
            }
            let expr_1102_mpos = fun_create(_5, var_params_1029_mpos, expr_1058_mpos, U256::from(0x2u128), context)?;
            let _8 = convert_uint256_to_uint256(_5, context)?;
            let _9 = allocate_unbounded(context)?;
            let _10 = abi_encode_struct_CreateEventCommon_array_struct_Tranche_dyn(_9, expr_1102_mpos, var_tranches_1033_mpos, context)?;
            log2(_9, sub(_10, _9, context)?, U256::from_be_slice(&[0x1c, 0xb1, 0x5a, 0x39, 0xf1, 0x2b, 0x6a, 0x34, 0x9f, 0x8d, 0x1d, 0x45, 0x49, 0x9b, 0x7b, 0x9d, 0xf6, 0x34, 0x64, 0xa7, 0x9f, 0xa2, 0xe2, 0x94, 0xa7, 0x23, 0x71, 0x07, 0xe6, 0x2c, 0x38, 0x4f]), _8, context)?;
            Ok(var_streamId)
        }

        pub fn fun_createWithDurationsLT_inner<CI>(_1: U256, var_params_offset: U256, var_tranchesWithDuration_offset: U256, var_tranchesWithDuration_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            var_streamId = _1;
            let expr = convert_uint256_to_uint40(timestamp(context)?, context)?;
            let _845_mpos = convert_array_array_struct_TrancheWithDuration_calldata_dyn_calldata_to_array_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_offset, var_tranchesWithDuration_length, context)?;
            let expr_465_mpos = fun_Helpers_calculateTrancheTimestamps(_845_mpos, expr, context)?;
            let expr_1 = array_length_array_struct_Tranche_dyn(expr_465_mpos, context)?;
            let expr_2 = checked_sub_uint256(expr_1, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let _849_mpos = mload(memory_array_index_access_struct_Tranche_dyn(expr_465_mpos, expr_2, context)?, context)?;
            let _2 = read_from_memoryt_uint40(add(_849_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_482_mpos = allocate_memory_struct_struct_Timestamps_storage_ptr(context)?;
            write_to_memory_uint40(add(expr_482_mpos, U256::from(0x0u128), context)?, expr, context)?;
            write_to_memory_uint40(add(expr_482_mpos, U256::from(0x20u128), context)?, _2, context)?;
            let expr_3 = read_from_calldatat_address(add(var_params_offset, U256::from(0x0u128), context)?, context)?;
            let expr_4 = read_from_calldatat_address(add(var_params_offset, U256::from(0x20u128), context)?, context)?;
            let expr_5 = read_from_calldatat_uint128(add(var_params_offset, U256::from(0x40u128), context)?, context)?;
            let expr_address = read_from_calldatat_contract_IERC20(add(var_params_offset, U256::from(0x60u128), context)?, context)?;
            let expr_6 = read_from_calldatat_bool(add(var_params_offset, U256::from(0x80u128), context)?, context)?;
            let expr_7 = read_from_calldatat_bool(add(var_params_offset, U256::from(0xa0u128), context)?, context)?;
            let (expr_502_offset, expr_502_length) = access_calldata_tail_string_calldata(var_params_offset, add(var_params_offset, U256::from(0xc0u128), context)?, context)?;
            let _3 = add(var_params_offset, U256::from(0xe0u128), context)?;
            let expr_505_mpos = allocate_memory_struct_struct_CreateWithTimestamps_storage_ptr(context)?;
            write_to_memory_address(add(expr_505_mpos, U256::from(0x0u128), context)?, expr_3, context)?;
            write_to_memory_address(add(expr_505_mpos, U256::from(0x20u128), context)?, expr_4, context)?;
            write_to_memory_uint128(add(expr_505_mpos, U256::from(0x40u128), context)?, expr_5, context)?;
            write_to_memory_contract_IERC20(add(expr_505_mpos, U256::from(0x60u128), context)?, expr_address, context)?;
            write_to_memory_bool(add(expr_505_mpos, U256::from(0x80u128), context)?, expr_6, context)?;
            write_to_memory_bool(add(expr_505_mpos, U256::from(0xa0u128), context)?, expr_7, context)?;
            write_to_memory_struct_Timestamps(add(expr_505_mpos, U256::from(0xc0u128), context)?, expr_482_mpos, context)?;
            let _869_mpos = convert_array_string_calldata_to_string(expr_502_offset, expr_502_length, context)?;
            write_to_memory_string(add(expr_505_mpos, U256::from(0xe0u128), context)?, _869_mpos, context)?;
            let _870_mpos = convert_struct_Broker_calldata_to_struct_Broker(_3, context)?;
            write_to_memory_struct_Broker(add(expr_505_mpos, U256::from(0x100u128), context)?, _870_mpos, context)?;
            let expr_8 = fun_createLT(expr_505_mpos, expr_465_mpos, context)?;
            var_streamId = expr_8;
            Ok(var_streamId)
        }

        pub fn modifier_noDelegateCall_444<CI>(var_streamId: U256, var_params_436_offset: U256, var_tranchesWithDuration_offset: U256, var_tranchesWithDuration_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_streamId;
            fun_preventDelegateCall(context)?;
            _1 = fun_createWithDurationsLT_inner(var_streamId, var_params_436_offset, var_tranchesWithDuration_offset, var_tranchesWithDuration_length, context)?;
            Ok(_1)
        }

        pub fn fun_createWithDurationsLT<CI>(var_params_offset: U256, var_tranchesWithDuration_offset: U256, var_tranchesWithDuration_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            var_streamId = modifier_noDelegateCall_444(zero_uint256, var_params_offset, var_tranchesWithDuration_offset, var_tranchesWithDuration_length, context)?;
            Ok(var_streamId)
        }

        pub fn external_fun_createWithDurationsLT<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2) = abi_decode_struct_CreateWithDurations_calldatat_array_struct_TrancheWithDuration_calldata_dyn_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_createWithDurationsLT(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_createWithTimestampsLD_inner<CI>(_1: U256, var_params_offset: U256, var_segments_offset: U256, var_segments_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            var_streamId = _1;
            let _160_mpos = convert_struct_CreateWithTimestamps_calldata_to_struct_CreateWithTimestamps(var_params_offset, context)?;
            let _161_mpos = convert_array_array_struct_Segment_calldata_dyn_calldata_to_array_struct_Segment_dyn(var_segments_offset, var_segments_length, context)?;
            let expr = fun_createLD(_160_mpos, _161_mpos, context)?;
            var_streamId = expr;
            Ok(var_streamId)
        }

        pub fn modifier_noDelegateCall_523<CI>(var_streamId: U256, var_params_515_offset: U256, var_segments_offset: U256, var_segments_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_streamId;
            fun_preventDelegateCall(context)?;
            _1 = fun_createWithTimestampsLD_inner(var_streamId, var_params_515_offset, var_segments_offset, var_segments_length, context)?;
            Ok(_1)
        }

        pub fn fun_createWithTimestampsLD<CI>(var_params_offset: U256, var_segments_offset: U256, var_segments_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            var_streamId = modifier_noDelegateCall_523(zero_uint256, var_params_offset, var_segments_offset, var_segments_length, context)?;
            Ok(var_streamId)
        }

        pub fn external_fun_createWithTimestampsLD<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2) = abi_decode_struct_CreateWithTimestamps_calldatat_array_struct_Segment_calldata_dyn_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_createWithTimestampsLD(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_createWithTimestampsLL_inner<CI>(_1: U256, var_params_offset: U256, var_unlockAmounts_offset: U256, var_cliffTime: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            var_streamId = _1;
            let _422_mpos = convert_struct_CreateWithTimestamps_calldata_to_struct_CreateWithTimestamps(var_params_offset, context)?;
            let _423_mpos = convert_struct_UnlockAmounts_calldata_to_struct_UnlockAmounts(var_unlockAmounts_offset, context)?;
            let expr = fun_createLL(_422_mpos, _423_mpos, var_cliffTime, context)?;
            var_streamId = expr;
            Ok(var_streamId)
        }

        pub fn modifier_noDelegateCall_548<CI>(var_streamId: U256, var_params_539_offset: U256, var_unlockAmounts_offset: U256, var_cliffTime: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_streamId;
            fun_preventDelegateCall(context)?;
            _1 = fun_createWithTimestampsLL_inner(var_streamId, var_params_539_offset, var_unlockAmounts_offset, var_cliffTime, context)?;
            Ok(_1)
        }

        pub fn fun_createWithTimestampsLL<CI>(var_params_offset: U256, var_unlockAmounts_offset: U256, var_cliffTime: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            var_streamId = modifier_noDelegateCall_548(zero_uint256, var_params_offset, var_unlockAmounts_offset, var_cliffTime, context)?;
            Ok(var_streamId)
        }

        pub fn external_fun_createWithTimestampsLL<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2) = abi_decode_struct_CreateWithTimestamps_calldatat_struct_UnlockAmounts_calldatat_uint40(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_createWithTimestampsLL(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_createWithTimestampsLT_inner<CI>(_1: U256, var_params_offset: U256, var_tranches_offset: U256, var_tranches_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            var_streamId = _1;
            let _479_mpos = convert_struct_CreateWithTimestamps_calldata_to_struct_CreateWithTimestamps(var_params_offset, context)?;
            let _480_mpos = convert_array_array_struct_Tranche_calldata_dyn_calldata_to_array_struct_Tranche_dyn(var_tranches_offset, var_tranches_length, context)?;
            let expr = fun_createLT(_479_mpos, _480_mpos, context)?;
            var_streamId = expr;
            Ok(var_streamId)
        }

        pub fn modifier_noDelegateCall_573<CI>(var_streamId: U256, var_params_565_offset: U256, var_tranches_569_offset: U256, var_tranches_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_streamId;
            fun_preventDelegateCall(context)?;
            _1 = fun_createWithTimestampsLT_inner(var_streamId, var_params_565_offset, var_tranches_569_offset, var_tranches_length, context)?;
            Ok(_1)
        }

        pub fn fun_createWithTimestampsLT<CI>(var_params_offset: U256, var_tranches_offset: U256, var_tranches_length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamId = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_streamId = zero_uint256;
            var_streamId = modifier_noDelegateCall_573(zero_uint256, var_params_offset, var_tranches_offset, var_tranches_length, context)?;
            Ok(var_streamId)
        }

        pub fn external_fun_createWithTimestampsLT<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2) = abi_decode_struct_CreateWithTimestamps_calldatat_array_struct_Tranche_calldata_dyn_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_createWithTimestampsLT(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_getApproved<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getApproved(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_address(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getCliffTime_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_cliffTime = U256::ZERO;
            var_cliffTime = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_enum_Model(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = iszero(eq(cleanup_enum_Model(_3, context)?, cleanup_enum_Model(U256::from(0x0u128), context)?, context)?, context)?;
            if expr != U256::ZERO {
                let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
                let _5 = read_from_storage_split_offset_enum_Model(add(_4, U256::from(0x1u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7382cd8bu128), context)?, context)?;
                let _6 = abi_encode_enum_Model_enum_Model(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _5, U256::from(0x0u128), context)?;
                revert(U256::from(0x0u128), sub(_6, U256::from(0x0u128), context)?, context)?;
            }
            let _7 = mapping_index_access_mapping_uint256_uint40_of_uint256(U256::from(0xbu128), var_streamId, context)?;
            let _8 = read_from_storage_split_offset_0_uint40(_7, context)?;
            var_cliffTime = _8;
            Ok(var_cliffTime)
        }

        pub fn modifier_notNull_104<CI>(var_cliffTime: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_cliffTime;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getCliffTime_inner(var_cliffTime, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getCliffTime<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_cliffTime = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_cliffTime = zero_uint40;
            var_cliffTime = modifier_notNull_104(zero_uint40, var_streamId, context)?;
            Ok(var_cliffTime)
        }

        pub fn external_fun_getCliffTime<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getCliffTime(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint40(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getDepositedAmount_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_depositedAmount = U256::ZERO;
            var_depositedAmount = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = add(_2, U256::from(0x2u128), context)?;
            let _4 = read_from_storage_split_offset_t_uint128(add(_3, U256::from(0x0u128), context)?, context)?;
            var_depositedAmount = _4;
            Ok(var_depositedAmount)
        }

        pub fn modifier_notNull_2610<CI>(var_depositedAmount: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_depositedAmount;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getDepositedAmount_inner(var_depositedAmount, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getDepositedAmount<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_depositedAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_depositedAmount = zero_uint128;
            var_depositedAmount = modifier_notNull_2610(zero_uint128, var_streamId, context)?;
            Ok(var_depositedAmount)
        }

        pub fn external_fun_getDepositedAmount<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getDepositedAmount(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getEndTime_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_endTime = U256::ZERO;
            var_endTime = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_25_uint40(add(_2, U256::from(0x0u128), context)?, context)?;
            var_endTime = _3;
            Ok(var_endTime)
        }

        pub fn modifier_notNull<CI>(var_endTime: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_endTime;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getEndTime_inner(var_endTime, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getEndTime<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_endTime = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_endTime = zero_uint40;
            var_endTime = modifier_notNull(zero_uint40, var_streamId, context)?;
            Ok(var_endTime)
        }

        pub fn external_fun_getEndTime<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getEndTime(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint40(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getLockupModel_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_lockupModel = U256::ZERO;
            var_lockupModel = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_enum_Model(add(_2, U256::from(0x1u128), context)?, context)?;
            var_lockupModel = _3;
            Ok(var_lockupModel)
        }

        pub fn modifier_notNull_2651<CI>(var_lockupModel: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_lockupModel;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getLockupModel_inner(var_lockupModel, var_streamId, context)?;
            Ok(_1)
        }

        pub fn zero_value_for_split_enum_Model<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_getLockupModel<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_lockupModel = U256::ZERO;
            let zero_enum_Model = zero_value_for_split_enum_Model(context)?;
            var_lockupModel = zero_enum_Model;
            var_lockupModel = modifier_notNull_2651(zero_enum_Model, var_streamId, context)?;
            Ok(var_lockupModel)
        }

        pub fn external_fun_getLockupModel<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getLockupModel(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_enum_Model(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getRecipient<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_recipient = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var_recipient = zero_address;
            let expr = fun_requireOwned(var_streamId, context)?;
            var_recipient = expr;
            Ok(var_recipient)
        }

        pub fn external_fun_getRecipient<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getRecipient(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_address(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getRefundedAmount_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_refundedAmount = U256::ZERO;
            var_refundedAmount = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = add(_2, U256::from(0x2u128), context)?;
            let _4 = read_from_storage_split_offset_t_uint128(add(_3, U256::from(0x1u128), context)?, context)?;
            var_refundedAmount = _4;
            Ok(var_refundedAmount)
        }

        pub fn modifier_notNull_2688<CI>(var_refundedAmount: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_refundedAmount;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getRefundedAmount_inner(var_refundedAmount, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getRefundedAmount<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_refundedAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_refundedAmount = zero_uint128;
            var_refundedAmount = modifier_notNull_2688(zero_uint128, var_streamId, context)?;
            Ok(var_refundedAmount)
        }

        pub fn external_fun_getRefundedAmount<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getRefundedAmount(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getSegments_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_segments_mpos = U256::ZERO;
            var_segments_mpos = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_enum_Model(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = iszero(eq(cleanup_enum_Model(_3, context)?, cleanup_enum_Model(U256::from(0x1u128), context)?, context)?, context)?;
            if expr != U256::ZERO {
                let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
                let _5 = read_from_storage_split_offset_enum_Model(add(_4, U256::from(0x1u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7382cd8bu128), context)?, context)?;
                let _6 = abi_encode_enum_Model_enum_Model(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _5, U256::from(0x1u128), context)?;
                revert(U256::from(0x0u128), sub(_6, U256::from(0x0u128), context)?, context)?;
            }
            let _7 = mapping_index_access_mapping_uint256_array_struct_Segment_storage_dyn_of_uint256(U256::from(0xcu128), var_streamId, context)?;
            var_segments_mpos = convert_array_array_struct_Segment_storage_dyn_to_array_struct_Segment_dyn(_7, context)?;
            Ok(var_segments_mpos)
        }

        pub fn modifier_notNull_145<CI>(var_segments_149_mpos: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_segments_149_mpos;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getSegments_inner(var_segments_149_mpos, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getSegments<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_segments_mpos = U256::ZERO;
            let zero_array_struct_Segment_memory_ptr_dyn_memory_ptr_mpos = zero_value_for_split_array_struct_Segment_dyn(context)?;
            var_segments_mpos = zero_array_struct_Segment_memory_ptr_dyn_memory_ptr_mpos;
            var_segments_mpos = modifier_notNull_145(zero_array_struct_Segment_memory_ptr_dyn_memory_ptr_mpos, var_streamId, context)?;
            Ok(var_segments_mpos)
        }

        pub fn external_fun_getSegments<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getSegments(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_array_struct_Segment_dyn(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getSender_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_sender = U256::ZERO;
            var_sender = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_address(add(_2, U256::from(0x0u128), context)?, context)?;
            var_sender = _3;
            Ok(var_sender)
        }

        pub fn modifier_notNull_2709<CI>(var_sender: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_sender;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getSender_inner(var_sender, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getSender<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_sender = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var_sender = zero_address;
            var_sender = modifier_notNull_2709(zero_address, var_streamId, context)?;
            Ok(var_sender)
        }

        pub fn external_fun_getSender<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getSender(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_address(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getStartTime_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_startTime = U256::ZERO;
            var_startTime = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_uint40(add(_2, U256::from(0x0u128), context)?, context)?;
            var_startTime = _3;
            Ok(var_startTime)
        }

        pub fn modifier_notNull_2729<CI>(var_startTime: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_startTime;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getStartTime_inner(var_startTime, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getStartTime<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_startTime = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_startTime = zero_uint40;
            var_startTime = modifier_notNull_2729(zero_uint40, var_streamId, context)?;
            Ok(var_startTime)
        }

        pub fn external_fun_getStartTime<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getStartTime(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint40(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getTranches_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_tranches_mpos = U256::ZERO;
            var_tranches_mpos = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_enum_Model(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = iszero(eq(cleanup_enum_Model(_3, context)?, cleanup_enum_Model(U256::from(0x2u128), context)?, context)?, context)?;
            if expr != U256::ZERO {
                let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
                let _5 = read_from_storage_split_offset_enum_Model(add(_4, U256::from(0x1u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7382cd8bu128), context)?, context)?;
                let _6 = abi_encode_enum_Model_enum_Model(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _5, U256::from(0x2u128), context)?;
                revert(U256::from(0x0u128), sub(_6, U256::from(0x0u128), context)?, context)?;
            }
            let _7 = mapping_index_access_mapping_uint256_array_struct_Tranche_storage_dyn_of_uint256(U256::from(0xdu128), var_streamId, context)?;
            var_tranches_mpos = convert_array_array_struct_Tranche_storage_dyn_to_array_struct_Tranche_dyn(_7, context)?;
            Ok(var_tranches_mpos)
        }

        pub fn modifier_notNull_188<CI>(var_tranches_192_mpos: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_tranches_192_mpos;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getTranches_inner(var_tranches_192_mpos, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getTranches<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_tranches_mpos = U256::ZERO;
            let zero_array_struct_Tranche_memory_ptr_dyn_memory_ptr_mpos = zero_value_for_split_array_struct_Tranche_dyn(context)?;
            var_tranches_mpos = zero_array_struct_Tranche_memory_ptr_dyn_memory_ptr_mpos;
            var_tranches_mpos = modifier_notNull_188(zero_array_struct_Tranche_memory_ptr_dyn_memory_ptr_mpos, var_streamId, context)?;
            Ok(var_tranches_mpos)
        }

        pub fn external_fun_getTranches<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getTranches(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_array_struct_Tranche_memory_ptr_dyn_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getUnderlyingToken_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_token_address = U256::ZERO;
            var_token_address = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _582_address = read_from_storage_split_offset_contract_IERC20(add(_2, U256::from(0x1u128), context)?, context)?;
            var_token_address = _582_address;
            Ok(var_token_address)
        }

        pub fn modifier_notNull_2749<CI>(var_token_2752_address: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_token_2752_address;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getUnderlyingToken_inner(var_token_2752_address, var_streamId, context)?;
            Ok(_1)
        }

        pub fn zero_value_for_split_contract_IERC20<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_getUnderlyingToken<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_token_address = U256::ZERO;
            let zero_contract_IERC20_address = zero_value_for_split_contract_IERC20(context)?;
            var_token_address = zero_contract_IERC20_address;
            var_token_address = modifier_notNull_2749(zero_contract_IERC20_address, var_streamId, context)?;
            Ok(var_token_address)
        }

        pub fn external_fun_getUnderlyingToken<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getUnderlyingToken(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_contract_IERC20(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getUnlockAmounts_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_unlockAmounts_mpos = U256::ZERO;
            var_unlockAmounts_mpos = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_enum_Model(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = iszero(eq(cleanup_enum_Model(_3, context)?, cleanup_enum_Model(U256::from(0x0u128), context)?, context)?, context)?;
            if expr != U256::ZERO {
                let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
                let _5 = read_from_storage_split_offset_enum_Model(add(_4, U256::from(0x1u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7382cd8bu128), context)?, context)?;
                let _6 = abi_encode_enum_Model_enum_Model(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _5, U256::from(0x0u128), context)?;
                revert(U256::from(0x0u128), sub(_6, U256::from(0x0u128), context)?, context)?;
            }
            let _7 = mapping_index_access_mapping_uint256_struct_UnlockAmounts_storage_of_uint256(U256::from(0xeu128), var_streamId, context)?;
            var_unlockAmounts_mpos = convert_struct_UnlockAmounts_storage_to_struct_UnlockAmounts(_7, context)?;
            Ok(var_unlockAmounts_mpos)
        }

        pub fn modifier_notNull_231<CI>(var_unlockAmounts_234_mpos: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_unlockAmounts_234_mpos;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getUnlockAmounts_inner(var_unlockAmounts_234_mpos, var_streamId, context)?;
            Ok(_1)
        }

        pub fn zero_value_for_split_struct_UnlockAmounts<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_UnlockAmounts(context)?;
            Ok(ret)
        }

        pub fn fun_getUnlockAmounts<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_unlockAmounts_mpos = U256::ZERO;
            let zero_struct_UnlockAmounts_mpos = zero_value_for_split_struct_UnlockAmounts(context)?;
            var_unlockAmounts_mpos = zero_struct_UnlockAmounts_mpos;
            var_unlockAmounts_mpos = modifier_notNull_231(zero_struct_UnlockAmounts_mpos, var_streamId, context)?;
            Ok(var_unlockAmounts_mpos)
        }

        pub fn external_fun_getUnlockAmounts<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getUnlockAmounts(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_struct_UnlockAmounts_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_getWithdrawnAmount_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_withdrawnAmount = U256::ZERO;
            var_withdrawnAmount = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = add(_2, U256::from(0x2u128), context)?;
            let _4 = read_from_storage_split_offset_uint128(add(_3, U256::from(0x0u128), context)?, context)?;
            var_withdrawnAmount = _4;
            Ok(var_withdrawnAmount)
        }

        pub fn modifier_notNull_2770<CI>(var_withdrawnAmount: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_withdrawnAmount;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_getWithdrawnAmount_inner(var_withdrawnAmount, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_getWithdrawnAmount<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_withdrawnAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_withdrawnAmount = zero_uint128;
            var_withdrawnAmount = modifier_notNull_2770(zero_uint128, var_streamId, context)?;
            Ok(var_withdrawnAmount)
        }

        pub fn external_fun_getWithdrawnAmount<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_getWithdrawnAmount(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_isAllowedToHook<CI>(var_recipient: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            let _1 = mapping_index_access_mapping_address_bool_of_address(U256::from(0x9u128), var_recipient, context)?;
            let _2 = read_from_storage_split_offset_0_bool(_1, context)?;
            var_result = _2;
            Ok(var_result)
        }

        pub fn external_fun_isAllowedToHook<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isAllowedToHook(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_isApprovedForAll<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isApprovedForAll(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_enum_Status<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun__statusOf<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_enum_Status = zero_value_for_split_enum_Status(context)?;
            var = zero_t_enum_Status;
            let _slot = U256::from(0xau128);
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_slot, var_streamId, context)?;
            let _2 = read_from_storage_split_offset_t_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            // switch
            let δ = _2;
            if δ == U256::from(0x0u128) {
                let _3 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_slot, var_streamId, context)?;
                let _4 = read_from_storage_split_offset_31_bool(add(_3, U256::from(0x0u128), context)?, context)?;
                if _4 != U256::ZERO {
                    var = U256::from(0x3u128);
                    return Ok(var);
                }
            }
            let _5 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_slot, var_streamId, context)?;
            let _6 = read_from_storage_split_offset_uint40(add(_5, U256::from(0x0u128), context)?, context)?;
            let expr = lt(cleanup_uint256(timestamp(context)?, context)?, convert_uint40_to_uint256(_6, context)?, context)?;
            if expr != U256::ZERO {
                var = U256::from(0x0u128);
                return Ok(var);
            }
            let expr_1 = fun_calculateStreamedAmount(var_streamId, context)?;
            let _7 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_slot, var_streamId, context)?;
            let _8 = add(_7, U256::from(0x2u128), context)?;
            let _9 = read_from_storage_split_offset_t_uint128(add(_8, U256::from(0x0u128), context)?, context)?;
            let expr_2 = lt(cleanup_uint128(expr_1, context)?, cleanup_uint128(_9, context)?, context)?;
            // switch
            let δ = expr_2;
            if δ == U256::from(0x0u128) {
                var = U256::from(0x2u128);
                return Ok(var);
            }
            Ok(var)
        }

        pub fn fun_isCancelable_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            var_result = _1;
            let expr = fun__statusOf(var_streamId, context)?;
            let expr_1 = iszero(eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x2u128), context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
                let _3 = read_from_storage_split_offset_30_bool(add(_2, U256::from(0x0u128), context)?, context)?;
                var_result = _3;
            }
            Ok(var_result)
        }

        pub fn modifier_notNull_2806<CI>(var_result: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_result;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_isCancelable_inner(var_result, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_isCancelable<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            var_result = modifier_notNull_2806(zero_bool, var_streamId, context)?;
            Ok(var_result)
        }

        pub fn external_fun_isCancelable<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isCancelable(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_isCold_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            var_result = _1;
            let expr = fun__statusOf(var_streamId, context)?;
            let expr_1 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x2u128), context)?, context)?;
            let mut expr_2 = expr_1;
            if iszero(expr_1, context)? != U256::ZERO {
                let expr_3 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x3u128), context)?, context)?;
                expr_2 = expr_3;
            }
            let mut expr_4 = expr_2;
            if iszero(expr_2, context)? != U256::ZERO {
                let expr_5 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x4u128), context)?, context)?;
                expr_4 = expr_5;
            }
            var_result = expr_4;
            Ok(var_result)
        }

        pub fn modifier_notNull_2835<CI>(var_result: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_result;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_isCold_inner(var_result, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_isCold<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            var_result = modifier_notNull_2835(zero_bool, var_streamId, context)?;
            Ok(var_result)
        }

        pub fn external_fun_isCold<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isCold(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_isDepleted_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            var_result = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_t_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            var_result = _3;
            Ok(var_result)
        }

        pub fn modifier_notNull_2877<CI>(var_result: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_result;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_isDepleted_inner(var_result, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_isDepleted<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            var_result = modifier_notNull_2877(zero_bool, var_streamId, context)?;
            Ok(var_result)
        }

        pub fn external_fun_isDepleted<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isDepleted(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_isStream<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            var_result = _2;
            Ok(var_result)
        }

        pub fn external_fun_isStream<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isStream(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_isTransferable_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            var_result = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_22_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            var_result = _3;
            Ok(var_result)
        }

        pub fn modifier_notNull_2914<CI>(var_result: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_result;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_isTransferable_inner(var_result, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_isTransferable<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            var_result = modifier_notNull_2914(zero_bool, var_streamId, context)?;
            Ok(var_result)
        }

        pub fn external_fun_isTransferable<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isTransferable(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_isWarm_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            var_result = _1;
            let expr = fun__statusOf(var_streamId, context)?;
            let expr_1 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x0u128), context)?, context)?;
            let mut expr_2 = expr_1;
            if iszero(expr_1, context)? != U256::ZERO {
                let expr_3 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x1u128), context)?, context)?;
                expr_2 = expr_3;
            }
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn modifier_notNull_2934<CI>(var_result: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_result;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_isWarm_inner(var_result, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_isWarm<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            var_result = modifier_notNull_2934(zero_bool, var_streamId, context)?;
            Ok(var_result)
        }

        pub fn external_fun_isWarm<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_isWarm(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_name<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var__mpos = U256::ZERO;
            let zero_string_mpos = zero_value_for_split_string(context)?;
            var__mpos = zero_string_mpos;
            var__mpos = convert_array_string_storage_to_string(U256::from(0x1u128), context)?;
            Ok(var__mpos)
        }

        pub fn external_fun_name<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_name(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_string(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn extract_from_storage_value_dynamict_uint256<CI>(slot_value: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint256(shift_right_unsigned_dynamic(mul(offset, U256::from(0x8u128), context)?, slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_dynamic_uint256<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_dynamict_uint256(sload(slot, context)?, offset, context)?;
            Ok(value)
        }

        pub fn getter_fun_nextStreamId<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = read_from_storage_split_dynamic_uint256(U256::from(0x7u128), U256::from(0x0u128), context)?;
            Ok(ret)
        }

        pub fn external_fun_nextStreamId<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_nextStreamId(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn extract_from_storage_value_dynamict_contract_ILockupNFTDescriptor<CI>(slot_value: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_contract_ILockupNFTDescriptor(shift_right_unsigned_dynamic(mul(offset, U256::from(0x8u128), context)?, slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_dynamic_contract_ILockupNFTDescriptor<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_dynamict_contract_ILockupNFTDescriptor(sload(slot, context)?, offset, context)?;
            Ok(value)
        }

        pub fn getter_fun_nftDescriptor<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret_address = U256::ZERO;
            ret_address = read_from_storage_split_dynamic_contract_ILockupNFTDescriptor(U256::from(0x8u128), U256::from(0x0u128), context)?;
            Ok(ret_address)
        }

        pub fn external_fun_nftDescriptor<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = getter_fun_nftDescriptor(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_contract_ILockupNFTDescriptor(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_ownerOf<CI>(var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            let expr = fun_requireOwned(var_tokenId, context)?;
            var = expr;
            Ok(var)
        }

        pub fn external_fun_ownerOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_ownerOf(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_address(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_refundableAmountOf_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_refundableAmount = U256::ZERO;
            var_refundableAmount = _1;
            let _100_slot = U256::from(0xau128);
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_100_slot, var_streamId, context)?;
            let _3 = read_from_storage_split_offset_30_bool(add(_2, U256::from(0x0u128), context)?, context)?;
            let mut expr = _3;
            if _3 != U256::ZERO {
                let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_100_slot, var_streamId, context)?;
                let _5 = read_from_storage_split_offset_t_bool(add(_4, U256::from(0x1u128), context)?, context)?;
                let expr_1 = cleanup_bool(iszero(_5, context)?, context)?;
                expr = expr_1;
            }
            if expr != U256::ZERO {
                let _6 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_100_slot, var_streamId, context)?;
                let _7 = add(_6, U256::from(0x2u128), context)?;
                let _8 = read_from_storage_split_offset_t_uint128(add(_7, U256::from(0x0u128), context)?, context)?;
                let expr_2 = fun_calculateStreamedAmount(var_streamId, context)?;
                let expr_3 = checked_sub_uint128(_8, expr_2, context)?;
                var_refundableAmount = expr_3;
            }
            Ok(var_refundableAmount)
        }

        pub fn modifier_notNull_2970<CI>(var_refundableAmount: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_refundableAmount;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_refundableAmountOf_inner(var_refundableAmount, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_refundableAmountOf<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_refundableAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_refundableAmount = zero_uint128;
            var_refundableAmount = modifier_notNull_2970(zero_uint128, var_streamId, context)?;
            Ok(var_refundableAmount)
        }

        pub fn external_fun_refundableAmountOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_refundableAmountOf(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_renounce<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_30_bool(add(_1, U256::from(0x0u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5c7470b7u128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            update_storage_value_offset_30t_bool_to_bool(add(_4, U256::from(0x0u128), context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn fun_renounce_inner<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun__statusOf(var_streamId, context)?;
            let expr_1 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x4u128), context)?, context)?;
            // switch
            let δ = expr_1;
            if δ == U256::from(0x0u128) {
                let expr_2 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x3u128), context)?, context)?;
                // switch
                let δ = expr_2;
                if δ == U256::from(0x0u128) {
                    let expr_3 = eq(cleanup_enum_Status(expr, context)?, cleanup_enum_Status(U256::from(0x2u128), context)?, context)?;
                    if expr_3 != U256::ZERO {
                        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xfa36c717u128), context)?, context)?;
                        let _1 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                        revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
                    }
                }
            }
            let expr_4 = fun_isCallerStreamSender(var_streamId, context)?;
            let expr_5 = cleanup_bool(iszero(expr_4, context)?, context)?;
            if expr_5 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4dda2c39u128), context)?, context)?;
                let _4 = abi_encode_uint256_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, caller(context)?, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            fun_renounce(var_streamId, context)?;
            let _5 = convert_uint256_to_uint256(var_streamId, context)?;
            let _6 = allocate_unbounded(context)?;
            let _7 = abi_encode_tuple(_6, context)?;
            log2(_6, sub(_7, _6, context)?, U256::from_be_slice(&[0x0e, 0xb0, 0x69, 0x20, 0x70, 0x93, 0xcd, 0x3e, 0x51, 0xcd, 0x13, 0x70, 0xd2, 0xd3, 0x69, 0x77, 0x00, 0x57, 0xfb, 0xe2, 0x99, 0x47, 0xe5, 0x77, 0xe5, 0xfb, 0x42, 0x8c, 0x6c, 0x6f, 0xc7, 0x8f]), _5, context)?;
            Ok(())
        }

        pub fn modifier_notNull_3372<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            fun_renounce_inner(var_streamId, context)?;
            Ok(())
        }

        pub fn modifier_noDelegateCall_3369<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_preventDelegateCall(context)?;
            modifier_notNull_3372(var_streamId, context)?;
            Ok(())
        }

        pub fn fun_renounce_3447<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_noDelegateCall_3369(var_streamId, context)?;
            Ok(())
        }

        pub fn external_fun_renounce<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_renounce_3447(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_renounceMultiple_inner<CI>(var_streamIds_offset: U256, var_streamIds_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = array_length_array_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, context)?;
            let mut var_i = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_1 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_1, context)? != U256::ZERO {
                        break;
                    }
                    let expr_2 = read_from_calldatat_uint256(calldata_array_index_access_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, var_i, context)?, context)?;
                    fun_renounce_3447(expr_2, context)?;
                }
                // post
                {
                    let _1 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _1;
                }
            }
            Ok(())
        }

        pub fn modifier_noDelegateCall_3455<CI>(var_streamIds_offset: U256, var_streamIds_3451_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_preventDelegateCall(context)?;
            fun_renounceMultiple_inner(var_streamIds_offset, var_streamIds_3451_length, context)?;
            Ok(())
        }

        pub fn fun_renounceMultiple<CI>(var_streamIds_offset: U256, var_streamIds_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_noDelegateCall_3455(var_streamIds_offset, var_streamIds_length, context)?;
            Ok(())
        }

        pub fn external_fun_renounceMultiple<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1) = abi_decode_array_uint256_dyn_calldata_ptr(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_renounceMultiple(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_checkOnERC721Received<CI>(var_from: U256, var_to: U256, var_tokenId: U256, var_data_2435_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = extcodesize(var_to, context)?;
            let expr_1 = gt(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                let expr_2445_address = convert_address_to_contract_IERC721Receiver(var_to, context)?;
                let expr_2446_address = convert_contract_IERC721Receiver_to_address(expr_2445_address, context)?;
                let expr_2 = fun_msgSender(context)?;
                let _1 = allocate_unbounded(context)?;
                mstore(_1, shift_left_224(U256::from(0x150b7a02u128), context)?, context)?;
                let _2 = abi_encode_address_address_uint256_bytes(add(_1, U256::from(0x4u128), context)?, expr_2, var_from, var_tokenId, var_data_2435_mpos, context)?;
                let trySuccessCondition = call(gas(context)?, expr_2446_address, U256::from(0x0u128), _1, sub(_2, _1, context)?, _1, U256::from(0x20u128), context)?;
                let mut expr_3 = U256::ZERO;
                if trySuccessCondition != U256::ZERO {
                    let mut _3 = U256::from(0x20u128);
                    if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                        _3 = returndatasize(context)?;
                    }
                    finalize_allocation(_1, _3, context)?;
                    expr_3 = abi_decode_tuple_bytes4_fromMemory(_1, add(_1, _3, context)?, context)?;
                }
                // switch
                let δ = iszero(trySuccessCondition, context)?;
                if δ == U256::from(0x0u128) {
                    let expr_4 = iszero(eq(cleanup_bytes4(expr_3, context)?, cleanup_bytes4(shl(U256::from(0xe1u128), U256::from(0xa85bd01u128), context)?, context)?, context)?, context)?;
                    if expr_4 != U256::ZERO {
                        mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x32505749u128), context)?, context)?;
                        let _4 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_to, context)?;
                        revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
                    }
                }
            }
            Ok(())
        }

        pub fn fun_transferFrom<CI>(var_from: U256, var_to: U256, var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_to, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x32505749u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = fun_msgSender(context)?;
            let expr_3 = fun_update(var_to, var_tokenId, expr_2, context)?;
            let expr_4 = iszero(eq(cleanup_address(expr_3, context)?, cleanup_address(var_from, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x64283d7bu128), context)?, context)?;
                let _2 = abi_encode_address_uint256_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_from, var_tokenId, expr_3, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_safeTransferFrom<CI>(var_from: U256, var_to: U256, var_tokenId: U256, var_data_1826_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_transferFrom(var_from, var_to, var_tokenId, context)?;
            fun_checkOnERC721Received(var_from, var_to, var_tokenId, var_data_1826_mpos, context)?;
            Ok(())
        }

        pub fn fun_safeTransferFrom_1817<CI>(var_from: U256, var_to: U256, var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _261_mpos = convert_stringliteral_c5d2_to_bytes(context)?;
            fun_safeTransferFrom(var_from, var_to, var_tokenId, _261_mpos, context)?;
            Ok(())
        }

        pub fn external_fun_safeTransferFrom<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2) = abi_decode_addresst_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_safeTransferFrom_1817(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_safeTransferFrom_1843<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2, param_3) = abi_decode_addresst_addresst_uint256t_bytes(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_safeTransferFrom(param, param_1, param_2, param_3, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun__setApprovalForAll<CI>(var_owner: U256, var_operator: U256, var_approved: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_operator, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0xb611743u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_operator, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let _2 = mapping_index_access_mapping_address_mapping_address_bool_of_address(U256::from(0x6u128), var_owner, context)?;
            let _3 = mapping_index_access_mapping_address_bool_of_address(_2, var_operator, context)?;
            update_storage_value_offset_0t_bool_to_bool(_3, var_approved, context)?;
            let _4 = convert_address_to_address(var_owner, context)?;
            let _5 = convert_address_to_address(var_operator, context)?;
            let _6 = allocate_unbounded(context)?;
            let _7 = abi_encode_tuple_bool(_6, var_approved, context)?;
            log3(_6, sub(_7, _6, context)?, U256::from_be_slice(&[0x17, 0x30, 0x7e, 0xab, 0x39, 0xab, 0x61, 0x07, 0xe8, 0x89, 0x98, 0x45, 0xad, 0x3d, 0x59, 0xbd, 0x96, 0x53, 0xf2, 0x00, 0xf2, 0x20, 0x92, 0x04, 0x89, 0xca, 0x2b, 0x59, 0x37, 0x69, 0x6c, 0x31]), _4, _5, context)?;
            Ok(())
        }

        pub fn fun_setApprovalForAll<CI>(var_operator: U256, var_approved: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_msgSender(context)?;
            fun__setApprovalForAll(expr, var_operator, var_approved, context)?;
            Ok(())
        }

        pub fn external_fun_setApprovalForAll<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_bool(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_setApprovalForAll(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn extract_from_storage_value_offsett_contract_ILockupNFTDescriptor<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_contract_ILockupNFTDescriptor(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_contract_ILockupNFTDescriptor<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offsett_contract_ILockupNFTDescriptor(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn prepare_store_contract_ILockupNFTDescriptor<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn update_storage_value_offsett_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor(value, context)?;
            sstore(slot, update_byte_slice_20_shift(sload(slot, context)?, prepare_store_contract_ILockupNFTDescriptor(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn fun_setNFTDescriptor_inner<CI>(var_newNFTDescriptor_address: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _428_address = read_from_storage_split_offset_contract_ILockupNFTDescriptor(U256::from(0x8u128), context)?;
            update_storage_value_offsett_contract_ILockupNFTDescriptor_to_contract_ILockupNFTDescriptor(U256::from(0x8u128), var_newNFTDescriptor_address, context)?;
            let _1 = convert_address_to_address(caller(context)?, context)?;
            let _2 = allocate_unbounded(context)?;
            let _3 = abi_encode_contract_ILockupNFTDescriptor_contract_ILockupNFTDescriptor(_2, _428_address, var_newNFTDescriptor_address, context)?;
            log2(_2, sub(_3, _2, context)?, U256::from_be_slice(&[0xa2, 0x54, 0x8b, 0xd4, 0xb8, 0x05, 0xe9, 0x07, 0xc1, 0x55, 0x8a, 0x47, 0xb5, 0x85, 0x83, 0x24, 0xfe, 0x8b, 0xb4, 0xa2, 0xe1, 0xdd, 0xfc, 0xa6, 0x47, 0xee, 0xcb, 0xf6, 0x56, 0x10, 0xee, 0xbc]), _1, context)?;
            let _4 = read_from_storage_split_offset_uint256(U256::from(0x7u128), context)?;
            let expr = checked_sub_uint256(_4, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let _5 = allocate_unbounded(context)?;
            let _6 = abi_encode_rational_by_uint256(_5, U256::from(0x1u128), expr, context)?;
            log1(_5, sub(_6, _5, context)?, U256::from_be_slice(&[0x6b, 0xd5, 0xc9, 0x50, 0xa8, 0xd8, 0xdf, 0x17, 0xf7, 0x72, 0xf5, 0xaf, 0x37, 0xcb, 0x36, 0x55, 0x73, 0x78, 0x99, 0xcb, 0xf9, 0x03, 0x26, 0x4b, 0x97, 0x95, 0x59, 0x2d, 0xa4, 0x39, 0x66, 0x1c]), context)?;
            Ok(())
        }

        pub fn modifier_onlyAdmin<CI>(var_newNFTDescriptor_address: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = iszero(eq(cleanup_address(_1, context)?, cleanup_address(caller(context)?, context)?, context)?, context)?;
            if expr != U256::ZERO {
                let _2 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x31b339a9u128), context)?, context)?;
                let _3 = abi_encode_address_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _2, caller(context)?, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            fun_setNFTDescriptor_inner(var_newNFTDescriptor_address, context)?;
            Ok(())
        }

        pub fn fun_setNFTDescriptor<CI>(var_newNFTDescriptor_address: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyAdmin(var_newNFTDescriptor_address, context)?;
            Ok(())
        }

        pub fn external_fun_setNFTDescriptor<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_contract_ILockupNFTDescriptor(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_setNFTDescriptor(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_statusOf_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_status = U256::ZERO;
            var_status = _1;
            let expr = fun__statusOf(var_streamId, context)?;
            var_status = expr;
            Ok(var_status)
        }

        pub fn modifier_notNull_3007<CI>(var_status: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_status;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_statusOf_inner(var_status, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_statusOf<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_status = U256::ZERO;
            let zero_enum_Status = zero_value_for_split_enum_Status(context)?;
            var_status = zero_enum_Status;
            var_status = modifier_notNull_3007(zero_enum_Status, var_streamId, context)?;
            Ok(var_status)
        }

        pub fn external_fun_statusOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_statusOf(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_enum_Status(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun__streamedAmountOf<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_ = U256::ZERO;
            let zero_t_uint128 = zero_value_for_split_uint128(context)?;
            var_ = zero_t_uint128;
            let _1450_slot = U256::from(0xau128);
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1450_slot, var_streamId, context)?;
            let _2 = add(_1, U256::from(0x2u128), context)?;
            let var_amounts_mpos = convert_struct_Amounts_storage_to_struct_Amounts(_2, context)?;
            let _3 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1450_slot, var_streamId, context)?;
            let _4 = read_from_storage_split_offset_t_bool(add(_3, U256::from(0x1u128), context)?, context)?;
            // switch
            let δ = _4;
            if δ == U256::from(0x0u128) {
                let _5 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1450_slot, var_streamId, context)?;
                let _6 = read_from_storage_split_offset_31_bool(add(_5, U256::from(0x0u128), context)?, context)?;
                if _6 != U256::ZERO {
                    let _7 = read_from_memoryt_uint128(add(var_amounts_mpos, U256::from(0x0u128), context)?, context)?;
                    let _8 = read_from_memoryt_uint128(add(var_amounts_mpos, U256::from(0x40u128), context)?, context)?;
                    let expr = checked_sub_uint128(_7, _8, context)?;
                    var_ = expr;
                    return Ok(var_);
                }
            }
            let expr_1 = fun_calculateStreamedAmount(var_streamId, context)?;
            var_ = expr_1;
            Ok(var_)
        }

        pub fn fun_streamedAmountOf_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamedAmount = U256::ZERO;
            var_streamedAmount = _1;
            let expr = fun__streamedAmountOf(var_streamId, context)?;
            var_streamedAmount = expr;
            Ok(var_streamedAmount)
        }

        pub fn modifier_notNull_3027<CI>(var_streamedAmount: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_streamedAmount;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_streamedAmountOf_inner(var_streamedAmount, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_streamedAmountOf<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_streamedAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_streamedAmount = zero_uint128;
            var_streamedAmount = modifier_notNull_3027(zero_uint128, var_streamId, context)?;
            Ok(var_streamedAmount)
        }

        pub fn external_fun_streamedAmountOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_streamedAmountOf(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_supportsInterface<CI>(var_interfaceId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let expr = eq(cleanup_bytes4(var_interfaceId, context)?, cleanup_bytes4(shl(U256::from(0xe0u128), U256::from(0x1ffc9a7u128), context)?, context)?, context)?;
            var = expr;
            Ok(var)
        }

        pub fn fun_supportsInterface_1583<CI>(var_interfaceId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let expr = eq(cleanup_bytes4(var_interfaceId, context)?, cleanup_bytes4(shl(U256::from(0xe0u128), U256::from(0x80ac58cdu128), context)?, context)?, context)?;
            let mut expr_1 = expr;
            if iszero(expr, context)? != U256::ZERO {
                let expr_2 = eq(cleanup_bytes4(var_interfaceId, context)?, cleanup_bytes4(shl(U256::from(0xe0u128), U256::from(0x5b5e139fu128), context)?, context)?, context)?;
                expr_1 = expr_2;
            }
            let mut expr_3 = expr_1;
            if iszero(expr_1, context)? != U256::ZERO {
                let expr_4 = fun_supportsInterface(var_interfaceId, context)?;
                expr_3 = expr_4;
            }
            var = expr_3;
            Ok(var)
        }

        pub fn fun_supportsInterface_3059<CI>(var_interfaceId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let expr = eq(cleanup_bytes4(var_interfaceId, context)?, convert_rational_by_to_bytes4(U256::from(0x49064906u128), context)?, context)?;
            let mut expr_1 = expr;
            if iszero(expr, context)? != U256::ZERO {
                let expr_2 = fun_supportsInterface_1583(var_interfaceId, context)?;
                expr_1 = expr_2;
            }
            var = expr_1;
            Ok(var)
        }

        pub fn external_fun_supportsInterface<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_bytes4(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_supportsInterface_3059(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_symbol<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_1637_mpos = U256::ZERO;
            let zero_t_string_mpos = zero_value_for_split_string(context)?;
            var_1637_mpos = zero_t_string_mpos;
            var_1637_mpos = convert_array_string_storage_to_string(U256::from(0x2u128), context)?;
            Ok(var_1637_mpos)
        }

        pub fn external_fun_symbol<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_symbol(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_string(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_tokenURI<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_uri_mpos = U256::ZERO;
            let zero_string_memory_ptr_mpos = zero_value_for_split_string(context)?;
            var_uri_mpos = zero_string_memory_ptr_mpos;
            pop(fun_requireOwned(var_streamId, context)?, context)?;
            let _774_address = read_from_storage_split_offset_contract_ILockupNFTDescriptor(U256::from(0x8u128), context)?;
            let expr_3076_address = convert_contract_ILockupNFTDescriptor_to_address(_774_address, context)?;
            let _1 = allocate_unbounded(context)?;
            mstore(_1, shift_left_224(U256::from(0xe9dc6375u128), context)?, context)?;
            let _2 = abi_encode_contract_SablierLockupBase_uint256(add(_1, U256::from(0x4u128), context)?, address(context)?, var_streamId, context)?;
            let _3 = staticcall(gas(context)?, expr_3076_address, _1, sub(_2, _1, context)?, _1, U256::from(0x0u128), context)?;
            if iszero(_3, context)? != U256::ZERO {
                revert_forward(context)?;
            }
            let mut expr_3079_mpos = U256::ZERO;
            if _3 != U256::ZERO {
                let _4 = returndatasize(context)?;
                returndatacopy(_1, U256::from(0x0u128), _4, context)?;
                finalize_allocation(_1, _4, context)?;
                expr_3079_mpos = abi_decode_string_fromMemory(_1, add(_1, _4, context)?, context)?;
            }
            var_uri_mpos = expr_3079_mpos;
            Ok(var_uri_mpos)
        }

        pub fn external_fun_tokenURI<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_tokenURI(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_string(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_transferAdmin_inner<CI>(var_newAdmin: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            update_storage_value_offsett_address_to_address(U256::from(0x0u128), var_newAdmin, context)?;
            let _1 = convert_address_to_address(caller(context)?, context)?;
            let _2 = convert_address_to_address(var_newAdmin, context)?;
            let _3 = allocate_unbounded(context)?;
            let _4 = abi_encode_tuple(_3, context)?;
            log3(_3, sub(_4, _3, context)?, U256::from_be_slice(&[0xbd, 0xd3, 0x61, 0x43, 0xee, 0x09, 0xde, 0x60, 0xbd, 0xef, 0xca, 0x70, 0x68, 0x0e, 0x0f, 0x71, 0x18, 0x9b, 0x2e, 0xd7, 0xac, 0xee, 0x36, 0x4b, 0x53, 0x91, 0x7a, 0xd4, 0x33, 0xfd, 0xaf, 0x80]), _1, _2, context)?;
            Ok(())
        }

        pub fn modifier_onlyAdmin_7467<CI>(var_newAdmin: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
            let expr = iszero(eq(cleanup_address(_1, context)?, cleanup_address(caller(context)?, context)?, context)?, context)?;
            if expr != U256::ZERO {
                let _2 = read_from_storage_split_offset_address(U256::from(0x0u128), context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x31b339a9u128), context)?, context)?;
                let _3 = abi_encode_address_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _2, caller(context)?, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            fun_transferAdmin_inner(var_newAdmin, context)?;
            Ok(())
        }

        pub fn fun_transferAdmin<CI>(var_newAdmin: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_onlyAdmin_7467(var_newAdmin, context)?;
            Ok(())
        }

        pub fn external_fun_transferAdmin<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_transferAdmin(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn external_fun_transferFrom<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2) = abi_decode_addresst_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_transferFrom(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_wasCanceled_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            var_result = _1;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_31_bool(add(_2, U256::from(0x0u128), context)?, context)?;
            var_result = _3;
            Ok(var_result)
        }

        pub fn modifier_notNull_3091<CI>(var_result: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_result;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_wasCanceled_inner(var_result, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_wasCanceled<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            var_result = modifier_notNull_3091(zero_bool, var_streamId, context)?;
            Ok(var_result)
        }

        pub fn external_fun_wasCanceled<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_wasCanceled(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun__withdraw<CI>(var_streamId: U256, var_to: U256, var_amount: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1634_slot = U256::from(0xau128);
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1634_slot, var_streamId, context)?;
            let _2 = add(_1, U256::from(0x2u128), context)?;
            let _3 = read_from_storage_split_offset_uint128(add(_2, U256::from(0x0u128), context)?, context)?;
            let expr = checked_add_uint128(_3, var_amount, context)?;
            let _4 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1634_slot, var_streamId, context)?;
            let _5 = add(_4, U256::from(0x2u128), context)?;
            update_storage_value_offsett_uint128_to_t_uint128(add(_5, U256::from(0x0u128), context)?, expr, context)?;
            let _6 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1634_slot, var_streamId, context)?;
            let _7 = add(_6, U256::from(0x2u128), context)?;
            let var_amounts_4300_mpos = convert_struct_Amounts_storage_to_struct_Amounts(_7, context)?;
            let _8 = read_from_memoryt_uint128(add(var_amounts_4300_mpos, U256::from(0x20u128), context)?, context)?;
            let _9 = read_from_memoryt_uint128(add(var_amounts_4300_mpos, U256::from(0x0u128), context)?, context)?;
            let _10 = read_from_memoryt_uint128(add(var_amounts_4300_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_1 = checked_sub_uint128(_9, _10, context)?;
            let expr_2 = iszero(lt(cleanup_uint128(_8, context)?, cleanup_uint128(expr_1, context)?, context)?, context)?;
            if expr_2 != U256::ZERO {
                let _11 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1634_slot, var_streamId, context)?;
                update_storage_value_offsett_bool_to_bool(add(_11, U256::from(0x1u128), context)?, U256::from(0x1u128), context)?;
                let _12 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1634_slot, var_streamId, context)?;
                update_storage_value_offset_30t_bool_to_bool(add(_12, U256::from(0x0u128), context)?, U256::from(0x0u128), context)?;
            }
            let _13 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(_1634_slot, var_streamId, context)?;
            let _1680_address = read_from_storage_split_offset_contract_IERC20(add(_13, U256::from(0x1u128), context)?, context)?;
            let _14 = convert_uint128_to_uint256(var_amount, context)?;
            fun_safeTransfer(_1680_address, var_to, _14, context)?;
            let _15 = convert_uint256_to_uint256(var_streamId, context)?;
            let _16 = convert_address_to_address(var_to, context)?;
            let _1692_address = convert_contract_IERC20_to_contract_IERC20(_1680_address, context)?;
            let _17 = allocate_unbounded(context)?;
            let _18 = abi_encode_tuple_uint128(_17, var_amount, context)?;
            log4(_17, sub(_18, _17, context)?, U256::from_be_slice(&[0x40, 0xb8, 0x8e, 0x5c, 0x41, 0xc5, 0xa9, 0x7f, 0xfb, 0x7b, 0x6e, 0xf8, 0x8a, 0x0a, 0x2d, 0x50, 0x5a, 0xa0, 0xc6, 0x34, 0xcf, 0x8a, 0x02, 0x75, 0xcb, 0x23, 0x6e, 0xa7, 0xdd, 0x87, 0xed, 0x4d]), _15, _16, _1692_address, context)?;
            Ok(())
        }

        pub fn fun_withdrawableAmountOf<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var = zero_uint128;
            let expr = fun__streamedAmountOf(var_streamId, context)?;
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = add(_1, U256::from(0x2u128), context)?;
            let _3 = read_from_storage_split_offset_uint128(add(_2, U256::from(0x0u128), context)?, context)?;
            let expr_1 = checked_sub_uint128(expr, _3, context)?;
            var = expr_1;
            Ok(var)
        }

        pub fn fun_withdraw_inner<CI>(var_streamId: U256, var_to: U256, var_amount: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_t_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            if _2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x449491f5u128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_to, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16c90d27u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = fun__ownerOf(var_streamId, context)?;
            let expr_3 = iszero(eq(cleanup_address(var_to, context)?, cleanup_address(expr_2, context)?, context)?, context)?;
            let mut expr_4 = expr_3;
            if expr_3 != U256::ZERO {
                let expr_5 = fun_isCallerStreamRecipientOrApproved(var_streamId, expr_2, context)?;
                let expr_6 = cleanup_bool(iszero(expr_5, context)?, context)?;
                expr_4 = expr_6;
            }
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe6u128), U256::from(0x97d0a3u128), context)?, context)?;
                let _5 = abi_encode_uint256_address_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, caller(context)?, var_to, context)?;
                revert(U256::from(0x0u128), sub(_5, U256::from(0x0u128), context)?, context)?;
            }
            let expr_7 = eq(cleanup_uint128(var_amount, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr_7 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x3dd1eadfu128), context)?, context)?;
                let _6 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_6, U256::from(0x0u128), context)?, context)?;
            }
            let expr_8 = fun_withdrawableAmountOf(var_streamId, context)?;
            let expr_9 = gt(cleanup_uint128(var_amount, context)?, cleanup_uint128(expr_8, context)?, context)?;
            if expr_9 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x21765461u128), context)?, context)?;
                let _7 = abi_encode_uint256_uint128_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, var_amount, expr_8, context)?;
                revert(U256::from(0x0u128), sub(_7, U256::from(0x0u128), context)?, context)?;
            }
            fun__withdraw(var_streamId, var_to, var_amount, context)?;
            let _8 = allocate_unbounded(context)?;
            let _9 = abi_encode_uint256(_8, var_streamId, context)?;
            log1(_8, sub(_9, _8, context)?, U256::from_be_slice(&[0xf8, 0xe1, 0xa1, 0x5a, 0xba, 0x93, 0x98, 0xe0, 0x19, 0xf0, 0xb4, 0x9d, 0xf1, 0xa4, 0xfd, 0xe9, 0x8e, 0xe1, 0x7a, 0xe3, 0x45, 0xcb, 0x5f, 0x6b, 0x5e, 0x2c, 0x27, 0xf5, 0x03, 0x3e, 0x8c, 0xe7]), context)?;
            let expr_10 = iszero(eq(cleanup_address(caller(context)?, context)?, cleanup_address(expr_2, context)?, context)?, context)?;
            let mut expr_11 = expr_10;
            if expr_10 != U256::ZERO {
                let _10 = mapping_index_access_mapping_address_bool_of_address(U256::from(0x9u128), expr_2, context)?;
                let _11 = read_from_storage_split_offset_0_bool(_10, context)?;
                expr_11 = _11;
            }
            if expr_11 != U256::ZERO {
                let expr_3637_address = convert_address_to_contract_ISablierLockupRecipient(expr_2, context)?;
                let expr_3638_address = convert_contract_ISablierLockupRecipient_to_address(expr_3637_address, context)?;
                let _12 = allocate_unbounded(context)?;
                mstore(_12, shift_left_224(U256::from(0x92b9102bu128), context)?, context)?;
                let _13 = abi_encode_uint256_address_address_uint128(add(_12, U256::from(0x4u128), context)?, var_streamId, caller(context)?, var_to, var_amount, context)?;
                let _14 = call(gas(context)?, expr_3638_address, U256::from(0x0u128), _12, sub(_13, _12, context)?, _12, U256::from(0x20u128), context)?;
                if iszero(_14, context)? != U256::ZERO {
                    revert_forward(context)?;
                }
                let mut expr_12 = U256::ZERO;
                if _14 != U256::ZERO {
                    let mut _15 = U256::from(0x20u128);
                    if gt(U256::from(0x20u128), returndatasize(context)?, context)? != U256::ZERO {
                        _15 = returndatasize(context)?;
                    }
                    finalize_allocation(_12, _15, context)?;
                    expr_12 = abi_decode_tuple_bytes4_fromMemory(_12, add(_12, _15, context)?, context)?;
                }
                let expr_13 = iszero(eq(cleanup_bytes4(expr_12, context)?, cleanup_bytes4(shl(U256::from(0xe0u128), U256::from(0x92b9102bu128), context)?, context)?, context)?, context)?;
                if expr_13 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5f3a039du128), context)?, context)?;
                    let _16 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr_2, context)?;
                    revert(U256::from(0x0u128), sub(_16, U256::from(0x0u128), context)?, context)?;
                }
            }
            Ok(())
        }

        pub fn modifier_notNull_3531<CI>(var_streamId: U256, var_to: U256, var_amount: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let _1 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _2 = read_from_storage_split_offset_bool(add(_1, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_2, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _3 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            fun_withdraw_inner(var_streamId, var_to, var_amount, context)?;
            Ok(())
        }

        pub fn modifier_noDelegateCall_3528<CI>(var_streamId: U256, var_to: U256, var_amount: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_preventDelegateCall(context)?;
            modifier_notNull_3531(var_streamId, var_to, var_amount, context)?;
            Ok(())
        }

        pub fn fun_withdraw<CI>(var_streamId: U256, var_to: U256, var_amount: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_noDelegateCall_3528(var_streamId, var_to, var_amount, context)?;
            Ok(())
        }

        pub fn external_fun_withdraw<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2) = abi_decode_uint256t_addresst_uint128(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_withdraw(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_withdrawMax<CI>(var_streamId: U256, var_to: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_withdrawnAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_withdrawnAmount = zero_uint128;
            let expr = fun_withdrawableAmountOf(var_streamId, context)?;
            var_withdrawnAmount = expr;
            fun_withdraw(var_streamId, var_to, expr, context)?;
            Ok(var_withdrawnAmount)
        }

        pub fn external_fun_withdrawMax<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1) = abi_decode_uint256t_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_withdrawMax(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_transfer<CI>(var_from: U256, var_to: U256, var_tokenId: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_to, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x32505749u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = fun_update(var_to, var_tokenId, expr, context)?;
            let expr_3 = eq(cleanup_address(expr_2, context)?, cleanup_address(expr, context)?, context)?;
            // switch
            let δ = expr_3;
            if δ == U256::from(0x0u128) {
                let expr_4 = iszero(eq(cleanup_address(expr_2, context)?, cleanup_address(var_from, context)?, context)?, context)?;
                if expr_4 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x64283d7bu128), context)?, context)?;
                    let _2 = abi_encode_address_uint256_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_from, var_tokenId, expr_2, context)?;
                    revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
                }
            }
            Ok(())
        }

        pub fn fun_withdrawMaxAndTransfer_inner<CI>(_1: U256, var_streamId: U256, var_newRecipient: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_withdrawnAmount = U256::ZERO;
            var_withdrawnAmount = _1;
            let expr = fun__ownerOf(var_streamId, context)?;
            let expr_1 = fun_isCallerStreamRecipientOrApproved(var_streamId, expr, context)?;
            let expr_2 = cleanup_bool(iszero(expr_1, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4dda2c39u128), context)?, context)?;
                let _2 = abi_encode_uint256_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, caller(context)?, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let expr_3 = fun_withdrawableAmountOf(var_streamId, context)?;
            var_withdrawnAmount = expr_3;
            let expr_4 = gt(cleanup_uint128(expr_3, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr_4 != U256::ZERO {
                fun_withdraw(var_streamId, expr, expr_3, context)?;
            }
            fun_transfer(expr, var_newRecipient, var_streamId, context)?;
            Ok(var_withdrawnAmount)
        }

        pub fn modifier_notNull_3698<CI>(var_withdrawnAmount: U256, var_streamId: U256, var_newRecipient: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_withdrawnAmount;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_withdrawMaxAndTransfer_inner(var_withdrawnAmount, var_streamId, var_newRecipient, context)?;
            Ok(_1)
        }

        pub fn modifier_noDelegateCall_3695<CI>(var_withdrawnAmount: U256, var_streamId: U256, var_newRecipient: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_withdrawnAmount;
            fun_preventDelegateCall(context)?;
            _1 = modifier_notNull_3698(var_withdrawnAmount, var_streamId, var_newRecipient, context)?;
            Ok(_1)
        }

        pub fn fun_withdrawMaxAndTransfer<CI>(var_streamId: U256, var_newRecipient: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_withdrawnAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_withdrawnAmount = zero_uint128;
            var_withdrawnAmount = modifier_noDelegateCall_3695(zero_uint128, var_streamId, var_newRecipient, context)?;
            Ok(var_withdrawnAmount)
        }

        pub fn external_fun_withdrawMaxAndTransfer<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1) = abi_decode_uint256t_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_withdrawMaxAndTransfer(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_withdrawMultiple_inner<CI>(var_streamIds_offset: U256, var_streamIds_length: U256, var_amounts_offset: U256, var_amounts_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = array_length_array_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, context)?;
            let expr_1 = array_length_array_uint128_dyn_calldata(var_amounts_offset, var_amounts_length, context)?;
            let expr_2 = iszero(eq(cleanup_uint256(expr, context)?, cleanup_uint256(expr_1, context)?, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x6050d1adu128), context)?, context)?;
                let _1 = abi_encode_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, expr_1, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_i = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while U256::from(0x1u128) != U256::ZERO {
                // body
                {
                    let expr_3 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_3, context)? != U256::ZERO {
                        break;
                    }
                    let expr_4 = convert_contract_SablierLockupBase_to_address(address(context)?, context)?;
                    let expr_5 = read_from_calldatat_uint256(calldata_array_index_access_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, var_i, context)?, context)?;
                    let expr_6 = read_from_calldatat_uint256(calldata_array_index_access_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, var_i, context)?, context)?;
                    let expr_7 = fun__ownerOf(expr_6, context)?;
                    let expr_8 = read_from_calldatat_uint128(calldata_array_index_access_uint128_dyn_calldata(var_amounts_offset, var_amounts_length, var_i, context)?, context)?;
                    let expr_3817_mpos = allocate_unbounded(context)?;
                    let mut _3 = add(expr_3817_mpos, U256::from(0x20u128), context)?;
                    mstore(_3, shl(U256::from(0xe5u128), U256::from(0x7eea36bu128), context)?, context)?;
                    _3 = add(_3, U256::from(0x4u128), context)?;
                    let _4 = abi_encode_uint256_address_uint128(_3, expr_5, expr_7, expr_8, context)?;
                    mstore(expr_3817_mpos, sub(_4, add(expr_3817_mpos, U256::from(0x20u128), context)?, context)?, context)?;
                    finalize_allocation(expr_3817_mpos, sub(_4, expr_3817_mpos, context)?, context)?;
                    let _5 = mload(expr_3817_mpos, context)?;
                    let expr_component = delegatecall(gas(context)?, expr_4, add(expr_3817_mpos, U256::from(0x20u128), context)?, _5, U256::from(0x0u128), U256::from(0x0u128), context)?;
                    let expr_3818_component_2_mpos = extract_returndata(context)?;
                    let expr_9 = cleanup_bool(iszero(expr_component, context)?, context)?;
                    if expr_9 != U256::ZERO {
                        let expr_10 = read_from_calldatat_uint256(calldata_array_index_access_uint256_dyn_calldata(var_streamIds_offset, var_streamIds_length, var_i, context)?, context)?;
                        let _6 = allocate_unbounded(context)?;
                        let _7 = abi_encode_uint256_bytes(_6, expr_10, expr_3818_component_2_mpos, context)?;
                        log1(_6, sub(_7, _6, context)?, U256::from_be_slice(&[0x36, 0xb7, 0xa9, 0xa3, 0xf5, 0xbf, 0xe6, 0x9a, 0xd6, 0xae, 0x04, 0x10, 0x77, 0x96, 0xa9, 0x67, 0xde, 0x5c, 0x92, 0xc7, 0x61, 0xb4, 0xd7, 0xa4, 0xc3, 0x4e, 0x98, 0x56, 0x70, 0x66, 0x64, 0x19]), context)?;
                    }
                }
                // post
                {
                    let _2 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _2;
                }
            }
            Ok(())
        }

        pub fn modifier_noDelegateCall_3758<CI>(var_streamIds_3751_offset: U256, var_streamIds_length: U256, var_amounts_offset: U256, var_amounts_3754_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_preventDelegateCall(context)?;
            fun_withdrawMultiple_inner(var_streamIds_3751_offset, var_streamIds_length, var_amounts_offset, var_amounts_3754_length, context)?;
            Ok(())
        }

        pub fn fun_withdrawMultiple<CI>(var_streamIds_offset: U256, var_streamIds_length: U256, var_amounts_offset: U256, var_amounts_length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            modifier_noDelegateCall_3758(var_streamIds_offset, var_streamIds_length, var_amounts_offset, var_amounts_length, context)?;
            Ok(())
        }

        pub fn external_fun_withdrawMultiple<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let (param, param_1, param_2, param_3) = abi_decode_array_uint256_dyn_calldatat_array_uint128_dyn_calldata(U256::from(0x4u128), calldatasize(context)?, context)?;
            fun_withdrawMultiple(param, param_1, param_2, param_3, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple(memPos, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_withdrawableAmountOf_inner<CI>(_1: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_withdrawableAmount = U256::ZERO;
            var_withdrawableAmount = _1;
            let expr = fun_withdrawableAmountOf(var_streamId, context)?;
            var_withdrawableAmount = expr;
            Ok(var_withdrawableAmount)
        }

        pub fn modifier_notNull_3111<CI>(var_withdrawableAmount: U256, var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut _1 = U256::ZERO;
            _1 = var_withdrawableAmount;
            let _2 = mapping_index_access_mapping_uint256_struct_Stream_storage_of_uint256(U256::from(0xau128), var_streamId, context)?;
            let _3 = read_from_storage_split_offset_bool(add(_2, U256::from(0x1u128), context)?, context)?;
            let expr = cleanup_bool(iszero(_3, context)?, context)?;
            if expr != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x16437701u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_streamId, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            _1 = fun_withdrawableAmountOf_inner(var_withdrawableAmount, var_streamId, context)?;
            Ok(_1)
        }

        pub fn fun_withdrawableAmountOf_3122<CI>(var_streamId: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_withdrawableAmount = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_withdrawableAmount = zero_uint128;
            var_withdrawableAmount = modifier_notNull_3111(zero_uint128, var_streamId, context)?;
            Ok(var_withdrawableAmount)
        }

        pub fn external_fun_withdrawableAmountOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_withdrawableAmountOf_3122(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_tuple_uint128(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_224_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x40u128), U256::from(0x80u128), context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_224_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                // switch
                let δ = selector;
                if δ == U256::from(0xdba286u128) {
                    external_fun_createWithDurationsLL(context)?;
                } else if δ == U256::from(0x1ffc9a7u128) {
                    external_fun_supportsInterface(context)?;
                } else if δ == U256::from(0x27b6744u128) {
                    external_fun_MAX_BROKER_FEE(context)?;
                } else if δ == U256::from(0x6fdde03u128) {
                    external_fun_name(context)?;
                } else if δ == U256::from(0x81812fcu128) {
                    external_fun_getApproved(context)?;
                } else if δ == U256::from(0x95ea7b3u128) {
                    external_fun_approve(context)?;
                } else if δ == U256::from(0xaef4433u128) {
                    external_fun_createWithDurationsLD(context)?;
                } else if δ == U256::from(0x1400ececu128) {
                    external_fun_refundableAmountOf(context)?;
                } else if δ == U256::from(0x1c1cdd4cu128) {
                    external_fun_isWarm(context)?;
                } else if δ == U256::from(0x1e897afbu128) {
                    external_fun_batch(context)?;
                } else if δ == U256::from(0x1e99d569u128) {
                    external_fun_nextStreamId(context)?;
                } else if δ == U256::from(0x22bc0a80u128) {
                    external_fun_createWithTimestampsLD(context)?;
                } else if δ == U256::from(0x23b872ddu128) {
                    external_fun_transferFrom(context)?;
                } else if δ == U256::from(0x303acc85u128) {
                    external_fun_isAllowedToHook(context)?;
                } else if δ == U256::from(0x406887cbu128) {
                    external_fun_allowToHook(context)?;
                } else if δ == U256::from(0x40e58ee5u128) {
                    external_fun_cancel(context)?;
                } else if δ == U256::from(0x425d30ddu128) {
                    external_fun_isDepleted(context)?;
                } else if δ == U256::from(0x42842e0eu128) {
                    external_fun_safeTransferFrom(context)?;
                } else if δ == U256::from(0x42966c68u128) {
                    external_fun_burn(context)?;
                } else if δ == U256::from(0x44267570u128) {
                    external_fun_nftDescriptor(context)?;
                } else if δ == U256::from(0x4857501fu128) {
                    external_fun_isCancelable(context)?;
                } else if δ == U256::from(0x4869e12du128) {
                    external_fun_streamedAmountOf(context)?;
                } else if δ == U256::from(0x4cc55e11u128) {
                    external_fun_withdrawMultiple(context)?;
                } else if δ == U256::from(0x6352211eu128) {
                    external_fun_ownerOf(context)?;
                } else if δ == U256::from(0x6d0cee75u128) {
                    external_fun_getRecipient(context)?;
                } else if δ == U256::from(0x70a08231u128) {
                    external_fun_balanceOf(context)?;
                } else if δ == U256::from(0x727b3b0au128) {
                    external_fun_renounceMultiple(context)?;
                } else if δ == U256::from(0x75829defu128) {
                    external_fun_transferAdmin(context)?;
                } else if δ == U256::from(0x77163c1du128) {
                    external_fun_MAX_COUNT(context)?;
                } else if δ == U256::from(0x780a82c8u128) {
                    external_fun_getCliffTime(context)?;
                } else if δ == U256::from(0x7a695841u128) {
                    external_fun_createWithTimestampsLL(context)?;
                } else if δ == U256::from(0x7cad6cd1u128) {
                    external_fun_setNFTDescriptor(context)?;
                } else if δ == U256::from(0x7de6b1dbu128) {
                    external_fun_renounce(context)?;
                } else if δ == U256::from(0x7ee21391u128) {
                    external_fun_createWithTimestampsLT(context)?;
                } else if δ == U256::from(0x7f5799f9u128) {
                    external_fun_getTranches(context)?;
                } else if δ == U256::from(0x8659c270u128) {
                    external_fun_cancelMultiple(context)?;
                } else if δ == U256::from(0x8f69b993u128) {
                    external_fun_isCold(context)?;
                } else if δ == U256::from(0x9067b677u128) {
                    external_fun_getEndTime(context)?;
                } else if δ == U256::from(0x95d89b41u128) {
                    external_fun_symbol(context)?;
                } else if δ == U256::from(0xa22cb465u128) {
                    external_fun_setApprovalForAll(context)?;
                } else if δ == U256::from(0xa4775772u128) {
                    external_fun_getUnderlyingToken(context)?;
                } else if δ == U256::from(0xa80fc071u128) {
                    external_fun_getDepositedAmount(context)?;
                } else if δ == U256::from(0xad35efd4u128) {
                    external_fun_statusOf(context)?;
                } else if δ == U256::from(0xb2564569u128) {
                    external_fun_isTransferable(context)?;
                } else if δ == U256::from(0xb637b865u128) {
                    external_fun_getSegments(context)?;
                } else if δ == U256::from(0xb88d4fdeu128) {
                    external_fun_safeTransferFrom_1843(context)?;
                } else if δ == U256::from(0xb8a3be66u128) {
                    external_fun_isStream(context)?;
                } else if δ == U256::from(0xb971302au128) {
                    external_fun_getSender(context)?;
                } else if δ == U256::from(0xbc2be1beu128) {
                    external_fun_getStartTime(context)?;
                } else if δ == U256::from(0xc156a11du128) {
                    external_fun_withdrawMaxAndTransfer(context)?;
                } else if δ == U256::from(0xc8796572u128) {
                    external_fun_collectFees(context)?;
                } else if δ == U256::from(0xc87b56ddu128) {
                    external_fun_tokenURI(context)?;
                } else if δ == U256::from(0xd4dbd20bu128) {
                    external_fun_getRefundedAmount(context)?;
                } else if δ == U256::from(0xd511609fu128) {
                    external_fun_getWithdrawnAmount(context)?;
                } else if δ == U256::from(0xd975dfedu128) {
                    external_fun_withdrawableAmountOf(context)?;
                } else if δ == U256::from(0xdeecd64fu128) {
                    external_fun_createWithDurationsLT(context)?;
                } else if δ == U256::from(0xdf2a848cu128) {
                    external_fun_getUnlockAmounts(context)?;
                } else if δ == U256::from(0xe6c417ebu128) {
                    external_fun_getLockupModel(context)?;
                } else if δ == U256::from(0xe985e9c5u128) {
                    external_fun_isApprovedForAll(context)?;
                } else if δ == U256::from(0xea5ead19u128) {
                    external_fun_withdrawMax(context)?;
                } else if δ == U256::from(0xf590c176u128) {
                    external_fun_wasCanceled(context)?;
                } else if δ == U256::from(0xf851a440u128) {
                    external_fun_admin(context)?;
                } else if δ == U256::from(0xfdd46d60u128) {
                    external_fun_withdraw(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let mut context = Context {
        contract_interactions: std::marker::PhantomData::<DummyContractInteractions>,
        memory: Memory::new(),
        immutables: std::collections::HashMap::new(),
        storage: std::collections::HashMap::new(),
        address: U256::from(123),
        caller: U256::from(124),
        callvalue: U256::from(12),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
        chain_id: U256::from(123456),
    };

    // let result = exp_unit_test::exp_unit_test_deployed::fun_test_Exp(&mut context);
    // println!("result: {:#?}", result);
    // println!("context: {:#?}", context);
}
