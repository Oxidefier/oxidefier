// Generated by Oxidefier

#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod helpers_5716 {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn allocate_unbounded(context: &mut Context) -> YulOutput<U256> {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context: &mut Context) -> YulOutput<()> {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body(context: &mut Context) -> YulOutput<()> {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let _1 = allocate_unbounded(context)?;
        codecopy(_1, dataoffset(from_hex("48656c706572735f353731365f6465706c6f7965640000000000000000000000"), context)?, datasize(from_hex("48656c706572735f353731365f6465706c6f7965640000000000000000000000"), context)?, context)?;
        setimmutable(_1, from_hex("6c6962726172795f6465706c6f795f6164647265737300000000000000000000"), address(context)?, context)?;
        return_(_1, datasize(from_hex("48656c706572735f353731365f6465706c6f7965640000000000000000000000"), context)?, context)?;
        Ok(())
    }

    pub mod helpers_5716_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn cleanup_uint160(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_address(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = cleanup_uint160(value, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_address(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_address(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_address(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_address(value, context)?;
            Ok(value)
        }

        pub fn cleanup_uint128(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_uint128(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint128(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint128(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint128(value, context)?;
            Ok(value)
        }

        pub fn cleanup_uint40(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_uint40(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint40(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint40(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint40(value, context)?;
            Ok(value)
        }

        pub fn cleanup_uint64(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffffffffffffffffu128), context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_userDefinedValueType_UD2x18(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint64(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_userDefinedValueType_UD2x18(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_userDefinedValueType_UD2x18(value, context)?;
            Ok(value)
        }

        pub fn allocate_unbounded(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x41(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn round_up_to_mul_of(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
            Ok(result)
        }

        pub fn finalize_allocation(memPtr: U256, size: U256, context: &mut Context) -> YulOutput<()> {
            let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
            if or(gt(newFreePtr, U256::from(0xffffffffffffffffu128), context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            mstore(U256::from(0x40u128), newFreePtr, context)?;
            Ok(())
        }

        pub fn allocate_memory(size: U256, context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            finalize_allocation(memPtr, size, context)?;
            Ok(memPtr)
        }

        pub fn revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_struct_Segment(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x60u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_userDefinedValueType_UD2x18(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_Segment_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_array_struct_Segment_dyn(offset: U256, length: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_Segment_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x60u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_Segment(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x60u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_array_struct_Segment_dyn(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_array_struct_Segment_dyn(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn array_allocation_size_string(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = round_up_to_mul_of(length, context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn copy_calldata_to_memory_with_cleanup(src: U256, dst: U256, length: U256, context: &mut Context) -> YulOutput<()> {
            calldatacopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_string(src: U256, length: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_string(length, context)?, context)?;
            mstore(array, length, context)?;
            if gt(add(src, length, context)?, end_, context)? != U256::ZERO {
                revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(context)?;
            }
            copy_calldata_to_memory_with_cleanup(src, add(array, U256::from(0x20u128), context)?, length, context)?;
            Ok(array)
        }

        pub fn abi_decode_string(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_string(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_struct_Timestamps(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn cleanup_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn validator_revert_userDefinedValueType_UD60x18(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_userDefinedValueType_UD60x18(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_userDefinedValueType_UD60x18(value, context)?;
            Ok(value)
        }

        pub fn revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_addresst_struct_Timestampst_uint128t_array_struct_Segment_dynt_uint256t_userDefinedValueType_UD60x18t_stringt_userDefinedValueType_UD60x18(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256, U256, U256, U256, U256, U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            let mut value5 = U256::ZERO;
            let mut value6 = U256::ZERO;
            let mut value7 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x120u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_struct_Timestamps(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint128(add(headStart, U256::from(0x60u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x80u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value3 = abi_decode_array_struct_Segment_dyn(add(headStart, offset, context)?, dataEnd, context)?;
            value4 = abi_decode_uint256(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value5 = abi_decode_userDefinedValueType_UD60x18(add(headStart, U256::from(0xc0u128), context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0xe0u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value6 = abi_decode_string(add(headStart, offset_1, context)?, dataEnd, context)?;
            value7 = abi_decode_userDefinedValueType_UD60x18(add(headStart, U256::from(0x100u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4, value5, value6, value7))
        }

        pub fn abi_decode_struct_Tranche(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_Tranche_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_Tranche_dyn(offset: U256, length: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_Tranche_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x40u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_Tranche(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x40u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn abi_decode_array_struct_Tranche_dyn(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_array_struct_Tranche_dyn(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_addresst_struct_Timestampst_uint128t_array_struct_Tranche_dynt_uint256t_userDefinedValueType_UD60x18t_stringt_userDefinedValueType_UD60x18(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256, U256, U256, U256, U256, U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            let mut value5 = U256::ZERO;
            let mut value6 = U256::ZERO;
            let mut value7 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x120u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_struct_Timestamps(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint128(add(headStart, U256::from(0x60u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x80u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value3 = abi_decode_array_struct_Tranche_dyn(add(headStart, offset, context)?, dataEnd, context)?;
            value4 = abi_decode_uint256(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value5 = abi_decode_userDefinedValueType_UD60x18(add(headStart, U256::from(0xc0u128), context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0xe0u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value6 = abi_decode_string(add(headStart, offset_1, context)?, dataEnd, context)?;
            value7 = abi_decode_userDefinedValueType_UD60x18(add(headStart, U256::from(0x100u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4, value5, value6, value7))
        }

        pub fn abi_decode_struct_UnlockAmounts(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_struct_Timestampst_uint40t_uint128t_struct_UnlockAmountst_userDefinedValueType_UD60x18t_stringt_userDefinedValueType_UD60x18(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256, U256, U256, U256, U256, U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            let mut value3 = U256::ZERO;
            let mut value4 = U256::ZERO;
            let mut value5 = U256::ZERO;
            let mut value6 = U256::ZERO;
            let mut value7 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x140u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_struct_Timestamps(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint40(add(headStart, U256::from(0x60u128), context)?, dataEnd, context)?;
            value3 = abi_decode_uint128(add(headStart, U256::from(0x80u128), context)?, dataEnd, context)?;
            value4 = abi_decode_struct_UnlockAmounts(add(headStart, U256::from(0xa0u128), context)?, dataEnd, context)?;
            value5 = abi_decode_userDefinedValueType_UD60x18(add(headStart, U256::from(0xe0u128), context)?, dataEnd, context)?;
            let offset = calldataload(add(headStart, U256::from(0x100u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value6 = abi_decode_string(add(headStart, offset, context)?, dataEnd, context)?;
            value7 = abi_decode_userDefinedValueType_UD60x18(add(headStart, U256::from(0x120u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2, value3, value4, value5, value6, value7))
        }

        pub fn abi_decode_struct_SegmentWithDuration(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x60u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_userDefinedValueType_UD2x18(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x40u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x40u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_SegmentWithDuration_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_SegmentWithDuration_dyn(offset: U256, length: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_SegmentWithDuration_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x60u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_SegmentWithDuration(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x60u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn abi_decode_array_struct_SegmentWithDuration_dyn(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_array_struct_SegmentWithDuration_dyn(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_array_struct_SegmentWithDuration_dynt_uint40(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_array_struct_SegmentWithDuration_dyn(add(headStart, offset, context)?, dataEnd, context)?;
            value1 = abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_struct_TrancheWithDuration(headStart: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            if slt(sub(end_, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_3538a459e4a0eb828f1aed5ebe5dc96fe59620a31d9b33e41259bb820cae769f(context)?;
            }
            value = allocate_memory(U256::from(0x40u128), context)?;
            mstore(add(value, U256::from(0x0u128), context)?, abi_decode_uint128(add(headStart, U256::from(0x0u128), context)?, end_, context)?, context)?;
            mstore(add(value, U256::from(0x20u128), context)?, abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, end_, context)?, context)?;
            Ok(value)
        }

        pub fn array_allocation_size_array_struct_TrancheWithDuration_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn abi_decode_available_length_array_struct_TrancheWithDuration_dyn(offset: U256, length: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_array_struct_TrancheWithDuration_dyn(length, context)?, context)?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x40u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(context)?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_struct_TrancheWithDuration(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x40u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn abi_decode_array_struct_TrancheWithDuration_dyn(offset: U256, end_: U256, context: &mut Context) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
            }
            array = abi_decode_available_length_array_struct_TrancheWithDuration_dyn(add(offset, U256::from(0x20u128), context)?, calldataload(offset, context)?, end_, context)?;
            Ok(array)
        }

        pub fn abi_decode_array_struct_TrancheWithDuration_dynt_uint40(headStart: U256, dataEnd: U256, context: &mut Context) -> YulOutput<(U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
            }
            value0 = abi_decode_array_struct_TrancheWithDuration_dyn(add(headStart, offset, context)?, dataEnd, context)?;
            value1 = abi_decode_uint40(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_encode_uint128_to_uint128_library(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint40(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, cleanup_uint40(value, context)?, context)?;
            Ok(())
        }

        pub fn identity(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_uint64_to_uint64(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint64(identity(cleanup_uint64(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_userDefinedValueType_UD2x18(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, convert_uint64_to_uint64(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_Segment(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128_to_uint128_library(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_userDefinedValueType_UD2x18(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            let memberValue0_2 = mload(add(value, U256::from(0x40u128), context)?, context)?;
            abi_encode_uint40(memberValue0_2, add(pos, U256::from(0x40u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encodeUpdatedPos_struct_Segment(value0: U256, pos: U256, context: &mut Context) -> YulOutput<U256> {
            let mut updatedPos = U256::ZERO;
            abi_encode_struct_Segment(value0, pos, context)?;
            updatedPos = add(pos, U256::from(0x60u128), context)?;
            Ok(updatedPos)
        }

        pub fn abi_encode_struct_Tranche(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128_to_uint128_library(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint40(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encodeUpdatedPos_struct_Tranche(value0: U256, pos: U256, context: &mut Context) -> YulOutput<U256> {
            let mut updatedPos = U256::ZERO;
            abi_encode_struct_Tranche(value0, pos, context)?;
            updatedPos = add(pos, U256::from(0x40u128), context)?;
            Ok(updatedPos)
        }

        pub fn array_dataslot_array_struct_Segment_dyn(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_struct_Segment_dyn(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_nextElement_array_struct_Segment_dyn(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut next = U256::ZERO;
            next = add(ptr, U256::from(0x20u128), context)?;
            Ok(next)
        }

        pub fn array_storeLengthForEncoding_array_struct_Segment_dyn_library(pos: U256, length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_array_struct_Segment_dyn(value: U256, mut pos: U256, context: &mut Context) -> YulOutput<U256> {
            let mut end_ = U256::ZERO;
            let length = array_length_array_struct_Segment_dyn(value, context)?;
            pos = array_storeLengthForEncoding_array_struct_Segment_dyn_library(pos, length, context)?;
            let baseRef = array_dataslot_array_struct_Segment_dyn(value, context)?;
            let mut srcPtr = baseRef;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    let elementValue0 = mload(srcPtr, context)?;
                    pos = abi_encodeUpdatedPos_struct_Segment(elementValue0, pos, context)?;
                    srcPtr = array_nextElement_array_struct_Segment_dyn(srcPtr, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            end_ = pos;
            Ok(end_)
        }

        pub fn abi_encode_array_struct_Segment_memory_ptr_dyn_memory_ptr(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_struct_Segment_dyn(value0, tail, context)?;
            Ok(tail)
        }

        pub fn array_dataslot_array_struct_Tranche_dyn(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut data = U256::ZERO;
            data = ptr;
            data = add(ptr, U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_length_array_struct_Tranche_dyn(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_nextElement_array_struct_Tranche_dyn(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut next = U256::ZERO;
            next = add(ptr, U256::from(0x20u128), context)?;
            Ok(next)
        }

        pub fn array_storeLengthForEncoding_array_struct_Tranche_dyn_library(pos: U256, length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn abi_encode_array_struct_Tranche_dyn(value: U256, mut pos: U256, context: &mut Context) -> YulOutput<U256> {
            let mut end_ = U256::ZERO;
            let length = array_length_array_struct_Tranche_dyn(value, context)?;
            pos = array_storeLengthForEncoding_array_struct_Tranche_dyn_library(pos, length, context)?;
            let baseRef = array_dataslot_array_struct_Tranche_dyn(value, context)?;
            let mut srcPtr = baseRef;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, length, context)? != U256::ZERO {
                // body
                {
                    let elementValue0 = mload(srcPtr, context)?;
                    pos = abi_encodeUpdatedPos_struct_Tranche(elementValue0, pos, context)?;
                    srcPtr = array_nextElement_array_struct_Tranche_dyn(srcPtr, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x1u128), context)?;
                }
            }
            end_ = pos;
            Ok(end_)
        }

        pub fn abi_encode_array_struct_Tranche_memory_ptr_dyn_memory_ptr(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_array_struct_Tranche_dyn(value0, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_struct_CreateAmounts(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            let memberValue0 = mload(add(value, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128_to_uint128_library(memberValue0, add(pos, U256::from(0x0u128), context)?, context)?;
            let memberValue0_1 = mload(add(value, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128_to_uint128_library(memberValue0_1, add(pos, U256::from(0x20u128), context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_struct_CreateAmounts_memory_ptr(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_struct_CreateAmounts(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple(headStart: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x0u128), context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_tuple_uint128(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn convert_uint256_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn abi_encode_userDefinedValueType_UD60x18(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, convert_uint256_to_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_tuple_userDefinedValueType_UD60x18(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_userDefinedValueType_UD60x18(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128_uint128(headStart: U256, value0: U256, value1: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint128_uint128_uint128(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint128(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint128(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint128(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_to_uint256(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256(headStart: U256, value0: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256_uint256(headStart: U256, value0: U256, value1: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint40_to_uint40(value: U256, pos: U256, context: &mut Context) -> YulOutput<()> {
            mstore(pos, cleanup_uint40(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256_uint40_uint40(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint40_to_uint40(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint40_to_uint40(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint40_uint40(headStart: U256, value0: U256, value1: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_uint40_to_uint40(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint40_to_uint40(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_userDefinedValueType_UD60x18_userDefinedValueType_UD60x18(headStart: U256, value0: U256, value1: U256, context: &mut Context) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x40u128), context)?;
            abi_encode_userDefinedValueType_UD60x18(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_userDefinedValueType_UD60x18(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            Ok(tail)
        }

        pub fn allocate_memory_array_array_struct_Segment_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_array_struct_Segment_dyn(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Segment(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x60u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_uint128(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_uint40(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn zero_value_for_userDefinedValueType_UD2x18(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn allocate_and_zero_memory_struct_struct_Segment(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_Segment(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint128(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_userDefinedValueType_UD2x18(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint40(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_struct_Segment(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_Segment(context)?;
            Ok(ret)
        }

        pub fn zero_complex_memory_array_array_struct_Segment_dyn(dataStart: U256, dataSizeInBytes: U256, context: &mut Context) -> YulOutput<()> {
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, dataSizeInBytes, context)? != U256::ZERO {
                // body
                {
                    mstore(add(dataStart, i, context)?, zero_value_for_struct_Segment(context)?, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x20u128), context)?;
                }
            }
            Ok(())
        }

        pub fn allocate_and_zero_memory_array_array_struct_Segment_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_array_struct_Segment_dyn(length, context)?;
            let mut dataStart = memPtr;
            let mut dataSize = array_allocation_size_array_struct_Segment_dyn(length, context)?;
            dataStart = add(memPtr, U256::from(0x20u128), context)?;
            dataSize = sub(dataSize, U256::from(0x20u128), context)?;
            zero_complex_memory_array_array_struct_Segment_dyn(dataStart, dataSize, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_array_array_struct_Tranche_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_array_struct_Tranche_dyn(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Tranche(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_and_zero_memory_struct_struct_Tranche(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_Tranche(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint128(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint40(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn zero_value_for_struct_Tranche(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_Tranche(context)?;
            Ok(ret)
        }

        pub fn zero_complex_memory_array_array_struct_Tranche_dyn(dataStart: U256, dataSizeInBytes: U256, context: &mut Context) -> YulOutput<()> {
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, dataSizeInBytes, context)? != U256::ZERO {
                // body
                {
                    mstore(add(dataStart, i, context)?, zero_value_for_struct_Tranche(context)?, context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x20u128), context)?;
                }
            }
            Ok(())
        }

        pub fn allocate_and_zero_memory_array_array_struct_Tranche_dyn(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_array_struct_Tranche_dyn(length, context)?;
            let mut dataStart = memPtr;
            let mut dataSize = array_allocation_size_array_struct_Tranche_dyn(length, context)?;
            dataStart = add(memPtr, U256::from(0x20u128), context)?;
            dataSize = sub(dataSize, U256::from(0x20u128), context)?;
            zero_complex_memory_array_array_struct_Tranche_dyn(dataStart, dataSize, context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_CreateAmounts(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_and_zero_memory_struct_struct_CreateAmounts(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_struct_struct_CreateAmounts(context)?;
            let mut offset = memPtr;
            mstore(memPtr, zero_value_for_uint128(context)?, context)?;
            offset = add(memPtr, U256::from(0x20u128), context)?;
            mstore(offset, zero_value_for_uint128(context)?, context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_CreateAmounts_storage_ptr(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Segment_storage_ptr(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x60u128), context)?;
            Ok(memPtr)
        }

        pub fn allocate_memory_struct_struct_Tranche_storage_ptr(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn array_length_array_struct_SegmentWithDuration_dyn(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_length_array_struct_TrancheWithDuration_dyn(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_length_bytes(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn panic_error_0x01(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x1u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn assert_helper(condition: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(condition, context)? != U256::ZERO {
                panic_error_0x01(context)?;
            }
            Ok(())
        }

        pub fn panic_error_0x11(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_add_uint128(mut x: U256, mut y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut sum = U256::ZERO;
            x = cleanup_uint128(x, context)?;
            y = cleanup_uint128(y, context)?;
            sum = add(x, y, context)?;
            if gt(sum, U256::from(0xffffffffffffffffffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn checked_sub_uint128(mut x: U256, mut y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut diff = U256::ZERO;
            x = cleanup_uint128(x, context)?;
            y = cleanup_uint128(y, context)?;
            diff = sub(x, y, context)?;
            if gt(diff, U256::from(0xffffffffffffffffffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(diff)
        }

        pub fn checked_sub_uint256(mut x: U256, mut y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut diff = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            diff = sub(x, y, context)?;
            if gt(diff, x, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(diff)
        }

        pub fn cleanup_rational_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by_1(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by_1(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn constant_MAX_UINT128(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let expr = U256::from(0xffffffffffffffffffffffffffffffffu128);
            ret = expr;
            Ok(ret)
        }

        pub fn convert_rational_by_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn constant_UNIT(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_by_to_uint256(U256::from(0xde0b6b3a7640000u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_array_string_to_bytes(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = value;
            Ok(converted)
        }

        pub fn convert_rational_0_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_1_by_1_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint160(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_address(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = convert_rational_by_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint128(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint40(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint40(identity(cleanup_t_rational_by_1(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint128_to_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint128(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint128(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint128(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn increment_wrapping_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = cleanup_uint256(add(value, U256::from(0x1u128), context)?, context)?;
            Ok(ret)
        }

        pub fn panic_error_0x32(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x32u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn memory_array_index_access_struct_SegmentWithDuration_dyn(baseRef: U256, index: U256, context: &mut Context) -> YulOutput<U256> {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_SegmentWithDuration_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn memory_array_index_access_struct_Segment_dyn(baseRef: U256, index: U256, context: &mut Context) -> YulOutput<U256> {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_Segment_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn read_from_memoryt_uint128(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint128(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_uint40(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint40(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn read_from_memoryt_userDefinedValueType_UD2x18(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint64(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn wrapping_add_uint40(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut sum = U256::ZERO;
            sum = cleanup_uint40(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn wrapping_sub_uint256(x: U256, y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut diff = U256::ZERO;
            diff = cleanup_uint256(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn write_to_memory_uint128(memPtr: U256, value: U256, context: &mut Context) -> YulOutput<()> {
            mstore(memPtr, cleanup_uint128(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_uint40(memPtr: U256, value: U256, context: &mut Context) -> YulOutput<()> {
            mstore(memPtr, cleanup_uint40(value, context)?, context)?;
            Ok(())
        }

        pub fn write_to_memory_userDefinedValueType_UD2x18(memPtr: U256, value: U256, context: &mut Context) -> YulOutput<()> {
            mstore(memPtr, cleanup_uint64(value, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_array_struct_Segment_dyn(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_calculateSegmentTimestamps(var_segmentsWithDuration_mpos: U256, var_startTime: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_segmentsWithTimestamps_mpos = U256::ZERO;
            let zero_array_struct_Segment_dyn_mpos = zero_value_for_split_array_struct_Segment_dyn(context)?;
            var_segmentsWithTimestamps_mpos = zero_array_struct_Segment_dyn_mpos;
            let expr = array_length_array_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, context)?;
            let expr_4864_mpos = allocate_and_zero_memory_array_array_struct_Segment_dyn(expr, context)?;
            var_segmentsWithTimestamps_mpos = expr_4864_mpos;
            let _100_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _1 = read_from_memoryt_uint128(add(_100_mpos, U256::from(0x0u128), context)?, context)?;
            let _104_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _2 = read_from_memoryt_userDefinedValueType_UD2x18(add(_104_mpos, U256::from(0x20u128), context)?, context)?;
            let _109_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _3 = read_from_memoryt_uint40(add(_109_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_1 = wrapping_add_uint40(var_startTime, _3, context)?;
            let expr_4886_mpos = allocate_memory_struct_struct_Segment_storage_ptr(context)?;
            write_to_memory_uint128(add(expr_4886_mpos, U256::from(0x0u128), context)?, _1, context)?;
            write_to_memory_userDefinedValueType_UD2x18(add(expr_4886_mpos, U256::from(0x20u128), context)?, _2, context)?;
            write_to_memory_uint40(add(expr_4886_mpos, U256::from(0x40u128), context)?, expr_1, context)?;
            mstore(memory_array_index_access_struct_Segment_dyn(expr_4864_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, expr_4886_mpos, context)?;
            pop(mload(memory_array_index_access_struct_Segment_dyn(expr_4864_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?, context)?;
            let expr_2 = U256::from(0x1u128);
            let mut var_i = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
            // for loop
            while expr_2 != U256::ZERO {
                // body
                {
                    let expr_3 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_3, context)? != U256::ZERO {
                        break;
                    }
                    let _120_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, var_i, context)?, context)?;
                    let _5 = read_from_memoryt_uint128(add(_120_mpos, U256::from(0x0u128), context)?, context)?;
                    let _125_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, var_i, context)?, context)?;
                    let _6 = read_from_memoryt_userDefinedValueType_UD2x18(add(_125_mpos, U256::from(0x20u128), context)?, context)?;
                    let expr_4 = wrapping_sub_uint256(var_i, convert_rational_1_by_1_to_uint256(expr_2, context)?, context)?;
                    let _130_mpos = mload(memory_array_index_access_struct_Segment_dyn(expr_4864_mpos, expr_4, context)?, context)?;
                    let _7 = read_from_memoryt_uint40(add(_130_mpos, U256::from(0x40u128), context)?, context)?;
                    let _135_mpos = mload(memory_array_index_access_struct_SegmentWithDuration_dyn(var_segmentsWithDuration_mpos, var_i, context)?, context)?;
                    let _8 = read_from_memoryt_uint40(add(_135_mpos, U256::from(0x40u128), context)?, context)?;
                    let expr_5 = wrapping_add_uint40(_7, _8, context)?;
                    let expr_mpos = allocate_memory_struct_struct_Segment_storage_ptr(context)?;
                    write_to_memory_uint128(add(expr_mpos, U256::from(0x0u128), context)?, _5, context)?;
                    write_to_memory_userDefinedValueType_UD2x18(add(expr_mpos, U256::from(0x20u128), context)?, _6, context)?;
                    write_to_memory_uint40(add(expr_mpos, U256::from(0x40u128), context)?, expr_5, context)?;
                    mstore(memory_array_index_access_struct_Segment_dyn(expr_4864_mpos, var_i, context)?, expr_mpos, context)?;
                    pop(mload(memory_array_index_access_struct_Segment_dyn(expr_4864_mpos, var_i, context)?, context)?, context)?;
                }
                // post
                {
                    let _4 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _4;
                }
            }
            Ok(var_segmentsWithTimestamps_mpos)
        }

        pub fn external_fun_calculateSegmentTimestamps(context: &mut Context) -> YulOutput<()> {
            let (param, param_1) = abi_decode_array_struct_SegmentWithDuration_dynt_uint40(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_calculateSegmentTimestamps(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_array_struct_Segment_memory_ptr_dyn_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn memory_array_index_access_struct_TrancheWithDuration_dyn(baseRef: U256, index: U256, context: &mut Context) -> YulOutput<U256> {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_TrancheWithDuration_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn memory_array_index_access_struct_Tranche_dyn(baseRef: U256, index: U256, context: &mut Context) -> YulOutput<U256> {
            let mut addr = U256::ZERO;
            if iszero(lt(index, array_length_array_struct_Tranche_dyn(baseRef, context)?, context)?, context)? != U256::ZERO {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn zero_value_for_split_array_struct_Tranche_dyn(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_calculateTrancheTimestamps(var_tranchesWithDuration_mpos: U256, var_startTime: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_tranchesWithTimestamps_mpos = U256::ZERO;
            let zero_array_struct_Tranche_dyn_mpos = zero_value_for_split_array_struct_Tranche_dyn(context)?;
            var_tranchesWithTimestamps_mpos = zero_array_struct_Tranche_dyn_mpos;
            let expr = array_length_array_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, context)?;
            let expr_4955_mpos = allocate_and_zero_memory_array_array_struct_Tranche_dyn(expr, context)?;
            var_tranchesWithTimestamps_mpos = expr_4955_mpos;
            let _6_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _1 = read_from_memoryt_uint128(add(_6_mpos, U256::from(0x0u128), context)?, context)?;
            let _11_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _2 = read_from_memoryt_uint40(add(_11_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_1 = wrapping_add_uint40(var_startTime, _2, context)?;
            let expr_4973_mpos = allocate_memory_struct_struct_Tranche_storage_ptr(context)?;
            write_to_memory_uint128(add(expr_4973_mpos, U256::from(0x0u128), context)?, _1, context)?;
            write_to_memory_uint40(add(expr_4973_mpos, U256::from(0x20u128), context)?, expr_1, context)?;
            mstore(memory_array_index_access_struct_Tranche_dyn(expr_4955_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, expr_4973_mpos, context)?;
            pop(mload(memory_array_index_access_struct_Tranche_dyn(expr_4955_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?, context)?;
            let expr_2 = U256::from(0x1u128);
            let mut var_i = convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?;
            // for loop
            while expr_2 != U256::ZERO {
                // body
                {
                    let expr_3 = lt(cleanup_uint256(var_i, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_3, context)? != U256::ZERO {
                        break;
                    }
                    let _22_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, var_i, context)?, context)?;
                    let _4 = read_from_memoryt_uint128(add(_22_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_4 = wrapping_sub_uint256(var_i, convert_rational_1_by_1_to_uint256(expr_2, context)?, context)?;
                    let _27_mpos = mload(memory_array_index_access_struct_Tranche_dyn(expr_4955_mpos, expr_4, context)?, context)?;
                    let _5 = read_from_memoryt_uint40(add(_27_mpos, U256::from(0x20u128), context)?, context)?;
                    let _32_mpos = mload(memory_array_index_access_struct_TrancheWithDuration_dyn(var_tranchesWithDuration_mpos, var_i, context)?, context)?;
                    let _6 = read_from_memoryt_uint40(add(_32_mpos, U256::from(0x20u128), context)?, context)?;
                    let expr_5 = wrapping_add_uint40(_5, _6, context)?;
                    let expr_5006_mpos = allocate_memory_struct_struct_Tranche_storage_ptr(context)?;
                    write_to_memory_uint128(add(expr_5006_mpos, U256::from(0x0u128), context)?, _4, context)?;
                    write_to_memory_uint40(add(expr_5006_mpos, U256::from(0x20u128), context)?, expr_5, context)?;
                    mstore(memory_array_index_access_struct_Tranche_dyn(expr_4955_mpos, var_i, context)?, expr_5006_mpos, context)?;
                    pop(mload(memory_array_index_access_struct_Tranche_dyn(expr_4955_mpos, var_i, context)?, context)?, context)?;
                }
                // post
                {
                    let _3 = increment_wrapping_uint256(var_i, context)?;
                    var_i = _3;
                }
            }
            Ok(var_tranchesWithTimestamps_mpos)
        }

        pub fn external_fun_calculateTrancheTimestamps(context: &mut Context) -> YulOutput<()> {
            let (param, param_1) = abi_decode_array_struct_TrancheWithDuration_dynt_uint40(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_calculateTrancheTimestamps(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_array_struct_Tranche_memory_ptr_dyn_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_uint256(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_unwrap(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn zero_value_for_split_bool(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_gt(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var_result = zero_bool;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = fun_unwrap(var_y, context)?;
            let expr_2 = gt(cleanup_uint256(expr, context)?, cleanup_uint256(expr_1, context)?, context)?;
            var_result = expr_2;
            Ok(var_result)
        }

        pub fn zero_value_for_split_uint128(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_intoUint128(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_result = zero_uint128;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            let expr_1 = constant_MAX_UINT128(context)?;
            let expr_2 = gt(cleanup_uint256(expr, context)?, convert_uint128_to_uint256(expr_1, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x248b56e7u128), context)?, context)?;
                let _1 = abi_encode_tuple_userDefinedValueType_UD60x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_3 = convert_uint256_to_uint128(expr, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_isZero(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_t_bool = zero_value_for_split_bool(context)?;
            var_result = zero_t_bool;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            var_result = expr_1;
            Ok(var_result)
        }

        pub fn panic_error_0x12(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x12u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn wrapping_div_uint256(mut x: U256, mut y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut r = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            if iszero(y, context)? != U256::ZERO {
                panic_error_0x12(context)?;
            }
            r = div(x, y, context)?;
            Ok(r)
        }

        pub fn fun_mulDiv18(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_result = zero_uint256;
            let mut var_prod0 = U256::ZERO;
            var_prod0 = zero_uint256;
            let mut var_prod1 = U256::ZERO;
            var_prod1 = zero_uint256;
            let mm = mulmod(var_x, var_y, not(U256::from(0x0u128), context)?, context)?;
            var_prod0 = mul(var_x, var_y, context)?;
            var_prod1 = sub(sub(mm, var_prod0, context)?, lt(mm, var_prod0, context)?, context)?;
            let expr = eq(cleanup_uint256(var_prod1, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                let expr_1 = constant_UNIT(context)?;
                let expr_2 = wrapping_div_uint256(var_prod0, expr_1, context)?;
                var_result = expr_2;
                return Ok(var_result);
            }
            let expr_3 = constant_UNIT(context)?;
            let expr_4 = iszero(lt(cleanup_uint256(var_prod1, context)?, cleanup_uint256(expr_3, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5173648du128), context)?, context)?;
                let _1 = abi_encode_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_x, var_y, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_remainder = U256::ZERO;
            var_remainder = zero_uint256;
            var_remainder = mulmod(var_x, var_y, U256::from(0xde0b6b3a7640000u128), context)?;
            var_result = mul(or(div(sub(var_prod0, var_remainder, context)?, U256::from(0x40000u128), context)?, mul(sub(var_prod1, gt(var_remainder, var_prod0, context)?, context)?, add(div(sub(U256::from(0x0u128), U256::from(0x40000u128), context)?, U256::from(0x40000u128), context)?, U256::from(0x1u128), context)?, context)?, context)?, U256::from_be_slice(&[0xac, 0xcb, 0x18, 0x16, 0x5b, 0xd6, 0xfe, 0x31, 0xae, 0x1c, 0xf3, 0x18, 0xdc, 0x5b, 0x51, 0xee, 0xe0, 0xe1, 0xba, 0x56, 0x9b, 0x88, 0xcd, 0x74, 0xc1, 0x77, 0x3b, 0x91, 0xfa, 0xc1, 0x06, 0x69]), context)?;
            Ok(var_result)
        }

        pub fn zero_value_for_split_userDefinedValueType_UD60x18(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_wrap(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn fun_mul(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_t_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_t_userDefinedValueType_UD60x18;
            let expr = fun_unwrap(var_x, context)?;
            let expr_1 = fun_unwrap(var_y, context)?;
            let expr_2 = fun_mulDiv18(expr, expr_1, context)?;
            let expr_3 = fun_wrap(expr_2, context)?;
            var_result = expr_3;
            Ok(var_result)
        }

        pub fn fun_ud(var_x: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_result = U256::ZERO;
            let zero_userDefinedValueType_UD60x18 = zero_value_for_split_userDefinedValueType_UD60x18(context)?;
            var_result = zero_userDefinedValueType_UD60x18;
            let expr = convert_uint256_to_uint256(var_x, context)?;
            var_result = expr;
            Ok(var_result)
        }

        pub fn zero_value_for_split_struct_CreateAmounts(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = allocate_and_zero_memory_struct_struct_CreateAmounts(context)?;
            Ok(ret)
        }

        pub fn fun_checkAndCalculateBrokerFee(var_totalAmount: U256, var_brokerFee: U256, var_maxBrokerFee: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_amounts_mpos = U256::ZERO;
            let zero_t_struct_CreateAmounts_memory_ptr_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_amounts_mpos = zero_t_struct_CreateAmounts_memory_ptr_mpos;
            let expr = eq(cleanup_uint128(var_totalAmount, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr != U256::ZERO {
                let expr_5196_mpos = allocate_memory_struct_struct_CreateAmounts_storage_ptr(context)?;
                let _1 = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                write_to_memory_uint128(add(expr_5196_mpos, U256::from(0x0u128), context)?, _1, context)?;
                write_to_memory_uint128(add(expr_5196_mpos, U256::from(0x20u128), context)?, _1, context)?;
                var_amounts_mpos = expr_5196_mpos;
                return Ok(var_amounts_mpos);
            }
            let expr_1 = fun_isZero(var_brokerFee, context)?;
            if expr_1 != U256::ZERO {
                let expr_5207_mpos = allocate_memory_struct_struct_CreateAmounts_storage_ptr(context)?;
                write_to_memory_uint128(add(expr_5207_mpos, U256::from(0x0u128), context)?, var_totalAmount, context)?;
                let _2 = convert_rational_by_to_uint128(U256::from(0x0u128), context)?;
                write_to_memory_uint128(add(expr_5207_mpos, U256::from(0x20u128), context)?, _2, context)?;
                var_amounts_mpos = expr_5207_mpos;
                return Ok(var_amounts_mpos);
            }
            let expr_2 = fun_gt(var_brokerFee, var_maxBrokerFee, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4816cae3u128), context)?, context)?;
                let _3 = abi_encode_userDefinedValueType_UD60x18_userDefinedValueType_UD60x18(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_brokerFee, var_maxBrokerFee, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let _4 = convert_uint128_to_uint256(var_totalAmount, context)?;
            let expr_3 = fun_ud(_4, context)?;
            let expr_4 = fun_mul(expr_3, var_brokerFee, context)?;
            let expr_5 = fun_intoUint128(expr_4, context)?;
            let _5 = add(var_amounts_mpos, U256::from(0x20u128), context)?;
            write_to_memory_uint128(_5, expr_5, context)?;
            let _6 = read_from_memoryt_uint128(_5, context)?;
            let expr_6 = gt(cleanup_uint128(var_totalAmount, context)?, cleanup_uint128(_6, context)?, context)?;
            assert_helper(expr_6, context)?;
            let _7 = read_from_memoryt_uint128(_5, context)?;
            let expr_7 = checked_sub_uint128(var_totalAmount, _7, context)?;
            write_to_memory_uint128(add(var_amounts_mpos, U256::from(0x0u128), context)?, expr_7, context)?;
            Ok(var_amounts_mpos)
        }

        pub fn fun_checkCreateStream(var_sender: U256, var_depositAmount: U256, var_startTime: U256, var_shape_5359_mpos: U256, context: &mut Context) -> YulOutput<()> {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_sender, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xfeb974b3u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = eq(cleanup_uint128(var_depositAmount, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x59d19765u128), context)?, context)?;
                let _2 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let expr_3 = eq(cleanup_uint40(var_startTime, context)?, convert_rational_by_to_uint40(U256::from(0x0u128), context)?, context)?;
            if expr_3 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe7u128), U256::from(0xfcdef5u128), context)?, context)?;
                let _3 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
            }
            let expr_5398_mpos = convert_array_string_to_bytes(var_shape_5359_mpos, context)?;
            let expr_4 = array_length_bytes(expr_5398_mpos, context)?;
            let expr_5 = gt(cleanup_uint256(expr_4, context)?, convert_t_rational_by_to_t_uint256(U256::from(0x20u128), context)?, context)?;
            if expr_5 != U256::ZERO {
                let expr_6 = array_length_bytes(expr_5398_mpos, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x1f68a771u128), context)?, context)?;
                let _4 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr_6, context)?;
                revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn zero_value_for_split_uint40(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_checkSegments(var_segments_mpos: U256, var_depositAmount: U256, var_timestamps_5425_mpos: U256, var_maxSegmentCount: U256, context: &mut Context) -> YulOutput<()> {
            let expr = array_length_array_struct_Segment_dyn(var_segments_mpos, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0xc8936c1u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = gt(cleanup_uint256(expr, context)?, cleanup_uint256(var_maxSegmentCount, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x1b87f59bu128), context)?, context)?;
                let _2 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let _3 = add(var_timestamps_5425_mpos, U256::from(0x0u128), context)?;
            let _4 = read_from_memoryt_uint40(_3, context)?;
            let _331_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _5 = read_from_memoryt_uint40(add(_331_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_3 = iszero(lt(cleanup_uint40(_4, context)?, cleanup_uint40(_5, context)?, context)?, context)?;
            if expr_3 != U256::ZERO {
                let _6 = read_from_memoryt_uint40(_3, context)?;
                let _338_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
                let _7 = read_from_memoryt_uint40(add(_338_mpos, U256::from(0x40u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe4u128), U256::from(0xf500ccbu128), context)?, context)?;
                let _8 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _6, _7, context)?;
                revert(U256::from(0x0u128), sub(_8, U256::from(0x0u128), context)?, context)?;
            }
            let _9 = add(var_timestamps_5425_mpos, U256::from(0x20u128), context)?;
            let _10 = read_from_memoryt_uint40(_9, context)?;
            let expr_4 = U256::from(0x1u128);
            let expr_5 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let _348_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, expr_5, context)?, context)?;
            let _11 = read_from_memoryt_uint40(add(_348_mpos, U256::from(0x40u128), context)?, context)?;
            let expr_6 = iszero(eq(cleanup_uint40(_10, context)?, cleanup_uint40(_11, context)?, context)?, context)?;
            if expr_6 != U256::ZERO {
                let _12 = read_from_memoryt_uint40(_9, context)?;
                let expr_7 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let _356_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, expr_7, context)?, context)?;
                let _13 = read_from_memoryt_uint40(add(_356_mpos, U256::from(0x40u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x474537ffu128), context)?, context)?;
                let _14 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _12, _13, context)?;
                revert(U256::from(0x0u128), sub(_14, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_segmentAmountsSum = U256::ZERO;
            let zero_t_uint128 = zero_value_for_split_uint128(context)?;
            var_segmentAmountsSum = zero_t_uint128;
            let mut var_currentSegmentTimestamp = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_currentSegmentTimestamp = zero_uint40;
            let mut var_previousSegmentTimestamp = U256::ZERO;
            var_previousSegmentTimestamp = zero_uint40;
            let mut var_index = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while expr_4 != U256::ZERO {
                // body
                {
                    let expr_8 = lt(cleanup_uint256(var_index, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_8, context)? != U256::ZERO {
                        break;
                    }
                    let _mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, var_index, context)?, context)?;
                    let _16 = read_from_memoryt_uint128(add(_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_9 = checked_add_uint128(var_segmentAmountsSum, _16, context)?;
                    var_segmentAmountsSum = expr_9;
                    let _376_mpos = mload(memory_array_index_access_struct_Segment_dyn(var_segments_mpos, var_index, context)?, context)?;
                    let _17 = read_from_memoryt_uint40(add(_376_mpos, U256::from(0x40u128), context)?, context)?;
                    var_currentSegmentTimestamp = _17;
                    let expr_10 = iszero(gt(cleanup_uint40(_17, context)?, cleanup_uint40(var_previousSegmentTimestamp, context)?, context)?, context)?;
                    if expr_10 != U256::ZERO {
                        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x7d6d1f33u128), context)?, context)?;
                        let _18 = abi_encode_uint256_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_index, var_previousSegmentTimestamp, _17, context)?;
                        revert(U256::from(0x0u128), sub(_18, U256::from(0x0u128), context)?, context)?;
                    }
                    var_previousSegmentTimestamp = _17;
                }
                // post
                {
                    let _15 = increment_wrapping_uint256(var_index, context)?;
                    var_index = _15;
                }
            }
            let expr_11 = iszero(eq(cleanup_uint128(var_depositAmount, context)?, cleanup_uint128(var_segmentAmountsSum, context)?, context)?, context)?;
            if expr_11 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4b52f2ffu128), context)?, context)?;
                let _19 = abi_encode_uint128_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_depositAmount, var_segmentAmountsSum, context)?;
                revert(U256::from(0x0u128), sub(_19, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_checkCreateLockupDynamic(var_sender: U256, var_timestamps_5019_mpos: U256, var_totalAmount: U256, var_segments_5025_mpos: U256, var_maxCount: U256, var_brokerFee: U256, var_shape_5032_mpos: U256, var_maxBrokerFee: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_createAmounts_5039_mpos = U256::ZERO;
            let zero_struct_CreateAmounts_memory_ptr_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_createAmounts_5039_mpos = zero_struct_CreateAmounts_memory_ptr_mpos;
            let expr_5046_mpos = fun_checkAndCalculateBrokerFee(var_totalAmount, var_brokerFee, var_maxBrokerFee, context)?;
            var_createAmounts_5039_mpos = expr_5046_mpos;
            let _1 = add(expr_5046_mpos, U256::from(0x0u128), context)?;
            let _2 = read_from_memoryt_uint128(_1, context)?;
            let _3 = read_from_memoryt_uint40(add(var_timestamps_5019_mpos, U256::from(0x0u128), context)?, context)?;
            fun_checkCreateStream(var_sender, _2, _3, var_shape_5032_mpos, context)?;
            let _4 = read_from_memoryt_uint128(_1, context)?;
            fun_checkSegments(var_segments_5025_mpos, _4, var_timestamps_5019_mpos, var_maxCount, context)?;
            Ok(var_createAmounts_5039_mpos)
        }

        pub fn external_fun_checkCreateLockupDynamic(context: &mut Context) -> YulOutput<()> {
            let (param, param_1, param_2, param_3, param_4, param_5, param_6, param_7) = abi_decode_addresst_struct_Timestampst_uint128t_array_struct_Segment_dynt_uint256t_userDefinedValueType_UD60x18t_stringt_userDefinedValueType_UD60x18(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_checkCreateLockupDynamic(param, param_1, param_2, param_3, param_4, param_5, param_6, param_7, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_struct_CreateAmounts_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_checkTimestampsAndUnlockAmounts(var_depositAmount: U256, var_timestamps_5260_mpos: U256, var_cliffTime: U256, var_unlockAmounts_mpos: U256, context: &mut Context) -> YulOutput<()> {
            let expr = gt(cleanup_uint40(var_cliffTime, context)?, convert_rational_by_to_uint40(U256::from(0x0u128), context)?, context)?;
            // switch
            let  = expr;
            if  == U256::from(0x0u128) {
                let _1 = add(var_unlockAmounts_mpos, U256::from(0x20u128), context)?;
                let _2 = read_from_memoryt_uint128(_1, context)?;
                let expr_1 = gt(cleanup_uint128(_2, context)?, convert_rational_by_to_uint128(U256::from(0x0u128), context)?, context)?;
                if expr_1 != U256::ZERO {
                    let _3 = read_from_memoryt_uint128(_1, context)?;
                    mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x150ee1a5u128), context)?, context)?;
                    let _4 = abi_encode_tuple_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _3, context)?;
                    revert(U256::from(0x0u128), sub(_4, U256::from(0x0u128), context)?, context)?;
                }
            }
            let _13 = add(var_timestamps_5260_mpos, U256::from(0x0u128), context)?;
            let _14 = read_from_memoryt_uint40(_13, context)?;
            let _15 = add(var_timestamps_5260_mpos, U256::from(0x20u128), context)?;
            let _16 = read_from_memoryt_uint40(_15, context)?;
            let expr_4 = iszero(lt(cleanup_uint40(_14, context)?, cleanup_uint40(_16, context)?, context)?, context)?;
            if expr_4 != U256::ZERO {
                let _17 = read_from_memoryt_uint40(_13, context)?;
                let _18 = read_from_memoryt_uint40(_15, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x5171143u128), context)?, context)?;
                let _19 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _17, _18, context)?;
                revert(U256::from(0x0u128), sub(_19, U256::from(0x0u128), context)?, context)?;
            }
            let _20 = add(var_unlockAmounts_mpos, U256::from(0x0u128), context)?;
            let _21 = read_from_memoryt_uint128(_20, context)?;
            let _22 = add(var_unlockAmounts_mpos, U256::from(0x20u128), context)?;
            let _23 = read_from_memoryt_uint128(_22, context)?;
            let expr_5 = checked_add_uint128(_21, _23, context)?;
            let expr_6 = gt(cleanup_uint128(expr_5, context)?, cleanup_uint128(var_depositAmount, context)?, context)?;
            if expr_6 != U256::ZERO {
                let _24 = read_from_memoryt_uint128(_20, context)?;
                let _25 = read_from_memoryt_uint128(_22, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xb4ba30du128), context)?, context)?;
                let _26 = abi_encode_uint128_uint128_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_depositAmount, _24, _25, context)?;
                revert(U256::from(0x0u128), sub(_26, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_checkCreateLockupLinear(var_sender: U256, var_timestamps_5073_mpos: U256, var_cliffTime: U256, var_totalAmount: U256, var_unlockAmounts_5080_mpos: U256, var_brokerFee: U256, var_shape_mpos: U256, var_maxBrokerFee: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_createAmounts_mpos = U256::ZERO;
            let zero_struct_CreateAmounts_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_createAmounts_mpos = zero_struct_CreateAmounts_mpos;
            let expr_5099_mpos = fun_checkAndCalculateBrokerFee(var_totalAmount, var_brokerFee, var_maxBrokerFee, context)?;
            var_createAmounts_mpos = expr_5099_mpos;
            let _1 = add(expr_5099_mpos, U256::from(0x0u128), context)?;
            let _2 = read_from_memoryt_uint128(_1, context)?;
            let _3 = read_from_memoryt_uint40(add(var_timestamps_5073_mpos, U256::from(0x0u128), context)?, context)?;
            fun_checkCreateStream(var_sender, _2, _3, var_shape_mpos, context)?;
            let _4 = read_from_memoryt_uint128(_1, context)?;
            fun_checkTimestampsAndUnlockAmounts(_4, var_timestamps_5073_mpos, var_cliffTime, var_unlockAmounts_5080_mpos, context)?;
            Ok(var_createAmounts_mpos)
        }

        pub fn external_fun_checkCreateLockupLinear(context: &mut Context) -> YulOutput<()> {
            let (param, param_1, param_2, param_3, param_4, param_5, param_6, param_7) = abi_decode_addresst_struct_Timestampst_uint40t_uint128t_struct_UnlockAmountst_userDefinedValueType_UD60x18t_stringt_userDefinedValueType_UD60x18(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_checkCreateLockupLinear(param, param_1, param_2, param_3, param_4, param_5, param_6, param_7, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_struct_CreateAmounts_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_checkTranches(var_tranches_5570_mpos: U256, var_depositAmount: U256, var_timestamps_5575_mpos: U256, var_maxTrancheCount: U256, context: &mut Context) -> YulOutput<()> {
            let expr = array_length_array_struct_Tranche_dyn(var_tranches_5570_mpos, context)?;
            let expr_1 = eq(cleanup_uint256(expr, context)?, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xff743f91u128), context)?, context)?;
                let _1 = abi_encode_tuple(add(U256::from(0x0u128), U256::from(0x4u128), context)?, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = gt(cleanup_uint256(expr, context)?, cleanup_uint256(var_maxTrancheCount, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe3u128), U256::from(0xc6a5a61u128), context)?, context)?;
                let _2 = abi_encode_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let _3 = add(var_timestamps_5575_mpos, U256::from(0x0u128), context)?;
            let _4 = read_from_memoryt_uint40(_3, context)?;
            let _197_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5570_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
            let _5 = read_from_memoryt_uint40(add(_197_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_3 = iszero(lt(cleanup_uint40(_4, context)?, cleanup_uint40(_5, context)?, context)?, context)?;
            if expr_3 != U256::ZERO {
                let _6 = read_from_memoryt_uint40(_3, context)?;
                let _204_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5570_mpos, convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?, context)?, context)?;
                let _7 = read_from_memoryt_uint40(add(_204_mpos, U256::from(0x20u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x2719805fu128), context)?, context)?;
                let _8 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _6, _7, context)?;
                revert(U256::from(0x0u128), sub(_8, U256::from(0x0u128), context)?, context)?;
            }
            let _9 = add(var_timestamps_5575_mpos, U256::from(0x20u128), context)?;
            let _10 = read_from_memoryt_uint40(_9, context)?;
            let expr_4 = U256::from(0x1u128);
            let expr_5 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
            let _214_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5570_mpos, expr_5, context)?, context)?;
            let _11 = read_from_memoryt_uint40(add(_214_mpos, U256::from(0x20u128), context)?, context)?;
            let expr_6 = iszero(eq(cleanup_uint40(_10, context)?, cleanup_uint40(_11, context)?, context)?, context)?;
            if expr_6 != U256::ZERO {
                let _12 = read_from_memoryt_uint40(_9, context)?;
                let expr_7 = checked_sub_uint256(expr, convert_rational_1_by_1_to_uint256(U256::from(0x1u128), context)?, context)?;
                let _222_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5570_mpos, expr_7, context)?, context)?;
                let _13 = read_from_memoryt_uint40(add(_222_mpos, U256::from(0x20u128), context)?, context)?;
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x2828b1dfu128), context)?, context)?;
                let _14 = abi_encode_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, _12, _13, context)?;
                revert(U256::from(0x0u128), sub(_14, U256::from(0x0u128), context)?, context)?;
            }
            let mut var_trancheAmountsSum = U256::ZERO;
            let zero_uint128 = zero_value_for_split_uint128(context)?;
            var_trancheAmountsSum = zero_uint128;
            let mut var_currentTrancheTimestamp = U256::ZERO;
            let zero_uint40 = zero_value_for_split_uint40(context)?;
            var_currentTrancheTimestamp = zero_uint40;
            let mut var_previousTrancheTimestamp = U256::ZERO;
            var_previousTrancheTimestamp = zero_uint40;
            let mut var_index = convert_rational_0_by_1_to_uint256(U256::from(0x0u128), context)?;
            // for loop
            while expr_4 != U256::ZERO {
                // body
                {
                    let expr_8 = lt(cleanup_uint256(var_index, context)?, cleanup_uint256(expr, context)?, context)?;
                    if iszero(expr_8, context)? != U256::ZERO {
                        break;
                    }
                    let _236_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5570_mpos, var_index, context)?, context)?;
                    let _16 = read_from_memoryt_uint128(add(_236_mpos, U256::from(0x0u128), context)?, context)?;
                    let expr_9 = checked_add_uint128(var_trancheAmountsSum, _16, context)?;
                    var_trancheAmountsSum = expr_9;
                    let _242_mpos = mload(memory_array_index_access_struct_Tranche_dyn(var_tranches_5570_mpos, var_index, context)?, context)?;
                    let _17 = read_from_memoryt_uint40(add(_242_mpos, U256::from(0x20u128), context)?, context)?;
                    var_currentTrancheTimestamp = _17;
                    let expr_10 = iszero(gt(cleanup_uint40(_17, context)?, cleanup_uint40(var_previousTrancheTimestamp, context)?, context)?, context)?;
                    if expr_10 != U256::ZERO {
                        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x73a9cd5fu128), context)?, context)?;
                        let _18 = abi_encode_uint256_uint40_uint40(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_index, var_previousTrancheTimestamp, _17, context)?;
                        revert(U256::from(0x0u128), sub(_18, U256::from(0x0u128), context)?, context)?;
                    }
                    var_previousTrancheTimestamp = _17;
                }
                // post
                {
                    let _15 = increment_wrapping_uint256(var_index, context)?;
                    var_index = _15;
                }
            }
            let expr_11 = iszero(eq(cleanup_uint128(var_depositAmount, context)?, cleanup_uint128(var_trancheAmountsSum, context)?, context)?, context)?;
            if expr_11 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x59b0e8ddu128), context)?, context)?;
                let _19 = abi_encode_uint128_uint128(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_depositAmount, var_trancheAmountsSum, context)?;
                revert(U256::from(0x0u128), sub(_19, U256::from(0x0u128), context)?, context)?;
            }
            Ok(())
        }

        pub fn fun_checkCreateLockupTranched(var_sender: U256, var_timestamps_mpos: U256, var_totalAmount: U256, var_tranches_mpos: U256, var_maxCount: U256, var_brokerFee: U256, var_shape_5139_mpos: U256, var_maxBrokerFee: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_createAmounts_5146_mpos = U256::ZERO;
            let zero_t_struct_CreateAmounts_mpos = zero_value_for_split_struct_CreateAmounts(context)?;
            var_createAmounts_5146_mpos = zero_t_struct_CreateAmounts_mpos;
            let expr_5153_mpos = fun_checkAndCalculateBrokerFee(var_totalAmount, var_brokerFee, var_maxBrokerFee, context)?;
            var_createAmounts_5146_mpos = expr_5153_mpos;
            let _1 = add(expr_5153_mpos, U256::from(0x0u128), context)?;
            let _2 = read_from_memoryt_uint128(_1, context)?;
            let _3 = read_from_memoryt_uint40(add(var_timestamps_mpos, U256::from(0x0u128), context)?, context)?;
            fun_checkCreateStream(var_sender, _2, _3, var_shape_5139_mpos, context)?;
            let _4 = read_from_memoryt_uint128(_1, context)?;
            fun_checkTranches(var_tranches_mpos, _4, var_timestamps_mpos, var_maxCount, context)?;
            Ok(var_createAmounts_5146_mpos)
        }

        pub fn external_fun_checkCreateLockupTranched(context: &mut Context) -> YulOutput<()> {
            let (param, param_1, param_2, param_3, param_4, param_5, param_6, param_7) = abi_decode_addresst_struct_Timestampst_uint128t_array_struct_Tranche_dynt_uint256t_userDefinedValueType_UD60x18t_stringt_userDefinedValueType_UD60x18(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_checkCreateLockupTranched(param, param_1, param_2, param_3, param_4, param_5, param_6, param_7, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_struct_CreateAmounts_memory_ptr(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context: &mut Context) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                // switch
                let  = selector;
                if  == U256::from(0x14412079u128) {
                    external_fun_calculateTrancheTimestamps(context)?;
                } else if  == U256::from(0x6df26955u128) {
                    external_fun_checkCreateLockupTranched(context)?;
                } else if  == U256::from(0xcec85a90u128) {
                    external_fun_checkCreateLockupLinear(context)?;
                } else if  == U256::from(0xe68812b4u128) {
                    external_fun_checkCreateLockupDynamic(context)?;
                } else if  == U256::from(0xf0b95e09u128) {
                    external_fun_calculateSegmentTimestamps(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let context = Context {
        memory: Memory::new(),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
    };
    // let result = helpers_5716::helpers_5716_deployed::fun_runTests(
    //     &mut context
    // );
    // println!("result: {:#?}", result);
    // println!("context: {:#?}", context);
}
