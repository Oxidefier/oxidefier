// Generated by Oxidefier

#![allow(non_snake_case)]
#![allow(unused_assignments)]
#![allow(mixed_script_confusables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod plonkverifier_482 {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn allocate_unbounded(context: &mut Context) -> YulOutput<U256> {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(
        context: &mut Context,
    ) -> YulOutput<()> {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body(context: &mut Context) -> YulOutput<()> {
        mstore(
            U256::from(0x40u128),
            memoryguard(U256::from(0x80u128), context)?,
            context,
        )?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let _1 = allocate_unbounded(context)?;
        codecopy(
            _1,
            dataoffset(
                from_hex("506c6f6e6b56657269666965725f3438325f6465706c6f796564000000000000"),
                context,
            )?,
            datasize(
                from_hex("506c6f6e6b56657269666965725f3438325f6465706c6f796564000000000000"),
                context,
            )?,
            context,
        )?;
        return_(
            _1,
            datasize(
                from_hex("506c6f6e6b56657269666965725f3438325f6465706c6f796564000000000000"),
                context,
            )?,
            context,
        )?;
        Ok(())
    }

    pub mod plonkverifier_482_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn cleanup_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256(value: U256, context: &mut Context) -> YulOutput<()> {
            if iszero(
                eq(value, cleanup_uint256(value, context)?, context)?,
                context,
            )? != U256::ZERO
            {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256(
            offset: U256,
            end_: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn allocate_unbounded(context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x41(context: &mut Context) -> YulOutput<()> {
            mstore(
                U256::from(0x0u128),
                shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?,
                context,
            )?;
            mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn round_up_to_mul_of(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut result = U256::ZERO;
            result = and(
                add(value, U256::from(0x1fu128), context)?,
                not(U256::from(0x1fu128), context)?,
                context,
            )?;
            Ok(result)
        }

        pub fn finalize_allocation(
            memPtr: U256,
            size: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
            if or(
                gt(newFreePtr, U256::from(0xffffffffffffffffu128), context)?,
                lt(newFreePtr, memPtr, context)?,
                context,
            )? != U256::ZERO
            {
                panic_error_0x41(context)?;
            }
            mstore(U256::from(0x40u128), newFreePtr, context)?;
            Ok(())
        }

        pub fn allocate_memory(size: U256, context: &mut Context) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            finalize_allocation(memPtr, size, context)?;
            Ok(memPtr)
        }

        pub fn array_allocation_size_array_uint256_dyn(
            length: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = mul(length, U256::from(0x20u128), context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(
            context: &mut Context,
        ) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_array_uint256_dyn(
            offset: U256,
            length: U256,
            end_: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(
                array_allocation_size_array_uint256_dyn(length, context)?,
                context,
            )?;
            let mut dst = array;
            mstore(array, length, context)?;
            dst = add(array, U256::from(0x20u128), context)?;
            let srcEnd = add(offset, mul(length, U256::from(0x20u128), context)?, context)?;
            if gt(srcEnd, end_, context)? != U256::ZERO {
                revert_error_81385d8c0b31fffe14be1da910c8bd3a80be4cfa248e04f42ec0faea3132a8ef(
                    context,
                )?;
            }
            let mut src = offset;
            // for loop
            while lt(src, srcEnd, context)? != U256::ZERO {
                // body
                {
                    mstore(dst, abi_decode_uint256(src, end_, context)?, context)?;
                    dst = add(dst, U256::from(0x20u128), context)?;
                }
                // post
                {
                    src = add(src, U256::from(0x20u128), context)?;
                }
            }
            Ok(array)
        }

        pub fn revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(
            context: &mut Context,
        ) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_array_uint256_dyn(
            offset: U256,
            end_: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(
                slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?,
                context,
            )? != U256::ZERO
            {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(
                    context,
                )?;
            }
            array = abi_decode_available_length_array_uint256_dyn(
                add(offset, U256::from(0x20u128), context)?,
                calldataload(offset, context)?,
                end_,
                context,
            )?;
            Ok(array)
        }

        pub fn array_allocation_size_bytes(length: U256, context: &mut Context) -> YulOutput<U256> {
            let mut size = U256::ZERO;
            if gt(length, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            size = round_up_to_mul_of(length, context)?;
            size = add(size, U256::from(0x20u128), context)?;
            Ok(size)
        }

        pub fn copy_calldata_to_memory_with_cleanup(
            src: U256,
            dst: U256,
            length: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            calldatacopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(
            context: &mut Context,
        ) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_available_length_bytes(
            src: U256,
            length: U256,
            end_: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            array = allocate_memory(array_allocation_size_bytes(length, context)?, context)?;
            mstore(array, length, context)?;
            if gt(add(src, length, context)?, end_, context)? != U256::ZERO {
                revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(
                    context,
                )?;
            }
            copy_calldata_to_memory_with_cleanup(
                src,
                add(array, U256::from(0x20u128), context)?,
                length,
                context,
            )?;
            Ok(array)
        }

        pub fn abi_decode_bytes(
            offset: U256,
            end_: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut array = U256::ZERO;
            if iszero(
                slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?,
                context,
            )? != U256::ZERO
            {
                revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(
                    context,
                )?;
            }
            array = abi_decode_available_length_bytes(
                add(offset, U256::from(0x20u128), context)?,
                calldataload(offset, context)?,
                end_,
                context,
            )?;
            Ok(array)
        }

        pub fn revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(
            context: &mut Context,
        ) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(
            context: &mut Context,
        ) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode_bytest_array_uint256_dyn(
            headStart: U256,
            dataEnd: U256,
            context: &mut Context,
        ) -> YulOutput<(U256, U256)> {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(
                sub(dataEnd, headStart, context)?,
                U256::from(0x40u128),
                context,
            )? != U256::ZERO
            {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(
                    context,
                )?;
            }
            let offset = calldataload(add(headStart, U256::from(0x0u128), context)?, context)?;
            if gt(offset, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(
                    context,
                )?;
            }
            value0 = abi_decode_bytes(add(headStart, offset, context)?, dataEnd, context)?;
            let offset_1 = calldataload(add(headStart, U256::from(0x20u128), context)?, context)?;
            if gt(offset_1, U256::from(0xffffffffffffffffu128), context)? != U256::ZERO {
                revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(
                    context,
                )?;
            }
            value1 =
                abi_decode_array_uint256_dyn(add(headStart, offset_1, context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn cleanup_bool(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = iszero(iszero(value, context)?, context)?;
            Ok(cleaned)
        }

        pub fn abi_encode_bool_to_bool(
            value: U256,
            pos: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            mstore(pos, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bool(
            headStart: U256,
            value0: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bool_to_bool(
                value0,
                add(headStart, U256::from(0x0u128), context)?,
                context,
            )?;
            Ok(tail)
        }

        pub fn allocate_memory_array_array_uint256_dyn(
            length: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            let allocSize = array_allocation_size_array_uint256_dyn(length, context)?;
            memPtr = allocate_memory(allocSize, context)?;
            mstore(memPtr, length, context)?;
            Ok(memPtr)
        }

        pub fn zero_memory_chunk_uint256(
            dataStart: U256,
            dataSizeInBytes: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            calldatacopy(dataStart, calldatasize(context)?, dataSizeInBytes, context)?;
            Ok(())
        }

        pub fn allocate_and_zero_memory_array_array_uint256_dyn(
            length: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_memory_array_array_uint256_dyn(length, context)?;
            let mut dataStart = memPtr;
            let mut dataSize = array_allocation_size_array_uint256_dyn(length, context)?;
            dataStart = add(memPtr, U256::from(0x20u128), context)?;
            dataSize = sub(dataSize, U256::from(0x20u128), context)?;
            zero_memory_chunk_uint256(dataStart, dataSize, context)?;
            Ok(memPtr)
        }

        pub fn array_length_array_uint256_dyn(
            value: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn panic_error_0x11(context: &mut Context) -> YulOutput<()> {
            mstore(
                U256::from(0x0u128),
                shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?,
                context,
            )?;
            mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_add_uint256(
            mut x: U256,
            mut y: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut sum = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            sum = add(x, y, context)?;
            if gt(x, sum, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn checked_mul_uint256(
            mut x: U256,
            mut y: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut product = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            product = cleanup_uint256(mul(x, y, context)?, context)?;
            if iszero(
                or(
                    iszero(x, context)?,
                    eq(y, div(product, x, context)?, context)?,
                    context,
                )?,
                context,
            )? != U256::ZERO
            {
                panic_error_0x11(context)?;
            }
            Ok(product)
        }

        pub fn cleanup_rational_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by_1(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn identity(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_rational_by_to_uint256(
            value: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(
                identity(cleanup_rational_by(value, context)?, context)?,
                context,
            )?;
            Ok(converted)
        }

        pub fn constant_vk_nb_commitments_commit_api(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            let _1 = convert_rational_by_to_uint256(U256::from(0x1u128), context)?;
            ret = _1;
            Ok(ret)
        }

        pub fn convert_rational_2_by_1_to_uint256(
            value: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(
                identity(cleanup_rational_by_1(value, context)?, context)?,
                context,
            )?;
            Ok(converted)
        }

        pub fn convert_t_rational_by_to_t_uint256(
            value: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(
                identity(cleanup_t_rational_by(value, context)?, context)?,
                context,
            )?;
            Ok(converted)
        }

        pub fn ᵤpow_local(ᵤx: U256, ᵤe: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ᵤresult = U256::ZERO;
            let ᵤmPtr = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, U256::from(0x20u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from(0x20u128),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                U256::from(0x20u128),
                context,
            )?;
            mstore(add(ᵤmPtr, U256::from(0x60u128), context)?, ᵤx, context)?;
            mstore(add(ᵤmPtr, U256::from(0x80u128), context)?, ᵤe, context)?;
            mstore(
                add(ᵤmPtr, U256::from(0xa0u128), context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x5u128),
                    ᵤmPtr,
                    U256::from(0xc0u128),
                    U256::from(0x0u128),
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            ᵤresult = mload(U256::from(0x0u128), context)?;
            Ok(ᵤresult)
        }

        pub fn zero_value_for_split_uint256(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_compute_ith_lagrange_at_z(
            mut var_zeta: U256,
            mut var_i: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let mut var_res = U256::ZERO;
            var_res = zero_uint256;
            let ᵤw = ᵤpow_local(
                U256::from_be_slice(&[
                    0x2b, 0x33, 0x7d, 0xe1, 0xc8, 0xc1, 0x4f, 0x22, 0xec, 0x9b, 0x9e, 0x2f, 0x96,
                    0xaf, 0xef, 0x36, 0x52, 0x62, 0x73, 0x66, 0xf8, 0x17, 0x0a, 0x0a, 0x94, 0x8d,
                    0xad, 0x4a, 0xc1, 0xbd, 0x5e, 0x80,
                ]),
                var_i,
                context,
            )?;
            var_i = addmod(
                var_zeta,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    ᵤw,
                    context,
                )?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var_zeta = ᵤpow_local(var_zeta, U256::from(0x8u128), context)?;
            var_zeta = addmod(
                var_zeta,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x1u128),
                    context,
                )?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤw = mulmod(
                ᵤw,
                U256::from_be_slice(&[
                    0x2a, 0x57, 0xc4, 0xa4, 0x85, 0x0b, 0x6c, 0x24, 0x81, 0x46, 0x3c, 0xff, 0xb1,
                    0x51, 0x2d, 0x51, 0x83, 0x2d, 0x6b, 0x3f, 0x6a, 0x82, 0x42, 0x7f, 0x1b, 0x65,
                    0xb6, 0xe1, 0x72, 0x00, 0x00, 0x01,
                ]),
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var_i = ᵤpow_local(
                var_i,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x2u128),
                    context,
                )?,
                context,
            )?;
            ᵤw = mulmod(
                ᵤw,
                var_i,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var_res = mulmod(
                ᵤw,
                var_zeta,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var = var_res;
            Ok(var)
        }

        pub fn ᵤerror_sha2(context: &mut Context) -> YulOutput<()> {
            let ᵤptError = mload(U256::from(0x40u128), context)?;
            mstore(
                ᵤptError,
                shl(U256::from(0xe5u128), U256::from(0x461bcdu128), context)?,
                context,
            )?;
            mstore(
                add(ᵤptError, U256::from(0x4u128), context)?,
                U256::from(0x20u128),
                context,
            )?;
            mstore(
                add(ᵤptError, U256::from(0x24u128), context)?,
                U256::from(0x19u128),
                context,
            )?;
            mstore(
                add(ᵤptError, U256::from(0x44u128), context)?,
                from_hex("6572726f722073746174696363616c6c20736861322d32353600000000000000"),
                context,
            )?;
            revert(ᵤptError, U256::from(0x64u128), context)?;
            Ok(())
        }

        pub fn fun_hash_fr(var_x: U256, var_y: U256, context: &mut Context) -> YulOutput<U256> {
            let mut var_res = U256::ZERO;
            let zero_t_uint256 = zero_value_for_split_uint256(context)?;
            var_res = zero_t_uint256;
            let ᵤmPtr = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, U256::from(0x0u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from(0x0u128),
                context,
            )?;
            mstore(add(ᵤmPtr, U256::from(0x40u128), context)?, var_x, context)?;
            mstore(add(ᵤmPtr, U256::from(0x60u128), context)?, var_y, context)?;
            mstore8(
                add(ᵤmPtr, U256::from(0x80u128), context)?,
                U256::from(0x0u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x81u128), context)?,
                U256::from(0x30u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x82u128), context)?,
                U256::from(0x0u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x83u128), context)?,
                U256::from(0x42u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x84u128), context)?,
                U256::from(0x53u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x85u128), context)?,
                U256::from(0x42u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x86u128), context)?,
                U256::from(0x32u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x87u128), context)?,
                U256::from(0x32u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x88u128), context)?,
                U256::from(0x2du128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x89u128), context)?,
                U256::from(0x50u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x8au128), context)?,
                U256::from(0x6cu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x8bu128), context)?,
                U256::from(0x6fu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x8cu128), context)?,
                U256::from(0x6eu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x8du128), context)?,
                U256::from(0x6bu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x8eu128), context)?,
                U256::from(0xbu128),
                context,
            )?;
            let ᵤsuccess = staticcall(
                gas(context)?,
                U256::from(0x2u128),
                ᵤmPtr,
                U256::from(0x8fu128),
                ᵤmPtr,
                U256::from(0x20u128),
                context,
            )?;
            if iszero(ᵤsuccess, context)? != U256::ZERO {
                ᵤerror_sha2(context)?;
            }
            let ᵤb0 = mload(ᵤmPtr, context)?;
            mstore8(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from(0x1u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x21u128), context)?,
                U256::from(0x42u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x22u128), context)?,
                U256::from(0x53u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x23u128), context)?,
                U256::from(0x42u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x24u128), context)?,
                U256::from(0x32u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x25u128), context)?,
                U256::from(0x32u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x26u128), context)?,
                U256::from(0x2du128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x27u128), context)?,
                U256::from(0x50u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x28u128), context)?,
                U256::from(0x6cu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x29u128), context)?,
                U256::from(0x6fu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x2au128), context)?,
                U256::from(0x6eu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x2bu128), context)?,
                U256::from(0x6bu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x2cu128), context)?,
                U256::from(0xbu128),
                context,
            )?;
            ᵤsuccess = staticcall(
                gas(context)?,
                U256::from(0x2u128),
                ᵤmPtr,
                U256::from(0x2du128),
                ᵤmPtr,
                U256::from(0x20u128),
                context,
            )?;
            if iszero(ᵤsuccess, context)? != U256::ZERO {
                ᵤerror_sha2(context)?;
            }
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                xor(mload(ᵤmPtr, context)?, ᵤb0, context)?,
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                U256::from(0x2u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x41u128), context)?,
                U256::from(0x42u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x42u128), context)?,
                U256::from(0x53u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x43u128), context)?,
                U256::from(0x42u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x44u128), context)?,
                U256::from(0x32u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x45u128), context)?,
                U256::from(0x32u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x46u128), context)?,
                U256::from(0x2du128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x47u128), context)?,
                U256::from(0x50u128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x48u128), context)?,
                U256::from(0x6cu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x49u128), context)?,
                U256::from(0x6fu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x4au128), context)?,
                U256::from(0x6eu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x4bu128), context)?,
                U256::from(0x6bu128),
                context,
            )?;
            mstore8(
                add(ᵤmPtr, U256::from(0x4cu128), context)?,
                U256::from(0xbu128),
                context,
            )?;
            let ᵤoffset = add(ᵤmPtr, U256::from(0x20u128), context)?;
            ᵤsuccess = staticcall(
                gas(context)?,
                U256::from(0x2u128),
                ᵤoffset,
                U256::from(0x2du128),
                ᵤoffset,
                U256::from(0x20u128),
                context,
            )?;
            if iszero(ᵤsuccess, context)? != U256::ZERO {
                ᵤerror_sha2(context)?;
            }
            var_res = mulmod(
                mload(ᵤmPtr, context)?,
                shl(U256::from(0x80u128), U256::from(0x1u128), context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤoffset = add(ᵤmPtr, U256::from(0x10u128), context)?;
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, U256::from(0x10u128), context)? != U256::ZERO {
                // body
                {
                    mstore8(ᵤoffset, U256::from(0x0u128), context)?;
                    ᵤoffset = add(ᵤoffset, U256::from(0x1u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            let ᵤb1 = mload(add(ᵤmPtr, U256::from(0x10u128), context)?, context)?;
            var_res = addmod(
                var_res,
                ᵤb1,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            Ok(var_res)
        }

        pub fn fun_load_vk_commitments_indices_commit_api(
            var_v_mpos: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let mut usr_v = add(var_v_mpos, U256::from(0x20u128), context)?;
            mstore(usr_v, U256::from(0x5u128), context)?;
            usr_v = add(usr_v, U256::from(0x20u128), context)?;
            Ok(())
        }

        pub fn fun_load_wire_commitments_commit_api(
            var_wire_commitments_mpos: U256,
            var_proof_302_mpos: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤw = add(var_wire_commitments_mpos, U256::from(0x20u128), context)?;
            let ᵤp = add(var_proof_302_mpos, U256::from(0x360u128), context)?;
            ᵤp = add(
                ᵤp,
                mul(U256::from(0x1u128), U256::from(0x20u128), context)?,
                context,
            )?;
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(
                ᵤi,
                mul(U256::from(0x1u128), U256::from(0x2u128), context)?,
                context,
            )? != U256::ZERO
            {
                // body
                {
                    mstore(ᵤw, mload(ᵤp, context)?, context)?;
                    ᵤw = add(ᵤw, U256::from(0x20u128), context)?;
                    ᵤp = add(ᵤp, U256::from(0x20u128), context)?;
                    mstore(ᵤw, mload(ᵤp, context)?, context)?;
                    ᵤw = add(ᵤw, U256::from(0x20u128), context)?;
                    ᵤp = add(ᵤp, U256::from(0x20u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            Ok(())
        }

        pub fn increment_wrapping_uint256(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = cleanup_uint256(add(value, U256::from(0x1u128), context)?, context)?;
            Ok(ret)
        }

        pub fn panic_error_0x32(context: &mut Context) -> YulOutput<()> {
            mstore(
                U256::from(0x0u128),
                shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?,
                context,
            )?;
            mstore(U256::from(0x4u128), U256::from(0x32u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn memory_array_index_access_uint256_dyn(
            baseRef: U256,
            index: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut addr = U256::ZERO;
            if iszero(
                lt(
                    index,
                    array_length_array_uint256_dyn(baseRef, context)?,
                    context,
                )?,
                context,
            )? != U256::ZERO
            {
                panic_error_0x32(context)?;
            }
            let mut offset = mul(index, U256::from(0x20u128), context)?;
            offset = add(offset, U256::from(0x20u128), context)?;
            addr = add(baseRef, offset, context)?;
            Ok(addr)
        }

        pub fn read_from_memoryt_uint256(ptr: U256, context: &mut Context) -> YulOutput<U256> {
            let mut returnValue = U256::ZERO;
            let value = cleanup_uint256(mload(ptr, context)?, context)?;
            returnValue = value;
            Ok(returnValue)
        }

        pub fn ᵤpow_130(
            ᵤx: U256,
            ᵤe: U256,
            ᵤmPtr: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut ᵤres = U256::ZERO;
            mstore(ᵤmPtr, U256::from(0x20u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from(0x20u128),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                U256::from(0x20u128),
                context,
            )?;
            mstore(add(ᵤmPtr, U256::from(0x60u128), context)?, ᵤx, context)?;
            mstore(add(ᵤmPtr, U256::from(0x80u128), context)?, ᵤe, context)?;
            mstore(
                add(ᵤmPtr, U256::from(0xa0u128), context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x5u128),
                    ᵤmPtr,
                    U256::from(0xc0u128),
                    ᵤmPtr,
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            ᵤres = mload(ᵤmPtr, context)?;
            Ok(ᵤres)
        }

        pub fn ᵤbatch_invert(
            ᵤins: U256,
            ᵤnb_ins: U256,
            ᵤmPtr: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            mstore(ᵤmPtr, U256::from(0x1u128), context)?;
            let ᵤoffset = U256::from(0x0u128);
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, ᵤnb_ins, context)? != U256::ZERO {
                // body
                {
                    let ᵤprev = mload(add(ᵤmPtr, ᵤoffset, context)?, context)?;
                    let ᵤcur = mload(add(ᵤins, ᵤoffset, context)?, context)?;
                    ᵤcur = mulmod(
                        ᵤprev,
                        ᵤcur,
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                    ᵤoffset = add(ᵤoffset, U256::from(0x20u128), context)?;
                    mstore(add(ᵤmPtr, ᵤoffset, context)?, ᵤcur, context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            ᵤins = add(ᵤins, sub(ᵤoffset, U256::from(0x20u128), context)?, context)?;
            ᵤmPtr = add(ᵤmPtr, ᵤoffset, context)?;
            let ᵤinv = ᵤpow_130(
                mload(ᵤmPtr, context)?,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x2u128),
                    context,
                )?,
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                context,
            )?;
            let ᵤi_1 = U256::from(0x0u128);
            // for loop
            while lt(ᵤi_1, ᵤnb_ins, context)? != U256::ZERO {
                // body
                {
                    ᵤmPtr = sub(ᵤmPtr, U256::from(0x20u128), context)?;
                    let ᵤtmp = mload(ᵤins, context)?;
                    let ᵤcur_1 = mulmod(
                        ᵤinv,
                        mload(ᵤmPtr, context)?,
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                    mstore(ᵤins, ᵤcur_1, context)?;
                    ᵤinv = mulmod(
                        ᵤinv,
                        ᵤtmp,
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                    ᵤins = sub(ᵤins, U256::from(0x20u128), context)?;
                }
                // post
                {
                    ᵤi_1 = add(ᵤi_1, U256::from(0x1u128), context)?;
                }
            }
            Ok(())
        }

        pub fn ᵤbatch_compute_lagranges_at_z(
            ᵤz: U256,
            ᵤn: U256,
            ᵤmPtr: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤzn = addmod(
                ᵤpow_130(ᵤz, U256::from(0x8u128), ᵤmPtr, context)?,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x1u128),
                    context,
                )?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤzn = mulmod(
                ᵤzn,
                U256::from_be_slice(&[
                    0x2a, 0x57, 0xc4, 0xa4, 0x85, 0x0b, 0x6c, 0x24, 0x81, 0x46, 0x3c, 0xff, 0xb1,
                    0x51, 0x2d, 0x51, 0x83, 0x2d, 0x6b, 0x3f, 0x6a, 0x82, 0x42, 0x7f, 0x1b, 0x65,
                    0xb6, 0xe1, 0x72, 0x00, 0x00, 0x01,
                ]),
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let mut usr_w = U256::from(0x1u128);
            let mut usr_mPtr = ᵤmPtr;
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, ᵤn, context)? != U256::ZERO {
                // body
                {
                    mstore(
                        usr_mPtr,
                        addmod(
                            ᵤz,
                            sub(
                                U256::from_be_slice(&[
                                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50,
                                    0x45, 0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48,
                                    0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00,
                                    0x00, 0x01,
                                ]),
                                usr_w,
                                context,
                            )?,
                            U256::from_be_slice(&[
                                0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45,
                                0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9,
                                0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                            ]),
                            context,
                        )?,
                        context,
                    )?;
                    usr_w = mulmod(
                        usr_w,
                        U256::from_be_slice(&[
                            0x2b, 0x33, 0x7d, 0xe1, 0xc8, 0xc1, 0x4f, 0x22, 0xec, 0x9b, 0x9e, 0x2f,
                            0x96, 0xaf, 0xef, 0x36, 0x52, 0x62, 0x73, 0x66, 0xf8, 0x17, 0x0a, 0x0a,
                            0x94, 0x8d, 0xad, 0x4a, 0xc1, 0xbd, 0x5e, 0x80,
                        ]),
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                    usr_mPtr = add(usr_mPtr, U256::from(0x20u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            ᵤbatch_invert(ᵤmPtr, ᵤn, usr_mPtr, context)?;
            usr_mPtr = ᵤmPtr;
            usr_w = U256::from(0x1u128);
            let ᵤi_1 = U256::from(0x0u128);
            // for loop
            while lt(ᵤi_1, ᵤn, context)? != U256::ZERO {
                // body
                {
                    mstore(
                        usr_mPtr,
                        mulmod(
                            mulmod(
                                mload(usr_mPtr, context)?,
                                ᵤzn,
                                U256::from_be_slice(&[
                                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50,
                                    0x45, 0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48,
                                    0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00,
                                    0x00, 0x01,
                                ]),
                                context,
                            )?,
                            usr_w,
                            U256::from_be_slice(&[
                                0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45,
                                0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9,
                                0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                            ]),
                            context,
                        )?,
                        context,
                    )?;
                    usr_mPtr = add(usr_mPtr, U256::from(0x20u128), context)?;
                    usr_w = mulmod(
                        usr_w,
                        U256::from_be_slice(&[
                            0x2b, 0x33, 0x7d, 0xe1, 0xc8, 0xc1, 0x4f, 0x22, 0xec, 0x9b, 0x9e, 0x2f,
                            0x96, 0xaf, 0xef, 0x36, 0x52, 0x62, 0x73, 0x66, 0xf8, 0x17, 0x0a, 0x0a,
                            0x94, 0x8d, 0xad, 0x4a, 0xc1, 0xbd, 0x5e, 0x80,
                        ]),
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                }
                // post
                {
                    ᵤi_1 = add(ᵤi_1, U256::from(0x1u128), context)?;
                }
            }
            Ok(())
        }

        pub fn ᵤsum_pi_wo_api_commit(
            ᵤins: U256,
            ᵤn: U256,
            ᵤz: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤli = mload(U256::from(0x40u128), context)?;
            ᵤbatch_compute_lagranges_at_z(ᵤz, ᵤn, ᵤli, context)?;
            let ᵤres = U256::from(0x0u128);
            let ᵤtmp = U256::from(0x0u128);
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, ᵤn, context)? != U256::ZERO {
                // body
                {
                    ᵤtmp = mulmod(
                        mload(ᵤli, context)?,
                        mload(ᵤins, context)?,
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                    ᵤres = addmod(
                        ᵤres,
                        ᵤtmp,
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                    ᵤli = add(ᵤli, U256::from(0x20u128), context)?;
                    ᵤins = add(ᵤins, U256::from(0x20u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            mstore(mload(U256::from(0x40u128), context)?, ᵤres, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_array_uint256_dyn(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_compute_pi(
            var_proof_325_mpos: U256,
            var_public_inputs_328_mpos: U256,
            var_zeta: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let mut var_zeta_power_n_minus_one = U256::ZERO;
            var_zeta_power_n_minus_one = zero_uint256;
            let mut var_pi = U256::ZERO;
            var_pi = zero_uint256;
            ᵤsum_pi_wo_api_commit(
                add(var_public_inputs_328_mpos, U256::from(0x20u128), context)?,
                mload(var_public_inputs_328_mpos, context)?,
                var_zeta,
                context,
            )?;
            var_pi = mload(mload(U256::from(0x40u128), context)?, context)?;
            var_zeta_power_n_minus_one = ᵤpow_130(
                var_zeta,
                U256::from(0x8u128),
                mload(U256::from(0x40u128), context)?,
                context,
            )?;
            var_zeta_power_n_minus_one = addmod(
                var_zeta_power_n_minus_one,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x1u128),
                    context,
                )?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let expr = constant_vk_nb_commitments_commit_api(context)?;
            let expr_351_mpos = allocate_and_zero_memory_array_array_uint256_dyn(expr, context)?;
            fun_load_vk_commitments_indices_commit_api(expr_351_mpos, context)?;
            let expr_1 = gt(
                cleanup_uint256(expr, context)?,
                convert_t_rational_by_to_t_uint256(U256::from(0x0u128), context)?,
                context,
            )?;
            if expr_1 != U256::ZERO {
                let mut var_wire_committed_commitments_mpos = U256::ZERO;
                let zero_array_uint256_dyn_mpos = zero_value_for_split_array_uint256_dyn(context)?;
                var_wire_committed_commitments_mpos = zero_array_uint256_dyn_mpos;
                let expr_2 = U256::from(0x2u128);
                let expr_3 = checked_mul_uint256(
                    convert_rational_2_by_1_to_uint256(U256::from(0x2u128), context)?,
                    expr,
                    context,
                )?;
                let expr_mpos = allocate_and_zero_memory_array_array_uint256_dyn(expr_3, context)?;
                var_wire_committed_commitments_mpos = expr_mpos;
                fun_load_wire_commitments_commit_api(expr_mpos, var_proof_325_mpos, context)?;
                let mut var_i = convert_t_rational_by_to_t_uint256(U256::from(0x0u128), context)?;
                // for loop
                while U256::from(0x1u128) != U256::ZERO {
                    // body
                    {
                        let expr_4 = lt(
                            cleanup_uint256(var_i, context)?,
                            cleanup_uint256(expr, context)?,
                            context,
                        )?;
                        if iszero(expr_4, context)? != U256::ZERO {
                            break;
                        }
                        let expr_5 = checked_mul_uint256(
                            convert_rational_2_by_1_to_uint256(expr_2, context)?,
                            var_i,
                            context,
                        )?;
                        let _2 = read_from_memoryt_uint256(
                            memory_array_index_access_uint256_dyn(expr_mpos, expr_5, context)?,
                            context,
                        )?;
                        let expr_6 = checked_mul_uint256(
                            convert_rational_2_by_1_to_uint256(expr_2, context)?,
                            var_i,
                            context,
                        )?;
                        let expr_7 = checked_add_uint256(
                            expr_6,
                            convert_rational_by_to_uint256(U256::from(0x1u128), context)?,
                            context,
                        )?;
                        let _3 = read_from_memoryt_uint256(
                            memory_array_index_access_uint256_dyn(expr_mpos, expr_7, context)?,
                            context,
                        )?;
                        let expr_8 = fun_hash_fr(_2, _3, context)?;
                        let _4 = read_from_memoryt_uint256(
                            memory_array_index_access_uint256_dyn(expr_351_mpos, var_i, context)?,
                            context,
                        )?;
                        let expr_9 =
                            array_length_array_uint256_dyn(var_public_inputs_328_mpos, context)?;
                        let expr_10 = checked_add_uint256(_4, expr_9, context)?;
                        let expr_11 = fun_compute_ith_lagrange_at_z(var_zeta, expr_10, context)?;
                        let mut var_a = expr_11;
                        var_a = mulmod(
                            expr_8,
                            expr_11,
                            U256::from_be_slice(&[
                                0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45,
                                0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9,
                                0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                            ]),
                            context,
                        )?;
                        var_pi = addmod(
                            var_pi,
                            var_a,
                            U256::from_be_slice(&[
                                0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45,
                                0xb6, 0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9,
                                0x70, 0x91, 0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                            ]),
                            context,
                        )?;
                    }
                    // post
                    {
                        let _1 = increment_wrapping_uint256(var_i, context)?;
                        var_i = _1;
                    }
                }
            }
            var = var_pi;
            Ok(var)
        }

        pub fn ᵤderive_alpha(
            ᵤaproof: U256,
            ᵤprev_challenge: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤmPtr = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, U256::from(0x616c706861u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                ᵤprev_challenge,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                mload(add(ᵤaproof, U256::from(0x240u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x60u128), context)?,
                mload(add(ᵤaproof, U256::from(0x260u128), context)?, context)?,
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x2u128),
                    add(ᵤmPtr, U256::from(0x1bu128), context)?,
                    U256::from(0x65u128),
                    ᵤmPtr,
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤderive_beta(
            ᵤaproof: U256,
            ᵤprev_challenge: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤmPtr = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, U256::from(0x62657461u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                ᵤprev_challenge,
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x2u128),
                    add(ᵤmPtr, U256::from(0x1cu128), context)?,
                    U256::from(0x24u128),
                    ᵤmPtr,
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤderive_gamma(
            ᵤaproof: U256,
            ᵤpub_inputs: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤmPtr = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, U256::from(0x67616d6d61u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from_be_slice(&[
                    0x1d, 0x54, 0x08, 0xc4, 0x3c, 0x22, 0xcc, 0x34, 0x43, 0x44, 0x88, 0xa0, 0xcb,
                    0x4f, 0xa2, 0x74, 0x5c, 0x3f, 0x42, 0x2b, 0x0f, 0xb1, 0x95, 0x72, 0x4e, 0x3f,
                    0x11, 0x43, 0xdd, 0xdc, 0x62, 0x2c,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                U256::from_be_slice(&[
                    0x16, 0x90, 0xd5, 0x73, 0xab, 0xd0, 0x18, 0x44, 0xec, 0x52, 0x82, 0x69, 0xbe,
                    0x78, 0x98, 0xe2, 0x59, 0xc9, 0xf1, 0xc7, 0x3c, 0x3c, 0x23, 0xa3, 0x65, 0xaf,
                    0xa5, 0x12, 0xc3, 0x45, 0x60, 0xe0,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x60u128), context)?,
                U256::from_be_slice(&[
                    0x02, 0xa5, 0xa3, 0xc7, 0x70, 0xa8, 0xe8, 0x59, 0x5b, 0xff, 0x76, 0x35, 0x8e,
                    0xf9, 0x82, 0xe8, 0xab, 0xf9, 0x5b, 0x08, 0xbf, 0x74, 0xf5, 0xc8, 0x70, 0x9b,
                    0xc3, 0x4d, 0x28, 0x48, 0x4b, 0x01,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x80u128), context)?,
                U256::from_be_slice(&[
                    0x01, 0x24, 0xc0, 0x5f, 0x06, 0xc5, 0xd4, 0x67, 0x26, 0xe8, 0x9a, 0x1a, 0xcc,
                    0xcf, 0x22, 0xf6, 0x4f, 0x8c, 0xe5, 0x35, 0x69, 0x9c, 0x27, 0xa6, 0x2a, 0x6a,
                    0x6a, 0x60, 0x45, 0xca, 0x36, 0x3e,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xa0u128), context)?,
                U256::from_be_slice(&[
                    0x0f, 0x8e, 0xc3, 0xf3, 0x86, 0x11, 0x51, 0x4a, 0xad, 0xfd, 0x2b, 0x6f, 0xcc,
                    0x3b, 0x6c, 0x29, 0x5b, 0xad, 0xd9, 0x8f, 0xfc, 0xe4, 0xb6, 0x5a, 0x9e, 0xa6,
                    0x71, 0x83, 0x28, 0xba, 0x18, 0x1f,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xc0u128), context)?,
                U256::from_be_slice(&[
                    0x00, 0xf6, 0x42, 0xac, 0x5b, 0xe0, 0xd8, 0x22, 0xc5, 0xa5, 0x35, 0x31, 0x2d,
                    0x58, 0x9b, 0x55, 0x57, 0xa8, 0xdb, 0x31, 0x83, 0xe4, 0x08, 0xfb, 0x78, 0xff,
                    0x8f, 0x1c, 0x8b, 0x7b, 0x20, 0x46,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xe0u128), context)?,
                U256::from_be_slice(&[
                    0x1c, 0x1b, 0x52, 0x5d, 0xf0, 0xb1, 0x85, 0x54, 0xd4, 0xdd, 0x82, 0x8f, 0x8b,
                    0x2e, 0x60, 0x73, 0x57, 0xf8, 0x25, 0x31, 0x37, 0x24, 0x2d, 0x14, 0xbc, 0x67,
                    0x38, 0x61, 0xdc, 0x34, 0xe1, 0x1a,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x100u128), context)?,
                U256::from_be_slice(&[
                    0x26, 0x48, 0xb5, 0xfd, 0xaf, 0xc7, 0x00, 0x00, 0x40, 0x29, 0xfc, 0x59, 0xff,
                    0x01, 0x40, 0x5c, 0x41, 0x0b, 0xb9, 0x1c, 0xdd, 0xc1, 0xb0, 0x7a, 0x79, 0x34,
                    0x2d, 0xb6, 0x0c, 0x64, 0xdf, 0x9e,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x120u128), context)?,
                U256::from_be_slice(&[
                    0x0c, 0x85, 0x03, 0x37, 0x81, 0x2a, 0xd8, 0xff, 0xa6, 0xd2, 0x93, 0x49, 0x04,
                    0x23, 0xf4, 0x91, 0xc4, 0x2e, 0x9b, 0xef, 0xa8, 0x8e, 0x42, 0xd9, 0xaa, 0x47,
                    0x6e, 0x19, 0x0f, 0x25, 0x07, 0xee,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x140u128), context)?,
                U256::from_be_slice(&[
                    0x0e, 0x1c, 0x89, 0x48, 0xd9, 0x1d, 0xab, 0x2e, 0x9f, 0xdc, 0xe3, 0x37, 0xe0,
                    0xa3, 0x45, 0xa1, 0xa7, 0xf1, 0xa2, 0x63, 0xa2, 0xda, 0xca, 0x60, 0x12, 0x12,
                    0x83, 0x20, 0xe5, 0xe8, 0x14, 0x69,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x160u128), context)?,
                U256::from_be_slice(&[
                    0x0b, 0x7b, 0x83, 0x7f, 0xbc, 0x61, 0x14, 0xcf, 0x48, 0x7b, 0x04, 0xa0, 0x5b,
                    0x3a, 0xeb, 0x8e, 0xac, 0x5d, 0xcf, 0x63, 0x02, 0x84, 0xd3, 0x20, 0x8d, 0x3e,
                    0x07, 0x2b, 0x2c, 0x37, 0x84, 0x36,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x180u128), context)?,
                U256::from_be_slice(&[
                    0x15, 0x62, 0xcf, 0x4b, 0x10, 0x44, 0xda, 0x21, 0xe7, 0x9e, 0xd8, 0xa6, 0xed,
                    0x7c, 0x39, 0x42, 0x9e, 0xbd, 0x00, 0x84, 0x97, 0x3c, 0x8d, 0x9e, 0x25, 0x26,
                    0x8f, 0xad, 0x26, 0xbe, 0x29, 0x1b,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x1a0u128), context)?,
                U256::from_be_slice(&[
                    0x0b, 0x7b, 0x83, 0x7f, 0xbc, 0x61, 0x14, 0xcf, 0x48, 0x7b, 0x04, 0xa0, 0x5b,
                    0x3a, 0xeb, 0x8e, 0xac, 0x5d, 0xcf, 0x63, 0x02, 0x84, 0xd3, 0x20, 0x8d, 0x3e,
                    0x07, 0x2b, 0x2c, 0x37, 0x84, 0x36,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x1c0u128), context)?,
                U256::from_be_slice(&[
                    0x1b, 0x01, 0x7f, 0x27, 0xd0, 0xec, 0xc6, 0x07, 0xd0, 0xb1, 0x6d, 0x0f, 0x94,
                    0x05, 0x1f, 0x1a, 0xf8, 0xc4, 0x6a, 0x0c, 0xd1, 0x35, 0x3c, 0xef, 0x16, 0xf9,
                    0xfc, 0x69, 0xb1, 0xbe, 0xd4, 0x2c,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x1e0u128), context)?,
                U256::from(0x0u128),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x200u128), context)?,
                U256::from(0x0u128),
                context,
            )?;
            let ᵤpi = add(ᵤpub_inputs, U256::from(0x20u128), context)?;
            let mut usr_mPtr = add(ᵤmPtr, U256::from(0x220u128), context)?;
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, mload(ᵤpub_inputs, context)?, context)? != U256::ZERO {
                // body
                {
                    mstore(usr_mPtr, mload(ᵤpi, context)?, context)?;
                    ᵤpi = add(ᵤpi, U256::from(0x20u128), context)?;
                    usr_mPtr = add(usr_mPtr, U256::from(0x20u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            let mut usr_proof = add(ᵤaproof, U256::from(0x360u128), context)?;
            usr_proof = add(
                usr_proof,
                mul(U256::from(0x1u128), U256::from(0x20u128), context)?,
                context,
            )?;
            let ᵤi_1 = U256::from(0x0u128);
            // for loop
            while lt(ᵤi_1, U256::from(0x1u128), context)? != U256::ZERO {
                // body
                {
                    mstore(usr_mPtr, mload(usr_proof, context)?, context)?;
                    mstore(
                        add(usr_mPtr, U256::from(0x20u128), context)?,
                        mload(add(usr_proof, U256::from(0x20u128), context)?, context)?,
                        context,
                    )?;
                    usr_mPtr = add(usr_mPtr, U256::from(0x40u128), context)?;
                    usr_proof = add(usr_proof, U256::from(0x40u128), context)?;
                }
                // post
                {
                    ᵤi_1 = add(ᵤi_1, U256::from(0x1u128), context)?;
                }
            }
            mstore(
                usr_mPtr,
                mload(add(ᵤaproof, U256::from(0x20u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(usr_mPtr, U256::from(0x20u128), context)?,
                mload(add(ᵤaproof, U256::from(0x40u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(usr_mPtr, U256::from(0x40u128), context)?,
                mload(add(ᵤaproof, U256::from(0x60u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(usr_mPtr, U256::from(0x60u128), context)?,
                mload(add(ᵤaproof, U256::from(0x80u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(usr_mPtr, U256::from(0x80u128), context)?,
                mload(add(ᵤaproof, U256::from(0xa0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(usr_mPtr, U256::from(0xa0u128), context)?,
                mload(add(ᵤaproof, U256::from(0xc0u128), context)?, context)?,
                context,
            )?;
            let ᵤsize = add(
                U256::from(0x2c5u128),
                mul(mload(ᵤpub_inputs, context)?, U256::from(0x20u128), context)?,
                context,
            )?;
            ᵤsize = add(
                ᵤsize,
                mul(U256::from(0x1u128), U256::from(0x40u128), context)?,
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x2u128),
                    add(ᵤmPtr, U256::from(0x1bu128), context)?,
                    ᵤsize,
                    ᵤmPtr,
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤderive_zeta(
            ᵤaproof: U256,
            ᵤprev_challenge: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤmPtr = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, U256::from(0x7a657461u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                ᵤprev_challenge,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                mload(add(ᵤaproof, U256::from(0xe0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x60u128), context)?,
                mload(add(ᵤaproof, U256::from(0x100u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x80u128), context)?,
                mload(add(ᵤaproof, U256::from(0x120u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xa0u128), context)?,
                mload(add(ᵤaproof, U256::from(0x140u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xc0u128), context)?,
                mload(add(ᵤaproof, U256::from(0x160u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xe0u128), context)?,
                mload(add(ᵤaproof, U256::from(0x180u128), context)?, context)?,
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x2u128),
                    add(ᵤmPtr, U256::from(0x1cu128), context)?,
                    U256::from(0xe4u128),
                    ᵤmPtr,
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn fun_derive_gamma_beta_alpha_zeta(
            var_proof_mpos: U256,
            var_public_inputs_266_mpos: U256,
            context: &mut Context,
        ) -> YulOutput<(U256, U256, U256, U256)> {
            let mut var = U256::ZERO;
            let mut var_1 = U256::ZERO;
            let mut var_2 = U256::ZERO;
            let mut var_ = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            var_1 = zero_uint256;
            var_2 = zero_uint256;
            var_ = zero_uint256;
            let mut var_gamma = U256::ZERO;
            var_gamma = zero_uint256;
            let mut var_beta = U256::ZERO;
            var_beta = zero_uint256;
            let mut var_alpha = U256::ZERO;
            var_alpha = zero_uint256;
            let mut var_zeta = U256::ZERO;
            var_zeta = zero_uint256;
            let ᵤmem = mload(U256::from(0x40u128), context)?;
            ᵤderive_gamma(var_proof_mpos, var_public_inputs_266_mpos, context)?;
            var_gamma = mload(ᵤmem, context)?;
            ᵤderive_beta(var_proof_mpos, var_gamma, context)?;
            var_beta = mload(ᵤmem, context)?;
            ᵤderive_alpha(var_proof_mpos, var_beta, context)?;
            var_alpha = mload(ᵤmem, context)?;
            ᵤderive_zeta(var_proof_mpos, var_alpha, context)?;
            var_zeta = mload(ᵤmem, context)?;
            var_gamma = mod_(
                var_gamma,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var_beta = mod_(
                var_beta,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var_alpha = mod_(
                var_alpha,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var_zeta = mod_(
                var_zeta,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            var = var_gamma;
            var_1 = var_beta;
            var_2 = var_alpha;
            var_ = var_zeta;
            Ok((var, var_1, var_2, var_))
        }

        pub fn ᵤfr_acc_mul(
            ᵤdst: U256,
            ᵤsrc: U256,
            ᵤs: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤtmp = mulmod(
                mload(ᵤsrc, context)?,
                ᵤs,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            mstore(
                ᵤdst,
                addmod(
                    mload(ᵤdst, context)?,
                    ᵤtmp,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤpoint_acc_mul(
            ᵤdst: U256,
            ᵤsrc: U256,
            ᵤs: U256,
            ᵤmPtr: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, mload(ᵤsrc, context)?, context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                mload(add(ᵤsrc, U256::from(0x20u128), context)?, context)?,
                context,
            )?;
            mstore(add(ᵤmPtr, U256::from(0x40u128), context)?, ᵤs, context)?;
            let ᵤl_success = staticcall(
                sub(gas(context)?, U256::from(0x7d0u128), context)?,
                U256::from(0x7u128),
                ᵤmPtr,
                U256::from(0x60u128),
                ᵤmPtr,
                U256::from(0x40u128),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                mload(ᵤdst, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x60u128), context)?,
                mload(add(ᵤdst, U256::from(0x20u128), context)?, context)?,
                context,
            )?;
            ᵤl_success = and(
                ᵤl_success,
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x6u128),
                    ᵤmPtr,
                    U256::from(0x80u128),
                    ᵤdst,
                    U256::from(0x40u128),
                    context,
                )?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x240u128), context)?,
                and(
                    ᵤl_success,
                    mload(add(ᵤstate, U256::from(0x240u128), context)?, context)?,
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤpoint_add(
            ᵤdst: U256,
            ᵤp: U256,
            ᵤq: U256,
            ᵤmPtr: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, mload(ᵤp, context)?, context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                mload(add(ᵤp, U256::from(0x20u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                mload(ᵤq, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x60u128), context)?,
                mload(add(ᵤq, U256::from(0x20u128), context)?, context)?,
                context,
            )?;
            let ᵤl_success = staticcall(
                sub(gas(context)?, U256::from(0x7d0u128), context)?,
                U256::from(0x6u128),
                ᵤmPtr,
                U256::from(0x80u128),
                ᵤdst,
                U256::from(0x40u128),
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x240u128), context)?,
                and(
                    ᵤl_success,
                    mload(add(ᵤstate, U256::from(0x240u128), context)?, context)?,
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤpoint_mul(
            ᵤdst: U256,
            ᵤsrc: U256,
            ᵤs: U256,
            ᵤmPtr: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            mstore(ᵤmPtr, mload(ᵤsrc, context)?, context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                mload(add(ᵤsrc, U256::from(0x20u128), context)?, context)?,
                context,
            )?;
            mstore(add(ᵤmPtr, U256::from(0x40u128), context)?, ᵤs, context)?;
            let ᵤl_success = staticcall(
                sub(gas(context)?, U256::from(0x7d0u128), context)?,
                U256::from(0x7u128),
                ᵤmPtr,
                U256::from(0x60u128),
                ᵤdst,
                U256::from(0x40u128),
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x240u128), context)?,
                and(
                    ᵤl_success,
                    mload(add(ᵤstate, U256::from(0x240u128), context)?, context)?,
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤbatch_verify_multi_points(
            ᵤaproof: U256, context: &mut Context
        ) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤmPtr = add(ᵤstate, U256::from(0x280u128), context)?;
            let ᵤrandom = mod_(
                keccak256(ᵤstate, U256::from(0x20u128), context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let ᵤfolded_quotients = ᵤmPtr;
            ᵤmPtr = add(ᵤmPtr, U256::from(0x40u128), context)?;
            mstore(
                ᵤfolded_quotients,
                mload(add(ᵤaproof, U256::from(0x2e0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤfolded_quotients, U256::from(0x20u128), context)?,
                mload(add(ᵤaproof, U256::from(0x300u128), context)?, context)?,
                context,
            )?;
            ᵤpoint_acc_mul(
                ᵤfolded_quotients,
                add(ᵤaproof, U256::from(0x320u128), context)?,
                ᵤrandom,
                ᵤmPtr,
                context,
            )?;
            let ᵤfolded_digests = add(ᵤstate, U256::from(0x180u128), context)?;
            ᵤpoint_acc_mul(
                ᵤfolded_digests,
                add(ᵤaproof, U256::from(0x240u128), context)?,
                ᵤrandom,
                ᵤmPtr,
                context,
            )?;
            let ᵤfolded_evals = add(ᵤstate, U256::from(0x160u128), context)?;
            ᵤfr_acc_mul(
                ᵤfolded_evals,
                add(ᵤaproof, U256::from(0x280u128), context)?,
                ᵤrandom,
                context,
            )?;
            let ᵤfolded_evals_commit = ᵤmPtr;
            ᵤmPtr = add(ᵤmPtr, U256::from(0x40u128), context)?;
            mstore(ᵤfolded_evals_commit, U256::from(0x1u128), context)?;
            mstore(
                add(ᵤfolded_evals_commit, U256::from(0x20u128), context)?,
                U256::from(0x2u128),
                context,
            )?;
            mstore(
                add(ᵤfolded_evals_commit, U256::from(0x40u128), context)?,
                mload(ᵤfolded_evals, context)?,
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x7u128),
                    ᵤfolded_evals_commit,
                    U256::from(0x60u128),
                    ᵤfolded_evals_commit,
                    U256::from(0x40u128),
                    context,
                )?,
                context,
            )?;
            let ᵤfolded_evals_commit_y = add(ᵤfolded_evals_commit, U256::from(0x20u128), context)?;
            mstore(
                ᵤfolded_evals_commit_y,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x97, 0x81, 0x6a, 0x91, 0x68, 0x71, 0xca, 0x8d,
                        0x3c, 0x20, 0x8c, 0x16, 0xd8, 0x7c, 0xfd, 0x47,
                    ]),
                    mload(ᵤfolded_evals_commit_y, context)?,
                    context,
                )?,
                context,
            )?;
            ᵤpoint_add(
                ᵤfolded_digests,
                ᵤfolded_digests,
                ᵤfolded_evals_commit,
                ᵤmPtr,
                context,
            )?;
            let ᵤfolded_points_quotients = ᵤmPtr;
            ᵤmPtr = add(ᵤmPtr, U256::from(0x40u128), context)?;
            ᵤpoint_mul(
                ᵤfolded_points_quotients,
                add(ᵤaproof, U256::from(0x2e0u128), context)?,
                mload(add(ᵤstate, U256::from(0x60u128), context)?, context)?,
                ᵤmPtr,
                context,
            )?;
            let ᵤzeta_omega = mulmod(
                mload(add(ᵤstate, U256::from(0x60u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x2b, 0x33, 0x7d, 0xe1, 0xc8, 0xc1, 0x4f, 0x22, 0xec, 0x9b, 0x9e, 0x2f, 0x96,
                    0xaf, 0xef, 0x36, 0x52, 0x62, 0x73, 0x66, 0xf8, 0x17, 0x0a, 0x0a, 0x94, 0x8d,
                    0xad, 0x4a, 0xc1, 0xbd, 0x5e, 0x80,
                ]),
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤrandom = mulmod(
                ᵤrandom,
                ᵤzeta_omega,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                ᵤfolded_points_quotients,
                add(ᵤaproof, U256::from(0x320u128), context)?,
                ᵤrandom,
                ᵤmPtr,
                context,
            )?;
            ᵤpoint_add(
                ᵤfolded_digests,
                ᵤfolded_digests,
                ᵤfolded_points_quotients,
                ᵤmPtr,
                context,
            )?;
            let ᵤfolded_quotients_y = add(ᵤfolded_quotients, U256::from(0x20u128), context)?;
            mstore(
                ᵤfolded_quotients_y,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x97, 0x81, 0x6a, 0x91, 0x68, 0x71, 0xca, 0x8d,
                        0x3c, 0x20, 0x8c, 0x16, 0xd8, 0x7c, 0xfd, 0x47,
                    ]),
                    mload(ᵤfolded_quotients_y, context)?,
                    context,
                )?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x260u128), context)?,
                mload(ᵤfolded_quotients_y, context)?,
                context,
            )?;
            mstore(ᵤmPtr, mload(ᵤfolded_digests, context)?, context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                mload(
                    add(ᵤfolded_digests, U256::from(0x20u128), context)?,
                    context,
                )?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                U256::from_be_slice(&[
                    0x19, 0x8e, 0x93, 0x93, 0x92, 0x0d, 0x48, 0x3a, 0x72, 0x60, 0xbf, 0xb7, 0x31,
                    0xfb, 0x5d, 0x25, 0xf1, 0xaa, 0x49, 0x33, 0x35, 0xa9, 0xe7, 0x12, 0x97, 0xe4,
                    0x85, 0xb7, 0xae, 0xf3, 0x12, 0xc2,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x60u128), context)?,
                U256::from_be_slice(&[
                    0x18, 0x00, 0xde, 0xef, 0x12, 0x1f, 0x1e, 0x76, 0x42, 0x6a, 0x00, 0x66, 0x5e,
                    0x5c, 0x44, 0x79, 0x67, 0x43, 0x22, 0xd4, 0xf7, 0x5e, 0xda, 0xdd, 0x46, 0xde,
                    0xbd, 0x5c, 0xd9, 0x92, 0xf6, 0xed,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x80u128), context)?,
                U256::from_be_slice(&[
                    0x09, 0x06, 0x89, 0xd0, 0x58, 0x5f, 0xf0, 0x75, 0xec, 0x9e, 0x99, 0xad, 0x69,
                    0x0c, 0x33, 0x95, 0xbc, 0x4b, 0x31, 0x33, 0x70, 0xb3, 0x8e, 0xf3, 0x55, 0xac,
                    0xda, 0xdc, 0xd1, 0x22, 0x97, 0x5b,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xa0u128), context)?,
                U256::from_be_slice(&[
                    0x12, 0xc8, 0x5e, 0xa5, 0xdb, 0x8c, 0x6d, 0xeb, 0x4a, 0xab, 0x71, 0x80, 0x8d,
                    0xcb, 0x40, 0x8f, 0xe3, 0xd1, 0xe7, 0x69, 0x0c, 0x43, 0xd3, 0x7b, 0x4c, 0xe6,
                    0xcc, 0x01, 0x66, 0xfa, 0x7d, 0xaa,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xc0u128), context)?,
                mload(ᵤfolded_quotients, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xe0u128), context)?,
                mload(ᵤfolded_quotients_y, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x100u128), context)?,
                U256::from_be_slice(&[
                    0x12, 0x74, 0x09, 0x34, 0xba, 0x96, 0x15, 0xb7, 0x7b, 0x6a, 0x49, 0xb0, 0x6f,
                    0xcc, 0xe8, 0x3c, 0xe9, 0x0d, 0x67, 0xb1, 0xd0, 0xe2, 0xa5, 0x30, 0x06, 0x9e,
                    0x3a, 0x73, 0x06, 0x56, 0x9a, 0x91,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x120u128), context)?,
                U256::from_be_slice(&[
                    0x11, 0x6d, 0xa8, 0xc8, 0x9a, 0x0d, 0x09, 0x0f, 0x3d, 0x86, 0x44, 0xad, 0xa3,
                    0x3a, 0x5f, 0x1c, 0x80, 0x13, 0xba, 0x72, 0x04, 0xae, 0xca, 0x62, 0xd6, 0x6d,
                    0x93, 0x1b, 0x99, 0xaf, 0xe6, 0xe7,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x140u128), context)?,
                U256::from_be_slice(&[
                    0x25, 0x22, 0x2d, 0x98, 0x16, 0xe5, 0xf8, 0x6b, 0x4a, 0x7d, 0xed, 0xd0, 0x0d,
                    0x04, 0xac, 0xc5, 0xc9, 0x79, 0xc1, 0x8b, 0xd2, 0x2b, 0x83, 0x4e, 0xa8, 0xc6,
                    0xd0, 0x7c, 0x0b, 0xa4, 0x41, 0xdb,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x160u128), context)?,
                U256::from_be_slice(&[
                    0x07, 0x64, 0x41, 0x04, 0x2e, 0x77, 0xb6, 0x30, 0x96, 0x44, 0xb5, 0x62, 0x51,
                    0xf0, 0x59, 0xcf, 0x14, 0xbe, 0xfc, 0x72, 0xac, 0x8a, 0x61, 0x57, 0xd3, 0x09,
                    0x24, 0xe5, 0x8d, 0xc4, 0xc1, 0x72,
                ]),
                context,
            )?;
            let ᵤl_success = staticcall(
                sub(gas(context)?, U256::from(0x7d0u128), context)?,
                U256::from(0x8u128),
                ᵤmPtr,
                U256::from(0x180u128),
                U256::from(0x0u128),
                U256::from(0x20u128),
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x240u128), context)?,
                and(
                    ᵤl_success,
                    mload(add(ᵤstate, U256::from(0x240u128), context)?, context)?,
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤpow(
            ᵤx: U256, ᵤe: U256, ᵤmPtr: U256, context: &mut Context
        ) -> YulOutput<U256> {
            let mut ᵤres = U256::ZERO;
            mstore(ᵤmPtr, U256::from(0x20u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from(0x20u128),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                U256::from(0x20u128),
                context,
            )?;
            mstore(add(ᵤmPtr, U256::from(0x60u128), context)?, ᵤx, context)?;
            mstore(add(ᵤmPtr, U256::from(0x80u128), context)?, ᵤe, context)?;
            mstore(
                add(ᵤmPtr, U256::from(0xa0u128), context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x5u128),
                    ᵤmPtr,
                    U256::from(0xc0u128),
                    ᵤmPtr,
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            ᵤres = mload(ᵤmPtr, context)?;
            Ok(ᵤres)
        }

        pub fn ᵤcompute_alpha_square_lagrange(context: &mut Context) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤmPtr = add(
                mload(U256::from(0x40u128), context)?,
                U256::from(0x280u128),
                context,
            )?;
            let ᵤres = ᵤpow(
                mload(add(ᵤstate, U256::from(0x60u128), context)?, context)?,
                U256::from(0x8u128),
                ᵤmPtr,
                context,
            )?;
            ᵤres = addmod(
                ᵤres,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x1u128),
                    context,
                )?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            mstore(add(ᵤstate, U256::from(0x1e0u128), context)?, ᵤres, context)?;
            let ᵤden = addmod(
                mload(add(ᵤstate, U256::from(0x60u128), context)?, context)?,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x1u128),
                    context,
                )?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤden = ᵤpow(
                ᵤden,
                sub(
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    U256::from(0x2u128),
                    context,
                )?,
                ᵤmPtr,
                context,
            )?;
            ᵤden = mulmod(
                ᵤden,
                U256::from_be_slice(&[
                    0x2a, 0x57, 0xc4, 0xa4, 0x85, 0x0b, 0x6c, 0x24, 0x81, 0x46, 0x3c, 0xff, 0xb1,
                    0x51, 0x2d, 0x51, 0x83, 0x2d, 0x6b, 0x3f, 0x6a, 0x82, 0x42, 0x7f, 0x1b, 0x65,
                    0xb6, 0xe1, 0x72, 0x00, 0x00, 0x01,
                ]),
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤres = mulmod(
                ᵤden,
                ᵤres,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let ᵤl_alpha = mload(add(ᵤstate, U256::from(0x0u128), context)?, context)?;
            ᵤres = mulmod(
                ᵤres,
                ᵤl_alpha,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤres = mulmod(
                ᵤres,
                ᵤl_alpha,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            mstore(add(ᵤstate, U256::from(0xc0u128), context)?, ᵤres, context)?;
            Ok(())
        }

        pub fn ᵤcompute_commitment_linearised_polynomial_ec(
            ᵤaproof: U256,
            ᵤs1: U256,
            ᵤs2: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤmPtr = add(
                mload(U256::from(0x40u128), context)?,
                U256::from(0x280u128),
                context,
            )?;
            mstore(
                ᵤmPtr,
                U256::from_be_slice(&[
                    0x1c, 0x1b, 0x52, 0x5d, 0xf0, 0xb1, 0x85, 0x54, 0xd4, 0xdd, 0x82, 0x8f, 0x8b,
                    0x2e, 0x60, 0x73, 0x57, 0xf8, 0x25, 0x31, 0x37, 0x24, 0x2d, 0x14, 0xbc, 0x67,
                    0x38, 0x61, 0xdc, 0x34, 0xe1, 0x1a,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from_be_slice(&[
                    0x26, 0x48, 0xb5, 0xfd, 0xaf, 0xc7, 0x00, 0x00, 0x40, 0x29, 0xfc, 0x59, 0xff,
                    0x01, 0x40, 0x5c, 0x41, 0x0b, 0xb9, 0x1c, 0xdd, 0xc1, 0xb0, 0x7a, 0x79, 0x34,
                    0x2d, 0xb6, 0x0c, 0x64, 0xdf, 0x9e,
                ]),
                context,
            )?;
            ᵤpoint_mul(
                add(ᵤstate, U256::from(0x120u128), context)?,
                ᵤmPtr,
                mload(add(ᵤaproof, U256::from(0x1a0u128), context)?, context)?,
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                context,
            )?;
            mstore(
                ᵤmPtr,
                U256::from_be_slice(&[
                    0x0c, 0x85, 0x03, 0x37, 0x81, 0x2a, 0xd8, 0xff, 0xa6, 0xd2, 0x93, 0x49, 0x04,
                    0x23, 0xf4, 0x91, 0xc4, 0x2e, 0x9b, 0xef, 0xa8, 0x8e, 0x42, 0xd9, 0xaa, 0x47,
                    0x6e, 0x19, 0x0f, 0x25, 0x07, 0xee,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from_be_slice(&[
                    0x0e, 0x1c, 0x89, 0x48, 0xd9, 0x1d, 0xab, 0x2e, 0x9f, 0xdc, 0xe3, 0x37, 0xe0,
                    0xa3, 0x45, 0xa1, 0xa7, 0xf1, 0xa2, 0x63, 0xa2, 0xda, 0xca, 0x60, 0x12, 0x12,
                    0x83, 0x20, 0xe5, 0xe8, 0x14, 0x69,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x120u128), context)?,
                ᵤmPtr,
                mload(add(ᵤaproof, U256::from(0x1c0u128), context)?, context)?,
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                context,
            )?;
            let ᵤrl = mulmod(
                mload(add(ᵤaproof, U256::from(0x1a0u128), context)?, context)?,
                mload(add(ᵤaproof, U256::from(0x1c0u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            mstore(
                ᵤmPtr,
                U256::from_be_slice(&[
                    0x0b, 0x7b, 0x83, 0x7f, 0xbc, 0x61, 0x14, 0xcf, 0x48, 0x7b, 0x04, 0xa0, 0x5b,
                    0x3a, 0xeb, 0x8e, 0xac, 0x5d, 0xcf, 0x63, 0x02, 0x84, 0xd3, 0x20, 0x8d, 0x3e,
                    0x07, 0x2b, 0x2c, 0x37, 0x84, 0x36,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from_be_slice(&[
                    0x15, 0x62, 0xcf, 0x4b, 0x10, 0x44, 0xda, 0x21, 0xe7, 0x9e, 0xd8, 0xa6, 0xed,
                    0x7c, 0x39, 0x42, 0x9e, 0xbd, 0x00, 0x84, 0x97, 0x3c, 0x8d, 0x9e, 0x25, 0x26,
                    0x8f, 0xad, 0x26, 0xbe, 0x29, 0x1b,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x120u128), context)?,
                ᵤmPtr,
                ᵤrl,
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                context,
            )?;
            mstore(
                ᵤmPtr,
                U256::from_be_slice(&[
                    0x0b, 0x7b, 0x83, 0x7f, 0xbc, 0x61, 0x14, 0xcf, 0x48, 0x7b, 0x04, 0xa0, 0x5b,
                    0x3a, 0xeb, 0x8e, 0xac, 0x5d, 0xcf, 0x63, 0x02, 0x84, 0xd3, 0x20, 0x8d, 0x3e,
                    0x07, 0x2b, 0x2c, 0x37, 0x84, 0x36,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from_be_slice(&[
                    0x1b, 0x01, 0x7f, 0x27, 0xd0, 0xec, 0xc6, 0x07, 0xd0, 0xb1, 0x6d, 0x0f, 0x94,
                    0x05, 0x1f, 0x1a, 0xf8, 0xc4, 0x6a, 0x0c, 0xd1, 0x35, 0x3c, 0xef, 0x16, 0xf9,
                    0xfc, 0x69, 0xb1, 0xbe, 0xd4, 0x2c,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x120u128), context)?,
                ᵤmPtr,
                mload(add(ᵤaproof, U256::from(0x1e0u128), context)?, context)?,
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                context,
            )?;
            mstore(ᵤmPtr, U256::from(0x0u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from(0x0u128),
                context,
            )?;
            ᵤpoint_add(
                add(ᵤstate, U256::from(0x120u128), context)?,
                add(ᵤstate, U256::from(0x120u128), context)?,
                ᵤmPtr,
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                context,
            )?;
            let ᵤcommits_api_at_zeta = add(ᵤaproof, U256::from(0x360u128), context)?;
            let ᵤcommits_api = add(
                ᵤaproof,
                add(
                    U256::from(0x360u128),
                    mul(U256::from(0x1u128), U256::from(0x20u128), context)?,
                    context,
                )?,
                context,
            )?;
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, U256::from(0x1u128), context)? != U256::ZERO {
                // body
                {
                    mstore(ᵤmPtr, mload(ᵤcommits_api, context)?, context)?;
                    mstore(
                        add(ᵤmPtr, U256::from(0x20u128), context)?,
                        mload(add(ᵤcommits_api, U256::from(0x20u128), context)?, context)?,
                        context,
                    )?;
                    ᵤpoint_acc_mul(
                        add(ᵤstate, U256::from(0x120u128), context)?,
                        ᵤmPtr,
                        mload(ᵤcommits_api_at_zeta, context)?,
                        add(ᵤmPtr, U256::from(0x40u128), context)?,
                        context,
                    )?;
                    ᵤcommits_api_at_zeta =
                        add(ᵤcommits_api_at_zeta, U256::from(0x20u128), context)?;
                    ᵤcommits_api = add(ᵤcommits_api, U256::from(0x40u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            mstore(
                ᵤmPtr,
                U256::from_be_slice(&[
                    0x0f, 0x8e, 0xc3, 0xf3, 0x86, 0x11, 0x51, 0x4a, 0xad, 0xfd, 0x2b, 0x6f, 0xcc,
                    0x3b, 0x6c, 0x29, 0x5b, 0xad, 0xd9, 0x8f, 0xfc, 0xe4, 0xb6, 0x5a, 0x9e, 0xa6,
                    0x71, 0x83, 0x28, 0xba, 0x18, 0x1f,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                U256::from_be_slice(&[
                    0x00, 0xf6, 0x42, 0xac, 0x5b, 0xe0, 0xd8, 0x22, 0xc5, 0xa5, 0x35, 0x31, 0x2d,
                    0x58, 0x9b, 0x55, 0x57, 0xa8, 0xdb, 0x31, 0x83, 0xe4, 0x08, 0xfb, 0x78, 0xff,
                    0x8f, 0x1c, 0x8b, 0x7b, 0x20, 0x46,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x120u128), context)?,
                ᵤmPtr,
                ᵤs1,
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                context,
            )?;
            mstore(
                ᵤmPtr,
                mload(add(ᵤaproof, U256::from(0x240u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                mload(add(ᵤaproof, U256::from(0x260u128), context)?, context)?,
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x120u128), context)?,
                ᵤmPtr,
                ᵤs2,
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤcompute_commitment_linearised_polynomial(
            ᵤaproof: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤl_beta = mload(add(ᵤstate, U256::from(0x20u128), context)?, context)?;
            let ᵤl_gamma = mload(add(ᵤstate, U256::from(0x40u128), context)?, context)?;
            let ᵤl_zeta = mload(add(ᵤstate, U256::from(0x60u128), context)?, context)?;
            let ᵤl_alpha = mload(add(ᵤstate, U256::from(0x0u128), context)?, context)?;
            let ᵤu = mulmod(
                mload(add(ᵤaproof, U256::from(0x280u128), context)?, context)?,
                ᵤl_beta,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let ᵤv = mulmod(
                ᵤl_beta,
                mload(add(ᵤaproof, U256::from(0x200u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤv = addmod(
                ᵤv,
                mload(add(ᵤaproof, U256::from(0x1a0u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤv = addmod(
                ᵤv,
                ᵤl_gamma,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let ᵤw = mulmod(
                ᵤl_beta,
                mload(add(ᵤaproof, U256::from(0x220u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤw = addmod(
                ᵤw,
                mload(add(ᵤaproof, U256::from(0x1c0u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤw = addmod(
                ᵤw,
                ᵤl_gamma,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let ᵤs1 = mulmod(
                ᵤu,
                ᵤv,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤs1 = mulmod(
                ᵤs1,
                ᵤw,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤs1 = mulmod(
                ᵤs1,
                ᵤl_alpha,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let ᵤbetazeta = mulmod(
                ᵤl_beta,
                ᵤl_zeta,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤu = addmod(
                ᵤbetazeta,
                mload(add(ᵤaproof, U256::from(0x1a0u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤu = addmod(
                ᵤu,
                ᵤl_gamma,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤv = mulmod(
                ᵤbetazeta,
                U256::from(0x5u128),
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤv = addmod(
                ᵤv,
                mload(add(ᵤaproof, U256::from(0x1c0u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤv = addmod(
                ᵤv,
                ᵤl_gamma,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤw = mulmod(
                ᵤbetazeta,
                mulmod(
                    U256::from(0x5u128),
                    U256::from(0x5u128),
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤw = addmod(
                ᵤw,
                mload(add(ᵤaproof, U256::from(0x1e0u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤw = addmod(
                ᵤw,
                ᵤl_gamma,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            let ᵤs2 = mulmod(
                ᵤu,
                ᵤv,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤs2 = mulmod(
                ᵤs2,
                ᵤw,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤs2 = sub(
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                ᵤs2,
                context,
            )?;
            ᵤs2 = mulmod(
                ᵤs2,
                ᵤl_alpha,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤs2 = addmod(
                ᵤs2,
                mload(add(ᵤstate, U256::from(0xc0u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤcompute_commitment_linearised_polynomial_ec(ᵤaproof, ᵤs1, ᵤs2, context)?;
            Ok(())
        }

        pub fn ᵤcompute_gamma_kzg(ᵤaproof: U256, context: &mut Context) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤmPtr = add(
                mload(U256::from(0x40u128), context)?,
                U256::from(0x280u128),
                context,
            )?;
            mstore(ᵤmPtr, U256::from(0x67616d6d61u128), context)?;
            mstore(
                add(ᵤmPtr, U256::from(0x20u128), context)?,
                mload(add(ᵤstate, U256::from(0x60u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x40u128), context)?,
                mload(add(ᵤstate, U256::from(0xe0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x60u128), context)?,
                mload(add(ᵤstate, U256::from(0x100u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x80u128), context)?,
                mload(add(ᵤstate, U256::from(0x120u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xa0u128), context)?,
                mload(add(ᵤstate, U256::from(0x140u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xc0u128), context)?,
                mload(add(ᵤaproof, U256::from(0x20u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0xe0u128), context)?,
                mload(add(ᵤaproof, U256::from(0x40u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x100u128), context)?,
                mload(add(ᵤaproof, U256::from(0x60u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x120u128), context)?,
                mload(add(ᵤaproof, U256::from(0x80u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x140u128), context)?,
                mload(add(ᵤaproof, U256::from(0xa0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x160u128), context)?,
                mload(add(ᵤaproof, U256::from(0xc0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x180u128), context)?,
                U256::from_be_slice(&[
                    0x1d, 0x54, 0x08, 0xc4, 0x3c, 0x22, 0xcc, 0x34, 0x43, 0x44, 0x88, 0xa0, 0xcb,
                    0x4f, 0xa2, 0x74, 0x5c, 0x3f, 0x42, 0x2b, 0x0f, 0xb1, 0x95, 0x72, 0x4e, 0x3f,
                    0x11, 0x43, 0xdd, 0xdc, 0x62, 0x2c,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x1a0u128), context)?,
                U256::from_be_slice(&[
                    0x16, 0x90, 0xd5, 0x73, 0xab, 0xd0, 0x18, 0x44, 0xec, 0x52, 0x82, 0x69, 0xbe,
                    0x78, 0x98, 0xe2, 0x59, 0xc9, 0xf1, 0xc7, 0x3c, 0x3c, 0x23, 0xa3, 0x65, 0xaf,
                    0xa5, 0x12, 0xc3, 0x45, 0x60, 0xe0,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x1c0u128), context)?,
                U256::from_be_slice(&[
                    0x02, 0xa5, 0xa3, 0xc7, 0x70, 0xa8, 0xe8, 0x59, 0x5b, 0xff, 0x76, 0x35, 0x8e,
                    0xf9, 0x82, 0xe8, 0xab, 0xf9, 0x5b, 0x08, 0xbf, 0x74, 0xf5, 0xc8, 0x70, 0x9b,
                    0xc3, 0x4d, 0x28, 0x48, 0x4b, 0x01,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, U256::from(0x1e0u128), context)?,
                U256::from_be_slice(&[
                    0x01, 0x24, 0xc0, 0x5f, 0x06, 0xc5, 0xd4, 0x67, 0x26, 0xe8, 0x9a, 0x1a, 0xcc,
                    0xcf, 0x22, 0xf6, 0x4f, 0x8c, 0xe5, 0x35, 0x69, 0x9c, 0x27, 0xa6, 0x2a, 0x6a,
                    0x6a, 0x60, 0x45, 0xca, 0x36, 0x3e,
                ]),
                context,
            )?;
            let ᵤoffset = U256::from(0x200u128);
            mstore(
                add(ᵤmPtr, ᵤoffset, context)?,
                U256::from_be_slice(&[
                    0x24, 0xa0, 0xb9, 0xcf, 0x26, 0x5f, 0x92, 0x6f, 0x25, 0x76, 0xbe, 0xbe, 0x81,
                    0xea, 0xf4, 0x48, 0x58, 0x74, 0xc5, 0xd0, 0xd4, 0x07, 0x86, 0xec, 0x77, 0x18,
                    0x59, 0x79, 0x38, 0xb1, 0x95, 0x0f,
                ]),
                context,
            )?;
            mstore(
                add(ᵤmPtr, add(ᵤoffset, U256::from(0x20u128), context)?, context)?,
                U256::from_be_slice(&[
                    0x07, 0xfc, 0x8d, 0xbc, 0x51, 0x0e, 0x83, 0xa4, 0x16, 0xaa, 0x31, 0xf4, 0x0f,
                    0xa1, 0x0c, 0x5c, 0x48, 0x63, 0xb7, 0x09, 0xbc, 0x74, 0x2c, 0xba, 0x06, 0x47,
                    0xbf, 0xc9, 0xe1, 0x1e, 0x51, 0x04,
                ]),
                context,
            )?;
            ᵤoffset = add(ᵤoffset, U256::from(0x40u128), context)?;
            mstore(
                add(ᵤmPtr, ᵤoffset, context)?,
                mload(add(ᵤaproof, U256::from(0x2a0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, add(ᵤoffset, U256::from(0x20u128), context)?, context)?,
                mload(add(ᵤaproof, U256::from(0x2c0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, add(ᵤoffset, U256::from(0x40u128), context)?, context)?,
                mload(add(ᵤaproof, U256::from(0x1a0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, add(ᵤoffset, U256::from(0x60u128), context)?, context)?,
                mload(add(ᵤaproof, U256::from(0x1c0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, add(ᵤoffset, U256::from(0x80u128), context)?, context)?,
                mload(add(ᵤaproof, U256::from(0x1e0u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, add(ᵤoffset, U256::from(0xa0u128), context)?, context)?,
                mload(add(ᵤaproof, U256::from(0x200u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤmPtr, add(ᵤoffset, U256::from(0xc0u128), context)?, context)?,
                mload(add(ᵤaproof, U256::from(0x220u128), context)?, context)?,
                context,
            )?;
            let ᵤ_mPtr = add(ᵤmPtr, add(ᵤoffset, U256::from(0xe0u128), context)?, context)?;
            let mut usr_poscaz = add(ᵤaproof, U256::from(0x360u128), context)?;
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, U256::from(0x1u128), context)? != U256::ZERO {
                // body
                {
                    mstore(ᵤ_mPtr, mload(usr_poscaz, context)?, context)?;
                    usr_poscaz = add(usr_poscaz, U256::from(0x20u128), context)?;
                    ᵤ_mPtr = add(ᵤ_mPtr, U256::from(0x20u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            let ᵤsize_input = add(
                U256::from(0x16u128),
                mul(U256::from(0x1u128), U256::from(0x3u128), context)?,
                context,
            )?;
            ᵤsize_input = add(
                U256::from(0x5u128),
                mul(ᵤsize_input, U256::from(0x20u128), context)?,
                context,
            )?;
            pop(
                staticcall(
                    sub(gas(context)?, U256::from(0x7d0u128), context)?,
                    U256::from(0x2u128),
                    add(ᵤmPtr, U256::from(0x1bu128), context)?,
                    ᵤsize_input,
                    add(ᵤstate, U256::from(0x220u128), context)?,
                    U256::from(0x20u128),
                    context,
                )?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x220u128), context)?,
                mod_(
                    mload(add(ᵤstate, U256::from(0x220u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤfold_h(ᵤaproof: U256, context: &mut Context) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤmPtr = add(
                mload(U256::from(0x40u128), context)?,
                U256::from(0x280u128),
                context,
            )?;
            let ᵤzeta_power_n_plus_two = ᵤpow(
                mload(add(ᵤstate, U256::from(0x60u128), context)?, context)?,
                add(U256::from(0x8u128), U256::from(0x2u128), context)?,
                ᵤmPtr,
                context,
            )?;
            ᵤpoint_mul(
                add(ᵤstate, U256::from(0xe0u128), context)?,
                add(ᵤaproof, U256::from(0x160u128), context)?,
                ᵤzeta_power_n_plus_two,
                ᵤmPtr,
                context,
            )?;
            ᵤpoint_add(
                add(ᵤstate, U256::from(0xe0u128), context)?,
                add(ᵤstate, U256::from(0xe0u128), context)?,
                add(ᵤaproof, U256::from(0x120u128), context)?,
                ᵤmPtr,
                context,
            )?;
            ᵤpoint_mul(
                add(ᵤstate, U256::from(0xe0u128), context)?,
                add(ᵤstate, U256::from(0xe0u128), context)?,
                ᵤzeta_power_n_plus_two,
                ᵤmPtr,
                context,
            )?;
            ᵤpoint_add(
                add(ᵤstate, U256::from(0xe0u128), context)?,
                add(ᵤstate, U256::from(0xe0u128), context)?,
                add(ᵤaproof, U256::from(0xe0u128), context)?,
                ᵤmPtr,
                context,
            )?;
            Ok(())
        }

        pub fn ᵤfold_state(ᵤaproof: U256, context: &mut Context) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤmPtr = add(
                mload(U256::from(0x40u128), context)?,
                U256::from(0x280u128),
                context,
            )?;
            let ᵤl_gamma_kzg = mload(add(ᵤstate, U256::from(0x220u128), context)?, context)?;
            let ᵤacc_gamma = ᵤl_gamma_kzg;
            let ᵤmPtrOffset = add(
                ᵤmPtr,
                add(
                    U256::from(0x200u128),
                    mul(U256::from(0x1u128), U256::from(0x40u128), context)?,
                    context,
                )?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x180u128), context)?,
                mload(add(ᵤmPtr, U256::from(0x40u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x1a0u128), context)?,
                mload(add(ᵤmPtr, U256::from(0x60u128), context)?, context)?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x160u128), context)?,
                mload(add(ᵤaproof, U256::from(0x2a0u128), context)?, context)?,
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x180u128), context)?,
                add(ᵤmPtr, U256::from(0x80u128), context)?,
                ᵤl_gamma_kzg,
                ᵤmPtrOffset,
                context,
            )?;
            ᵤfr_acc_mul(
                add(ᵤstate, U256::from(0x160u128), context)?,
                add(ᵤaproof, U256::from(0x2c0u128), context)?,
                ᵤl_gamma_kzg,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x260u128), context)?,
                ᵤl_gamma_kzg,
                context,
            )?;
            ᵤacc_gamma = mulmod(
                ᵤl_gamma_kzg,
                ᵤl_gamma_kzg,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x180u128), context)?,
                add(ᵤmPtr, U256::from(0xc0u128), context)?,
                ᵤacc_gamma,
                ᵤmPtrOffset,
                context,
            )?;
            ᵤfr_acc_mul(
                add(ᵤstate, U256::from(0x160u128), context)?,
                add(ᵤaproof, U256::from(0x1a0u128), context)?,
                ᵤacc_gamma,
                context,
            )?;
            ᵤacc_gamma = mulmod(
                ᵤacc_gamma,
                ᵤl_gamma_kzg,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x180u128), context)?,
                add(ᵤmPtr, U256::from(0x100u128), context)?,
                ᵤacc_gamma,
                ᵤmPtrOffset,
                context,
            )?;
            ᵤfr_acc_mul(
                add(ᵤstate, U256::from(0x160u128), context)?,
                add(ᵤaproof, U256::from(0x1c0u128), context)?,
                ᵤacc_gamma,
                context,
            )?;
            ᵤacc_gamma = mulmod(
                ᵤacc_gamma,
                ᵤl_gamma_kzg,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x180u128), context)?,
                add(ᵤmPtr, U256::from(0x140u128), context)?,
                ᵤacc_gamma,
                ᵤmPtrOffset,
                context,
            )?;
            ᵤfr_acc_mul(
                add(ᵤstate, U256::from(0x160u128), context)?,
                add(ᵤaproof, U256::from(0x1e0u128), context)?,
                ᵤacc_gamma,
                context,
            )?;
            ᵤacc_gamma = mulmod(
                ᵤacc_gamma,
                ᵤl_gamma_kzg,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x180u128), context)?,
                add(ᵤmPtr, U256::from(0x180u128), context)?,
                ᵤacc_gamma,
                ᵤmPtrOffset,
                context,
            )?;
            ᵤfr_acc_mul(
                add(ᵤstate, U256::from(0x160u128), context)?,
                add(ᵤaproof, U256::from(0x200u128), context)?,
                ᵤacc_gamma,
                context,
            )?;
            ᵤacc_gamma = mulmod(
                ᵤacc_gamma,
                ᵤl_gamma_kzg,
                U256::from_be_slice(&[
                    0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6, 0x81,
                    0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91, 0x43, 0xe1,
                    0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                ]),
                context,
            )?;
            ᵤpoint_acc_mul(
                add(ᵤstate, U256::from(0x180u128), context)?,
                add(ᵤmPtr, U256::from(0x1c0u128), context)?,
                ᵤacc_gamma,
                ᵤmPtrOffset,
                context,
            )?;
            ᵤfr_acc_mul(
                add(ᵤstate, U256::from(0x160u128), context)?,
                add(ᵤaproof, U256::from(0x220u128), context)?,
                ᵤacc_gamma,
                context,
            )?;
            let ᵤposcaz = add(ᵤaproof, U256::from(0x360u128), context)?;
            let ᵤopca = add(ᵤmPtr, U256::from(0x200u128), context)?;
            let ᵤi = U256::from(0x0u128);
            // for loop
            while lt(ᵤi, U256::from(0x1u128), context)? != U256::ZERO {
                // body
                {
                    ᵤacc_gamma = mulmod(
                        ᵤacc_gamma,
                        ᵤl_gamma_kzg,
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        context,
                    )?;
                    ᵤpoint_acc_mul(
                        add(ᵤstate, U256::from(0x180u128), context)?,
                        ᵤopca,
                        ᵤacc_gamma,
                        ᵤmPtrOffset,
                        context,
                    )?;
                    ᵤfr_acc_mul(
                        add(ᵤstate, U256::from(0x160u128), context)?,
                        ᵤposcaz,
                        ᵤacc_gamma,
                        context,
                    )?;
                    ᵤposcaz = add(ᵤposcaz, U256::from(0x20u128), context)?;
                    ᵤopca = add(ᵤopca, U256::from(0x40u128), context)?;
                }
                // post
                {
                    ᵤi = add(ᵤi, U256::from(0x1u128), context)?;
                }
            }
            Ok(())
        }

        pub fn ᵤverify_quotient_poly_eval_at_zeta(
            ᵤaproof: U256,
            context: &mut Context,
        ) -> YulOutput<()> {
            let ᵤstate = mload(U256::from(0x40u128), context)?;
            let ᵤs1 = add(
                mload(U256::from(0x40u128), context)?,
                U256::from(0x280u128),
                context,
            )?;
            mstore(
                ᵤs1,
                mulmod(
                    mload(add(ᵤaproof, U256::from(0x200u128), context)?, context)?,
                    mload(add(ᵤstate, U256::from(0x20u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs1,
                addmod(
                    mload(ᵤs1, context)?,
                    mload(add(ᵤstate, U256::from(0x40u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs1,
                addmod(
                    mload(ᵤs1, context)?,
                    mload(add(ᵤaproof, U256::from(0x1a0u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            let ᵤs2 = add(ᵤs1, U256::from(0x20u128), context)?;
            mstore(
                ᵤs2,
                mulmod(
                    mload(add(ᵤaproof, U256::from(0x220u128), context)?, context)?,
                    mload(add(ᵤstate, U256::from(0x20u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs2,
                addmod(
                    mload(ᵤs2, context)?,
                    mload(add(ᵤstate, U256::from(0x40u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs2,
                addmod(
                    mload(ᵤs2, context)?,
                    mload(add(ᵤaproof, U256::from(0x1c0u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            let ᵤo = add(ᵤs1, U256::from(0x40u128), context)?;
            mstore(
                ᵤo,
                addmod(
                    mload(add(ᵤaproof, U256::from(0x1e0u128), context)?, context)?,
                    mload(add(ᵤstate, U256::from(0x40u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs1,
                mulmod(
                    mload(ᵤs1, context)?,
                    mload(ᵤs2, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs1,
                mulmod(
                    mload(ᵤs1, context)?,
                    mload(ᵤo, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs1,
                mulmod(
                    mload(ᵤs1, context)?,
                    mload(add(ᵤstate, U256::from(0x0u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs1,
                mulmod(
                    mload(ᵤs1, context)?,
                    mload(add(ᵤaproof, U256::from(0x280u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            let ᵤcomputed_quotient = add(ᵤs1, U256::from(0x60u128), context)?;
            mstore(
                ᵤcomputed_quotient,
                addmod(
                    mload(add(ᵤaproof, U256::from(0x2c0u128), context)?, context)?,
                    mload(add(ᵤstate, U256::from(0x1c0u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤcomputed_quotient,
                addmod(
                    mload(ᵤcomputed_quotient, context)?,
                    mload(ᵤs1, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤcomputed_quotient,
                addmod(
                    mload(ᵤcomputed_quotient, context)?,
                    sub(
                        U256::from_be_slice(&[
                            0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                            0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                            0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                        ]),
                        mload(add(ᵤstate, U256::from(0xc0u128), context)?, context)?,
                        context,
                    )?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                ᵤs2,
                mulmod(
                    mload(add(ᵤaproof, U256::from(0x2a0u128), context)?, context)?,
                    mload(add(ᵤstate, U256::from(0x1e0u128), context)?, context)?,
                    U256::from_be_slice(&[
                        0x30, 0x64, 0x4e, 0x72, 0xe1, 0x31, 0xa0, 0x29, 0xb8, 0x50, 0x45, 0xb6,
                        0x81, 0x81, 0x58, 0x5d, 0x28, 0x33, 0xe8, 0x48, 0x79, 0xb9, 0x70, 0x91,
                        0x43, 0xe1, 0xf5, 0x93, 0xf0, 0x00, 0x00, 0x01,
                    ]),
                    context,
                )?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x240u128), context)?,
                mload(ᵤcomputed_quotient, context)?,
                context,
            )?;
            mstore(
                add(ᵤstate, U256::from(0x240u128), context)?,
                eq(
                    mload(ᵤcomputed_quotient, context)?,
                    mload(ᵤs2, context)?,
                    context,
                )?,
                context,
            )?;
            Ok(())
        }

        pub fn zero_value_for_split_bool(context: &mut Context) -> YulOutput<U256> {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_Verify(
            var_proof_431_mpos: U256,
            var_public_inputs_mpos: U256,
            context: &mut Context,
        ) -> YulOutput<U256> {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let mut var_gamma = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_gamma = zero_uint256;
            let mut var_beta = U256::ZERO;
            var_beta = zero_uint256;
            let mut var_alpha = U256::ZERO;
            var_alpha = zero_uint256;
            let mut var_zeta = U256::ZERO;
            var_zeta = zero_uint256;
            let (expr_component, expr_component_1, expr_component_2, expr_component_3) =
                fun_derive_gamma_beta_alpha_zeta(
                    var_proof_431_mpos,
                    var_public_inputs_mpos,
                    context,
                )?;
            var_zeta = expr_component_3;
            var_alpha = expr_component_2;
            var_beta = expr_component_1;
            var_gamma = expr_component;
            let expr = fun_compute_pi(
                var_proof_431_mpos,
                var_public_inputs_mpos,
                expr_component_3,
                context,
            )?;
            let mut var_check = U256::ZERO;
            var_check = zero_uint256;
            let mut var_success = U256::from(0x0u128);
            let ᵤmem = mload(U256::from(0x40u128), context)?;
            mstore(
                add(ᵤmem, U256::from(0x0u128), context)?,
                expr_component_2,
                context,
            )?;
            mstore(
                add(ᵤmem, U256::from(0x40u128), context)?,
                expr_component,
                context,
            )?;
            mstore(
                add(ᵤmem, U256::from(0x60u128), context)?,
                expr_component_3,
                context,
            )?;
            mstore(
                add(ᵤmem, U256::from(0x20u128), context)?,
                expr_component_1,
                context,
            )?;
            mstore(add(ᵤmem, U256::from(0x1c0u128), context)?, expr, context)?;
            ᵤcompute_alpha_square_lagrange(context)?;
            ᵤverify_quotient_poly_eval_at_zeta(var_proof_431_mpos, context)?;
            ᵤfold_h(var_proof_431_mpos, context)?;
            ᵤcompute_commitment_linearised_polynomial(var_proof_431_mpos, context)?;
            ᵤcompute_gamma_kzg(var_proof_431_mpos, context)?;
            ᵤfold_state(var_proof_431_mpos, context)?;
            ᵤbatch_verify_multi_points(var_proof_431_mpos, context)?;
            var_success = mload(add(ᵤmem, U256::from(0x240u128), context)?, context)?;
            var_check = mload(add(ᵤmem, U256::from(0x260u128), context)?, context)?;
            var = var_success;
            Ok(var)
        }

        pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(
            context: &mut Context,
        ) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn external_fun_Verify(context: &mut Context) -> YulOutput<()> {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(
                    context,
                )?;
            }
            let (param, param_1) = abi_decode_bytest_array_uint256_dyn(
                U256::from(0x4u128),
                calldatasize(context)?,
                context,
            )?;
            let ret = fun_Verify(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(
            context: &mut Context,
        ) -> YulOutput<()> {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned(value: U256, context: &mut Context) -> YulOutput<U256> {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body(context: &mut Context) -> YulOutput<()> {
            mstore(U256::from(0x40u128), U256::from(0x80u128), context)?;
            if iszero(
                lt(calldatasize(context)?, U256::from(0x4u128), context)?,
                context,
            )? != U256::ZERO
            {
                let selector =
                    shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                if eq(U256::from(0x7e4f7a8au128), selector, context)? != U256::ZERO {
                    external_fun_Verify(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let mut context = Context {
        memory: Memory::new(),
        gas: U256::from(100 * 1000),
        calldata: vec![],
    };
    let result = plonkverifier_482::plonkverifier_482_deployed::fun_runTests(&mut context);
    println!("result: {:#?}", result);
    // println!("context: {:#?}", context);
}
