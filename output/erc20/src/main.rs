// Generated by Oxidefier

#![allow(mixed_script_confusables)]
#![allow(non_snake_case)]
#![allow(uncommon_codepoints)]
#![allow(unused_assignments)]
#![allow(unused_variables)]

use alloy_primitives::U256;
use evm_opcodes::*;

pub mod erc20 {
    use alloy_primitives::U256;
    use evm_opcodes::*;

    pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = mload(U256::from(0x40u128), context)?;
        Ok(memPtr)
    }

    pub fn panic_error_0x41<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
        mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
        revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
        Ok(())
    }

    pub fn round_up_to_mul_of<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
        Ok(result)
    }

    pub fn finalize_allocation<CI>(memPtr: U256, size: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
        if or(gt(newFreePtr, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        mstore(U256::from(0x40u128), newFreePtr, context)?;
        Ok(())
    }

    pub fn allocate_memory<CI>(size: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut memPtr = U256::ZERO;
        memPtr = allocate_unbounded(context)?;
        finalize_allocation(memPtr, size, context)?;
        Ok(memPtr)
    }

    pub fn array_allocation_size_string<CI>(length: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut size = U256::ZERO;
        if gt(length, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        size = round_up_to_mul_of(length, context)?;
        size = add(size, U256::from(0x20u128), context)?;
        Ok(size)
    }

    pub fn copy_memory_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mcopy(dst, src, length, context)?;
        mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn abi_decode_available_length_string_fromMemory<CI>(src: U256, length: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut array = U256::ZERO;
        array = allocate_memory(array_allocation_size_string(length, context)?, context)?;
        mstore(array, length, context)?;
        if gt(add(src, length, context)?, end_, context)? != U256::ZERO {
            revert_error_987264b3b1d58a9c7f8255e93e81c77d86d6299019c33110a076957a3e06e2ae(context)?;
        }
        copy_memory_to_memory_with_cleanup(src, add(array, U256::from(0x20u128), context)?, length, context)?;
        Ok(array)
    }

    pub fn revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn abi_decode_string_fromMemory<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut array = U256::ZERO;
        if iszero(slt(add(offset, U256::from(0x1fu128), context)?, end_, context)?, context)? != U256::ZERO {
            revert_error_1b9f4a0a5773e33b91aa01db23bf8c55fce1411167c872835e7fa00a4f17d46d(context)?;
        }
        let length = mload(offset, context)?;
        array = abi_decode_available_length_string_fromMemory(add(offset, U256::from(0x20u128), context)?, length, end_, context)?;
        Ok(array)
    }

    pub fn revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn abi_decode_stringt_string_fromMemory<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
    where
        Context<CI>: ContractInteractions,
    {
        let mut value0 = U256::ZERO;
        let mut value1 = U256::ZERO;
        if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
            revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
        }
        let offset = mload(add(headStart, U256::from(0x0u128), context)?, context)?;
        if gt(offset, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)? != U256::ZERO {
            revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
        }
        value0 = abi_decode_string_fromMemory(add(headStart, offset, context)?, dataEnd, context)?;
        let offset_1 = mload(add(headStart, U256::from(0x20u128), context)?, context)?;
        if gt(offset_1, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)? != U256::ZERO {
            revert_error_c1322bf8034eace5e0b5c7295db60986aa89aae5e0ea0873e4689e076861a5db(context)?;
        }
        value1 = abi_decode_string_fromMemory(add(headStart, offset_1, context)?, dataEnd, context)?;
        Ok((value0, value1))
    }

    pub fn array_dataslot_string_storage<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut data = U256::ZERO;
        data = ptr;
        mstore(U256::from(0x0u128), ptr, context)?;
        data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
        Ok(data)
    }

    pub fn array_length_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut length = U256::ZERO;
        length = mload(value, context)?;
        Ok(length)
    }

    pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut cleaned = U256::ZERO;
        cleaned = value;
        Ok(cleaned)
    }

    pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn convert_uint256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut converted = U256::ZERO;
        converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
        Ok(converted)
    }

    pub fn prepare_store_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = value;
        Ok(ret)
    }

    pub fn shift_left_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shl(bits, value, context)?;
        Ok(newValue)
    }

    pub fn update_byte_slice_dynamic32<CI>(mut value: U256, shiftBytes: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let shiftBits = mul(shiftBytes, U256::from(0x8u128), context)?;
        let mask = shift_left_dynamic(shiftBits, not(U256::from(0x0u128), context)?, context)?;
        toInsert = shift_left_dynamic(shiftBits, toInsert, context)?;
        value = and(value, not(mask, context)?, context)?;
        result = or(value, and(toInsert, mask, context)?, context)?;
        Ok(result)
    }

    pub fn update_storage_value_uint256_to_uint256<CI>(slot: U256, offset: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let convertedValue = convert_uint256_to_uint256(value, context)?;
        sstore(slot, update_byte_slice_dynamic32(sload(slot, context)?, offset, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
        Ok(())
    }

    pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret = U256::ZERO;
        ret = U256::from(0x0u128);
        Ok(ret)
    }

    pub fn storage_set_to_zero_uint256<CI>(slot: U256, offset: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let zero = zero_value_for_split_uint256(context)?;
        update_storage_value_uint256_to_uint256(slot, offset, zero, context)?;
        Ok(())
    }

    pub fn clear_storage_range_bytes1<CI>(mut start: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        // for loop
        while lt(start, end_, context)? != U256::ZERO {
            // body
            {
                storage_set_to_zero_uint256(start, U256::from(0x0u128), context)?;
            }
            // post
            {
                start = add(start, U256::from(0x1u128), context)?;
            }
        }
        Ok(())
    }

    pub fn divide_by_ceil<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        result = div(add(value, U256::from(0x1fu128), context)?, U256::from(0x20u128), context)?;
        Ok(result)
    }

    pub fn clean_up_bytearray_end_slots_string_storage<CI>(array: U256, len: U256, startIndex: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        if gt(len, U256::from(0x1fu128), context)? != U256::ZERO {
            let dataArea = array_dataslot_string_storage(array, context)?;
            let mut deleteStart = add(dataArea, divide_by_ceil(startIndex, context)?, context)?;
            if lt(startIndex, U256::from(0x20u128), context)? != U256::ZERO {
                deleteStart = dataArea;
            }
            clear_storage_range_bytes1(deleteStart, add(dataArea, divide_by_ceil(len, context)?, context)?, context)?;
        }
        Ok(())
    }

    pub fn panic_error_0x22<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
        mstore(U256::from(0x4u128), U256::from(0x22u128), context)?;
        revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
        Ok(())
    }

    pub fn extract_byte_array_length<CI>(data: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut length = U256::ZERO;
        length = div(data, U256::from(0x2u128), context)?;
        let outOfPlaceEncoding = and(data, U256::from(0x1u128), context)?;
        if iszero(outOfPlaceEncoding, context)? != U256::ZERO {
            length = and(length, U256::from(0x7fu128), context)?;
        }
        if eq(outOfPlaceEncoding, lt(length, U256::from(0x20u128), context)?, context)? != U256::ZERO {
            panic_error_0x22(context)?;
        }
        Ok(length)
    }

    pub fn shift_right_unsigned_dynamic<CI>(bits: U256, value: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut newValue = U256::ZERO;
        newValue = shr(bits, value, context)?;
        Ok(newValue)
    }

    pub fn mask_bytes_dynamic<CI>(data: U256, bytes: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut result = U256::ZERO;
        let mask = not(shift_right_unsigned_dynamic(mul(U256::from(0x8u128), bytes, context)?, not(U256::from(0x0u128), context)?, context)?, context)?;
        result = and(data, mask, context)?;
        Ok(result)
    }

    pub fn extract_used_part_and_set_length_of_short_byte_array<CI>(mut data: U256, len: U256, context: &mut Context<CI>) -> YulOutput<U256>
    where
        Context<CI>: ContractInteractions,
    {
        let mut used = U256::ZERO;
        data = mask_bytes_dynamic(data, len, context)?;
        used = or(data, mul(U256::from(0x2u128), len, context)?, context)?;
        Ok(used)
    }

    pub fn copy_byte_array_to_storage_from_string_to_string<CI>(slot: U256, src: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        let newLen = array_length_string(src, context)?;
        if gt(newLen, sub(shl(U256::from(0x40u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)? != U256::ZERO {
            panic_error_0x41(context)?;
        }
        let oldLen = extract_byte_array_length(sload(slot, context)?, context)?;
        clean_up_bytearray_end_slots_string_storage(slot, oldLen, newLen, context)?;
        let mut srcOffset = U256::from(0x0u128);
        srcOffset = U256::from(0x20u128);
        // switch
        let δ = gt(newLen, U256::from(0x1fu128), context)?;
        if δ == U256::from(0x1u128) {
            let loopEnd = and(newLen, not(U256::from(0x1fu128), context)?, context)?;
            let mut dstPtr = array_dataslot_string_storage(slot, context)?;
            let mut i = U256::from(0x0u128);
            // for loop
            while lt(i, loopEnd, context)? != U256::ZERO {
                // body
                {
                    sstore(dstPtr, mload(add(src, srcOffset, context)?, context)?, context)?;
                    dstPtr = add(dstPtr, U256::from(0x1u128), context)?;
                    srcOffset = add(srcOffset, U256::from(0x20u128), context)?;
                }
                // post
                {
                    i = add(i, U256::from(0x20u128), context)?;
                }
            }
            if lt(loopEnd, newLen, context)? != U256::ZERO {
                let lastValue = mload(add(src, srcOffset, context)?, context)?;
                sstore(dstPtr, mask_bytes_dynamic(lastValue, and(newLen, U256::from(0x1fu128), context)?, context)?, context)?;
            }
            sstore(slot, add(mul(newLen, U256::from(0x2u128), context)?, U256::from(0x1u128), context)?, context)?;
        }
        Ok(())
    }

    pub fn update_storage_value_offset_string_to_string<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        copy_byte_array_to_storage_from_string_to_string(slot, value, context)?;
        Ok(())
    }

    pub fn constructor_ERC20<CI>(var_name_mpos: U256, var_symbol_mpos: U256, context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        update_storage_value_offset_string_to_string(U256::from(0x3u128), var_name_mpos, context)?;
        update_storage_value_offset_string_to_string(U256::from(0x4u128), var_symbol_mpos, context)?;
        Ok(())
    }

    pub fn copy_arguments_for_constructor_object_ERC20<CI>(context: &mut Context<CI>) -> YulOutput<(U256, U256)>
    where
        Context<CI>: ContractInteractions,
    {
        let mut ret_param = U256::ZERO;
        let mut ret_param_1 = U256::ZERO;
        let programSize = datasize(from_hex("45524332305f3531340000000000000000000000000000000000000000000000"), context)?;
        let argSize = sub(codesize(context)?, programSize, context)?;
        let memoryDataOffset = allocate_memory(argSize, context)?;
        codecopy(memoryDataOffset, programSize, argSize, context)?;
        (ret_param, ret_param_1) = abi_decode_stringt_string_fromMemory(memoryDataOffset, add(memoryDataOffset, argSize, context)?, context)?;
        Ok((ret_param, ret_param_1))
    }

    pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
        Ok(())
    }

    pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
    where
        Context<CI>: ContractInteractions,
    {
        mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
        if callvalue(context)? != U256::ZERO {
            revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
        }
        let (_1, _2) = copy_arguments_for_constructor_object_ERC20(context)?;
        constructor_ERC20(_1, _2, context)?;
        let _3 = allocate_unbounded(context)?;
        codecopy(_3, dataoffset(from_hex("45524332305f3531345f6465706c6f7965640000000000000000000000000000"), context)?, datasize(from_hex("45524332305f3531345f6465706c6f7965640000000000000000000000000000"), context)?, context)?;
        return_(_3, datasize(from_hex("45524332305f3531345f6465706c6f7965640000000000000000000000000000"), context)?, context)?;
        Ok(())
    }

    pub mod erc20_deployed {
        use alloy_primitives::U256;
        use evm_opcodes::*;

        pub fn revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn abi_decode<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x0u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            Ok(())
        }

        pub fn cleanup_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, sub(shl(U256::from(0xa0u128), U256::from(0x1u128), context)?, U256::from(0x1u128), context)?, context)?;
            Ok(cleaned)
        }

        pub fn cleanup_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = cleanup_uint160(value, context)?;
            Ok(cleaned)
        }

        pub fn validator_revert_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_address(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_address<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_address(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn cleanup_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn validator_revert_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if iszero(eq(value, cleanup_uint256(value, context)?, context)?, context)? != U256::ZERO {
                revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn abi_decode_uint256<CI>(offset: U256, end_: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = calldataload(offset, context)?;
            validator_revert_uint256(value, context)?;
            Ok(value)
        }

        pub fn abi_decode_addresst_addresst_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            let mut value2 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x60u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_address(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            value2 = abi_decode_uint256(add(headStart, U256::from(0x40u128), context)?, dataEnd, context)?;
            Ok((value0, value1, value2))
        }

        pub fn abi_decode_addresst_uint256<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<(U256, U256)>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            let mut value1 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x40u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            value1 = abi_decode_uint256(add(headStart, U256::from(0x20u128), context)?, dataEnd, context)?;
            Ok((value0, value1))
        }

        pub fn abi_decode_tuple_address<CI>(headStart: U256, dataEnd: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value0 = U256::ZERO;
            if slt(sub(dataEnd, headStart, context)?, U256::from(0x20u128), context)? != U256::ZERO {
                revert_error_dbdddcbe895c83990c08b3492a0e83918d802a52331272ac6fdb6a7c4aea3b1b(context)?;
            }
            value0 = abi_decode_address(add(headStart, U256::from(0x0u128), context)?, dataEnd, context)?;
            Ok(value0)
        }

        pub fn array_dataslot_string_storage<CI>(ptr: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut data = U256::ZERO;
            data = ptr;
            mstore(U256::from(0x0u128), ptr, context)?;
            data = keccak256(U256::from(0x0u128), U256::from(0x20u128), context)?;
            Ok(data)
        }

        pub fn array_storeLengthForEncoding_string<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn panic_error_0x22<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x22u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn extract_byte_array_length<CI>(data: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = div(data, U256::from(0x2u128), context)?;
            let outOfPlaceEncoding = and(data, U256::from(0x1u128), context)?;
            if iszero(outOfPlaceEncoding, context)? != U256::ZERO {
                length = and(length, U256::from(0x7fu128), context)?;
            }
            if eq(outOfPlaceEncoding, lt(length, U256::from(0x20u128), context)?, context)? != U256::ZERO {
                panic_error_0x22(context)?;
            }
            Ok(length)
        }

        pub fn abi_encode_string_storage<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            let slotValue = sload(value, context)?;
            let length = extract_byte_array_length(slotValue, context)?;
            pos = array_storeLengthForEncoding_string(pos, length, context)?;
            // switch
            let δ = and(slotValue, U256::from(0x1u128), context)?;
            if δ == U256::from(0x0u128) {
                mstore(pos, and(slotValue, not(U256::from(0xffu128), context)?, context)?, context)?;
                ret = add(pos, mul(U256::from(0x20u128), iszero(iszero(length, context)?, context)?, context)?, context)?;
            } else if δ == U256::from(0x1u128) {
                let mut dataPos = array_dataslot_string_storage(value, context)?;
                let mut i = U256::from(0x0u128);
                // for loop
                while lt(i, length, context)? != U256::ZERO {
                    // body
                    {
                        mstore(add(pos, i, context)?, sload(dataPos, context)?, context)?;
                        dataPos = add(dataPos, U256::from(0x1u128), context)?;
                    }
                    // post
                    {
                        i = add(i, U256::from(0x20u128), context)?;
                    }
                }
                ret = add(pos, i, context)?;
            }
            Ok(ret)
        }

        pub fn abi_encodeUpdatedPos_string_storage<CI>(value0: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updatedPos = U256::ZERO;
            updatedPos = abi_encode_string_storage(value0, pos, context)?;
            Ok(updatedPos)
        }

        pub fn abi_encode_address<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_address(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint256_to_uint256<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint256(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_address_uint256_uint256<CI>(headStart: U256, value0: U256, value1: U256, value2: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x60u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value1, add(headStart, U256::from(0x20u128), context)?, context)?;
            abi_encode_uint256_to_uint256(value2, add(headStart, U256::from(0x40u128), context)?, context)?;
            Ok(tail)
        }

        pub fn cleanup_bool<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = iszero(iszero(value, context)?, context)?;
            Ok(cleaned)
        }

        pub fn abi_encode_bool_to_bool<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_bool(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_bool<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_bool_to_bool(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn array_length_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut length = U256::ZERO;
            length = mload(value, context)?;
            Ok(length)
        }

        pub fn array_storeLengthForEncoding_string_fromStack<CI>(pos: U256, length: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut updated_pos = U256::ZERO;
            mstore(pos, length, context)?;
            updated_pos = add(pos, U256::from(0x20u128), context)?;
            Ok(updated_pos)
        }

        pub fn copy_memory_to_memory_with_cleanup<CI>(src: U256, dst: U256, length: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mcopy(dst, src, length, context)?;
            mstore(add(dst, length, context)?, U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn round_up_to_mul_of<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            result = and(add(value, U256::from(0x1fu128), context)?, not(U256::from(0x1fu128), context)?, context)?;
            Ok(result)
        }

        pub fn abi_encode_string_memory_ptr<CI>(value: U256, mut pos: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut end_ = U256::ZERO;
            let length = array_length_string(value, context)?;
            pos = array_storeLengthForEncoding_string_fromStack(pos, length, context)?;
            copy_memory_to_memory_with_cleanup(add(value, U256::from(0x20u128), context)?, pos, length, context)?;
            end_ = add(pos, round_up_to_mul_of(length, context)?, context)?;
            Ok(end_)
        }

        pub fn abi_encode_string<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            mstore(add(headStart, U256::from(0x0u128), context)?, sub(tail, headStart, context)?, context)?;
            tail = abi_encode_string_memory_ptr(value0, tail, context)?;
            Ok(tail)
        }

        pub fn abi_encode_tuple_address<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_address(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn abi_encode_uint256<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint256_to_uint256(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn cleanup_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = and(value, U256::from(0xffu128), context)?;
            Ok(cleaned)
        }

        pub fn abi_encode_uint8_to_uint8<CI>(value: U256, pos: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(pos, cleanup_uint8(value, context)?, context)?;
            Ok(())
        }

        pub fn abi_encode_uint8<CI>(headStart: U256, value0: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut tail = U256::ZERO;
            tail = add(headStart, U256::from(0x20u128), context)?;
            abi_encode_uint8_to_uint8(value0, add(headStart, U256::from(0x0u128), context)?, context)?;
            Ok(tail)
        }

        pub fn allocate_unbounded<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = mload(U256::from(0x40u128), context)?;
            Ok(memPtr)
        }

        pub fn panic_error_0x11<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x11u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn checked_add_uint256<CI>(mut x: U256, mut y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            x = cleanup_uint256(x, context)?;
            y = cleanup_uint256(y, context)?;
            sum = add(x, y, context)?;
            if gt(x, sum, context)? != U256::ZERO {
                panic_error_0x11(context)?;
            }
            Ok(sum)
        }

        pub fn cleanup_from_storage_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn cleanup_t_rational_by<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut cleaned = U256::ZERO;
            cleaned = value;
            Ok(cleaned)
        }

        pub fn identity<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn convert_uint160_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_uint160(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint160_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_address_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_uint160_to_address(value, context)?;
            Ok(converted)
        }

        pub fn panic_error_0x41<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0x4e487b71u128), context)?, context)?;
            mstore(U256::from(0x4u128), U256::from(0x41u128), context)?;
            revert(U256::from(0x0u128), U256::from(0x24u128), context)?;
            Ok(())
        }

        pub fn finalize_allocation<CI>(memPtr: U256, size: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let newFreePtr = add(memPtr, round_up_to_mul_of(size, context)?, context)?;
            if or(gt(newFreePtr, U256::from(0xffffffffffffffffu128), context)?, lt(newFreePtr, memPtr, context)?, context)? != U256::ZERO {
                panic_error_0x41(context)?;
            }
            mstore(U256::from(0x40u128), newFreePtr, context)?;
            Ok(())
        }

        pub fn copy_array_from_storage_to_memory_string<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut memPtr = U256::ZERO;
            memPtr = allocate_unbounded(context)?;
            let end_ = abi_encodeUpdatedPos_string_storage(slot, memPtr, context)?;
            finalize_allocation(memPtr, sub(end_, memPtr, context)?, context)?;
            Ok(memPtr)
        }

        pub fn convert_array_string_storage_to_string<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = copy_array_from_storage_to_memory_string(value, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint160<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint160(identity(cleanup_t_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_address<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = convert_rational_by_to_uint160(value, context)?;
            Ok(converted)
        }

        pub fn convert_rational_by_to_uint8<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint8(identity(cleanup_rational_by(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn convert_uint256_to_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut converted = U256::ZERO;
            converted = cleanup_uint256(identity(cleanup_uint256(value, context)?, context)?, context)?;
            Ok(converted)
        }

        pub fn mapping_index_access_mapping_address_mapping_address_uint256__of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn mapping_index_access_mapping_address_uint256_of_address<CI>(slot: U256, key: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut dataSlot = U256::ZERO;
            mstore(U256::from(0x0u128), convert_address_to_address(key, context)?, context)?;
            mstore(U256::from(0x20u128), slot, context)?;
            dataSlot = keccak256(U256::from(0x0u128), U256::from(0x40u128), context)?;
            Ok(dataSlot)
        }

        pub fn shift_right_0_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn extract_from_storage_value_offset_uint256<CI>(slot_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = cleanup_from_storage_uint256(shift_right_0_unsigned(slot_value, context)?, context)?;
            Ok(value)
        }

        pub fn read_from_storage_split_offset_uint256<CI>(slot: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut value = U256::ZERO;
            value = extract_from_storage_value_offset_uint256(sload(slot, context)?, context)?;
            Ok(value)
        }

        pub fn zero_value_for_split_uint256<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_allowance<CI>(var_owner: U256, var_spender: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_t_uint256;
            let _1 = mapping_index_access_mapping_address_mapping_address_uint256__of_address(U256::from(0x1u128), var_owner, context)?;
            let _2 = mapping_index_access_mapping_address_uint256_of_address(_1, var_spender, context)?;
            let _3 = read_from_storage_split_offset_uint256(_2, context)?;
            var = _3;
            Ok(var)
        }

        pub fn revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn external_fun_allowance<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_allowance(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn prepare_store_uint256<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = value;
            Ok(ret)
        }

        pub fn shift_left<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shl(U256::from(0x0u128), value, context)?;
            Ok(newValue)
        }

        pub fn update_byte_slice_shift<CI>(mut value: U256, mut toInsert: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut result = U256::ZERO;
            let mask = not(U256::from(0x0u128), context)?;
            toInsert = shift_left(toInsert, context)?;
            value = and(value, not(mask, context)?, context)?;
            result = or(value, and(toInsert, mask, context)?, context)?;
            Ok(result)
        }

        pub fn update_storage_value_offset_uint256_to_uint256<CI>(slot: U256, value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let convertedValue = convert_uint256_to_uint256(value, context)?;
            sstore(slot, update_byte_slice_shift(sload(slot, context)?, prepare_store_uint256(convertedValue, context)?, context)?, context)?;
            Ok(())
        }

        pub fn fun_approve_465<CI>(var_owner: U256, var_spender: U256, var_value: U256, var_emitEvent: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_owner, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xe602df05u128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = eq(cleanup_address(var_spender, context)?, cleanup_address(expr, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4a1406b1u128), context)?, context)?;
                let _2 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            let _3 = mapping_index_access_mapping_address_mapping_address_uint256__of_address(U256::from(0x1u128), var_owner, context)?;
            let _4 = mapping_index_access_mapping_address_uint256_of_address(_3, var_spender, context)?;
            update_storage_value_offset_uint256_to_uint256(_4, var_value, context)?;
            if var_emitEvent != U256::ZERO {
                let _5 = convert_address_to_address(var_owner, context)?;
                let _6 = convert_address_to_address(var_spender, context)?;
                let _7 = allocate_unbounded(context)?;
                let _8 = abi_encode_uint256(_7, var_value, context)?;
                log3(_7, sub(_8, _7, context)?, U256::from_be_slice(&[0x8c, 0x5b, 0xe1, 0xe5, 0xeb, 0xec, 0x7d, 0x5b, 0xd1, 0x4f, 0x71, 0x42, 0x7d, 0x1e, 0x84, 0xf3, 0xdd, 0x03, 0x14, 0xc0, 0xf7, 0xb2, 0x29, 0x1e, 0x5b, 0x20, 0x0a, 0xc8, 0xc7, 0xc3, 0xb9, 0x25]), _5, _6, context)?;
            }
            Ok(())
        }

        pub fn fun__approve<CI>(var_owner: U256, var_spender: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            fun_approve_465(var_owner, var_spender, var_value, U256::from(0x1u128), context)?;
            Ok(())
        }

        pub fn zero_value_for_split_address<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_msgSender<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_address = zero_value_for_split_address(context)?;
            var = zero_address;
            var = caller(context)?;
            Ok(var)
        }

        pub fn zero_value_for_split_bool<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_approve<CI>(var_spender: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let expr = fun_msgSender(context)?;
            fun__approve(expr, var_spender, var_value, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_approve<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_approve(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_balanceOf<CI>(var_account: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_ = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var_ = zero_uint256;
            let _1 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_account, context)?;
            let _2 = read_from_storage_split_offset_uint256(_1, context)?;
            var_ = _2;
            Ok(var_)
        }

        pub fn external_fun_balanceOf<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let param = abi_decode_tuple_address(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_balanceOf(param, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_uint8<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x0u128);
            Ok(ret)
        }

        pub fn fun_decimals<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint8 = zero_value_for_split_uint8(context)?;
            var = zero_uint8;
            var = convert_rational_by_to_uint8(U256::from(0x12u128), context)?;
            Ok(var)
        }

        pub fn external_fun_decimals<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_decimals(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint8(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn zero_value_for_split_string<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut ret = U256::ZERO;
            ret = U256::from(0x60u128);
            Ok(ret)
        }

        pub fn fun_name<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var__mpos = U256::ZERO;
            let zero_string_memory_ptr_mpos = zero_value_for_split_string(context)?;
            var__mpos = zero_string_memory_ptr_mpos;
            var__mpos = convert_array_string_storage_to_string(U256::from(0x3u128), context)?;
            Ok(var__mpos)
        }

        pub fn external_fun_name<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_name(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_string(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_symbol<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var_mpos = U256::ZERO;
            let zero_string_mpos = zero_value_for_split_string(context)?;
            var_mpos = zero_string_mpos;
            var_mpos = convert_array_string_storage_to_string(U256::from(0x4u128), context)?;
            Ok(var_mpos)
        }

        pub fn external_fun_symbol<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_symbol(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_string(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_totalSupply<CI>(context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_uint256 = zero_value_for_split_uint256(context)?;
            var = zero_uint256;
            let _1 = read_from_storage_split_offset_uint256(U256::from(0x2u128), context)?;
            var = _1;
            Ok(var)
        }

        pub fn external_fun_totalSupply<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            abi_decode(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_totalSupply(context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_uint256(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn wrapping_add_uint256<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut sum = U256::ZERO;
            sum = cleanup_uint256(add(x, y, context)?, context)?;
            Ok(sum)
        }

        pub fn wrapping_sub_uint256<CI>(x: U256, y: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut diff = U256::ZERO;
            diff = cleanup_uint256(sub(x, y, context)?, context)?;
            Ok(diff)
        }

        pub fn fun_update<CI>(var_from: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_from, context)?, cleanup_address(expr, context)?, context)?;
            // switch
            let δ = expr_1;
            if δ == U256::from(0x0u128) {
                let _1 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_from, context)?;
                let _2 = read_from_storage_split_offset_uint256(_1, context)?;
                let expr_2 = lt(cleanup_uint256(_2, context)?, cleanup_uint256(var_value, context)?, context)?;
                if expr_2 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe2u128), U256::from(0x391434e3u128), context)?, context)?;
                    let _3 = abi_encode_address_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_from, _2, var_value, context)?;
                    revert(U256::from(0x0u128), sub(_3, U256::from(0x0u128), context)?, context)?;
                }
                let expr_3 = wrapping_sub_uint256(_2, var_value, context)?;
                let _4 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_from, context)?;
                update_storage_value_offset_uint256_to_uint256(_4, expr_3, context)?;
            }
            let expr_5 = eq(cleanup_address(var_to, context)?, cleanup_address(expr, context)?, context)?;
            // switch
            let δ = expr_5;
            if δ == U256::from(0x0u128) {
                let _6 = mapping_index_access_mapping_address_uint256_of_address(U256::from(0x0u128), var_to, context)?;
                let _7 = read_from_storage_split_offset_uint256(_6, context)?;
                let expr_6 = wrapping_add_uint256(_7, var_value, context)?;
                update_storage_value_offset_uint256_to_uint256(_6, expr_6, context)?;
            }
            let _9 = convert_address_to_address(var_from, context)?;
            let _10 = convert_address_to_address(var_to, context)?;
            let _11 = allocate_unbounded(context)?;
            let _12 = abi_encode_uint256(_11, var_value, context)?;
            log3(_11, sub(_12, _11, context)?, U256::from_be_slice(&[0xdd, 0xf2, 0x52, 0xad, 0x1b, 0xe2, 0xc8, 0x9b, 0x69, 0xc2, 0xb0, 0x68, 0xfc, 0x37, 0x8d, 0xaa, 0x95, 0x2b, 0xa7, 0xf1, 0x63, 0xc4, 0xa1, 0x16, 0x28, 0xf5, 0x5a, 0x4d, 0xf5, 0x23, 0xb3, 0xef]), _9, _10, context)?;
            Ok(())
        }

        pub fn fun__transfer<CI>(var_from: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = convert_rational_by_to_address(U256::from(0x0u128), context)?;
            let expr_1 = eq(cleanup_address(var_from, context)?, cleanup_address(expr, context)?, context)?;
            if expr_1 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x4b637e8fu128), context)?, context)?;
                let _1 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
            }
            let expr_2 = eq(cleanup_address(var_to, context)?, cleanup_address(expr, context)?, context)?;
            if expr_2 != U256::ZERO {
                mstore(U256::from(0x0u128), shl(U256::from(0xe0u128), U256::from(0xec442f05u128), context)?, context)?;
                let _2 = abi_encode_tuple_address(add(U256::from(0x0u128), U256::from(0x4u128), context)?, expr, context)?;
                revert(U256::from(0x0u128), sub(_2, U256::from(0x0u128), context)?, context)?;
            }
            fun_update(var_from, var_to, var_value, context)?;
            Ok(())
        }

        pub fn fun_transfer<CI>(var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_bool = zero_value_for_split_bool(context)?;
            var = zero_bool;
            let expr = fun_msgSender(context)?;
            fun__transfer(expr, var_to, var_value, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_transfer<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1) = abi_decode_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_transfer(param, param_1, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn fun_spendAllowance<CI>(var_owner: U256, var_spender: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            let expr = fun_allowance(var_owner, var_spender, context)?;
            let expr_1 = lt(cleanup_uint256(expr, context)?, cleanup_uint256(not(U256::from(0x0u128), context)?, context)?, context)?;
            if expr_1 != U256::ZERO {
                let expr_2 = lt(cleanup_uint256(expr, context)?, cleanup_uint256(var_value, context)?, context)?;
                if expr_2 != U256::ZERO {
                    mstore(U256::from(0x0u128), shl(U256::from(0xe1u128), U256::from(0x7dc7a0d9u128), context)?, context)?;
                    let _1 = abi_encode_address_uint256_uint256(add(U256::from(0x0u128), U256::from(0x4u128), context)?, var_spender, expr, var_value, context)?;
                    revert(U256::from(0x0u128), sub(_1, U256::from(0x0u128), context)?, context)?;
                }
                let expr_3 = wrapping_sub_uint256(expr, var_value, context)?;
                fun_approve_465(var_owner, var_spender, expr_3, U256::from(0x0u128), context)?;
            }
            Ok(())
        }

        pub fn fun_transferFrom<CI>(var_from: U256, var_to: U256, var_value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut var = U256::ZERO;
            let zero_t_bool = zero_value_for_split_bool(context)?;
            var = zero_t_bool;
            let expr = fun_msgSender(context)?;
            fun_spendAllowance(var_from, expr, var_value, context)?;
            fun__transfer(var_from, var_to, var_value, context)?;
            var = U256::from(0x1u128);
            Ok(var)
        }

        pub fn external_fun_transferFrom<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            if callvalue(context)? != U256::ZERO {
                revert_error_ca66f745a3ce8ff40e2ccaf1ad45db7774001b90d25810abd9040049be7bf4bb(context)?;
            }
            let (param, param_1, param_2) = abi_decode_addresst_addresst_uint256(U256::from(0x4u128), calldatasize(context)?, context)?;
            let ret = fun_transferFrom(param, param_1, param_2, context)?;
            let memPos = allocate_unbounded(context)?;
            let memEnd = abi_encode_bool(memPos, ret, context)?;
            return_(memPos, sub(memEnd, memPos, context)?, context)?;
            Ok(())
        }

        pub fn revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            revert(U256::from(0x0u128), U256::from(0x0u128), context)?;
            Ok(())
        }

        pub fn shift_right_unsigned<CI>(value: U256, context: &mut Context<CI>) -> YulOutput<U256>
        where
            Context<CI>: ContractInteractions,
        {
            let mut newValue = U256::ZERO;
            newValue = shr(U256::from(0xe0u128), value, context)?;
            Ok(newValue)
        }

        pub fn body<CI>(context: &mut Context<CI>) -> YulOutput<()>
        where
            Context<CI>: ContractInteractions,
        {
            mstore(U256::from(0x40u128), memoryguard(U256::from(0x80u128), context)?, context)?;
            if iszero(lt(calldatasize(context)?, U256::from(0x4u128), context)?, context)? != U256::ZERO {
                let selector = shift_right_unsigned(calldataload(U256::from(0x0u128), context)?, context)?;
                // switch
                let δ = selector;
                if δ == U256::from(0x6fdde03u128) {
                    external_fun_name(context)?;
                } else if δ == U256::from(0x95ea7b3u128) {
                    external_fun_approve(context)?;
                } else if δ == U256::from(0x18160dddu128) {
                    external_fun_totalSupply(context)?;
                } else if δ == U256::from(0x23b872ddu128) {
                    external_fun_transferFrom(context)?;
                } else if δ == U256::from(0x313ce567u128) {
                    external_fun_decimals(context)?;
                } else if δ == U256::from(0x70a08231u128) {
                    external_fun_balanceOf(context)?;
                } else if δ == U256::from(0x95d89b41u128) {
                    external_fun_symbol(context)?;
                } else if δ == U256::from(0xa9059cbbu128) {
                    external_fun_transfer(context)?;
                } else if δ == U256::from(0xdd62ed3eu128) {
                    external_fun_allowance(context)?;
                }
            }
            revert_error_42b3090547df1d2001c96683413b8cf91c1b902ef5e3cb8d9f6f304cf7446f74(context)?;
            Ok(())
        }
    }
}

fn main() {
    let context = Context {
        contract_interactions: std::marker::PhantomData::<DummyContractInteractions>,
        memory: Memory::new(),
        immutables: std::collections::HashMap::new(),
        storage: std::collections::HashMap::new(),
        address: U256::from(123),
        caller: U256::from(124),
        callvalue: U256::from(12),
        gas: U256::from(100 * 1000),
        timestamp: U256::from(1000 * 1000),
        calldata: vec![],
        chain_id: U256::from(123456),
    };

    // let result = exp_unit_test::exp_unit_test_deployed::fun_test_Exp(&mut context);
    // println!("result: {:#?}", result);
    // println!("context: {:#?}", context);
}
